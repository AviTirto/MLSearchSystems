1
00:00:00,000 --> 00:00:03,780
Okay. We're continuing
to talk about cashing.

2
00:00:03,780 --> 00:00:05,400
Last time we learned
a few things.

3
00:00:05,400 --> 00:00:07,980
We learned about these
different cashing policies.

4
00:00:07,980 --> 00:00:12,000
We learned about how we
could take a given workload

5
00:00:12,000 --> 00:00:14,580
and picture of the
cache and kind of trace

6
00:00:14,580 --> 00:00:15,859
through it and figure
out which ones

7
00:00:15,859 --> 00:00:17,300
are hits and which
ones are misses.

8
00:00:17,300 --> 00:00:18,779
There's a few more
examples I want to

9
00:00:18,779 --> 00:00:20,819
wrap up on the worksheet
today with that.

10
00:00:20,819 --> 00:00:23,039
And then the other I want
to practice today is,

11
00:00:23,039 --> 00:00:25,359
how can we actually
go and write Tad,

12
00:00:25,359 --> 00:00:28,380
say in Python to implement
one of these caches.

13
00:00:28,380 --> 00:00:30,779
And that's what you're
doing on this P two,

14
00:00:30,779 --> 00:00:32,079
that's also released today.

15
00:00:32,079 --> 00:00:33,999
So, of course, that will be very

16
00:00:33,999 --> 00:00:36,630
helpful for you as you
do that. Alright, ill.

17
00:00:36,630 --> 00:00:37,849
I may head over here to the

18
00:00:37,849 --> 00:00:40,529
document camera to where
we were last time.

19
00:00:40,529 --> 00:00:45,269
And I had left you with this
problem at the very end.

20
00:00:45,269 --> 00:00:47,609
I'm just trying to work
through it quickly,

21
00:00:47,609 --> 00:00:49,329
and so that if there was

22
00:00:49,329 --> 00:00:50,549
any confusion on the top at

23
00:00:50,549 --> 00:00:52,069
last time, we'll
see how to do it.

24
00:00:52,069 --> 00:00:53,910
Then we'll talk about
some of these statistics.

25
00:00:53,910 --> 00:00:56,610
And then on this back
hand side of the sheet,

26
00:00:56,610 --> 00:01:00,209
there's some limitations of
LRU that I want to show you.

27
00:01:00,209 --> 00:01:03,460
Let me just make
sure. Okay, great.

28
00:01:03,460 --> 00:01:05,329
So let's just work through

29
00:01:05,329 --> 00:01:07,909
this one to refresh our memory.

30
00:01:07,909 --> 00:01:10,510
So the first one is W,

31
00:01:10,510 --> 00:01:12,430
and that, of course, is a mess

32
00:01:12,430 --> 00:01:14,290
because there's nothing
in a cache yet.

33
00:01:14,290 --> 00:01:16,129
So I'll write W up here.

34
00:01:16,129 --> 00:01:18,390
Then I have another
W, and so that would

35
00:01:18,390 --> 00:01:20,850
be a hit. All right.

36
00:01:20,850 --> 00:01:23,910
This is a FIFO. So
when I have a hit,

37
00:01:23,910 --> 00:01:26,189
I don't have to reorganize
this data structure.

38
00:01:26,189 --> 00:01:28,810
I can leave in the
existing organization.

39
00:01:29,130 --> 00:01:32,730
I have x, x is a miss.

40
00:01:32,730 --> 00:01:35,009
I will write x up here.

41
00:01:35,210 --> 00:01:38,790
I have y. Y is a mess,

42
00:01:38,790 --> 00:01:42,329
so I'll put y up here as
well after it misses.

43
00:01:42,329 --> 00:01:44,989
Still size three
SenoiVctions, yet.

44
00:01:44,989 --> 00:01:49,855
Now I have y. Okay,
so y is a hit.

45
00:01:49,855 --> 00:01:53,339
And y is already
considered most recent.

46
00:01:53,339 --> 00:01:55,819
And even if it weren't,

47
00:01:55,819 --> 00:01:57,420
while we're doing FFO,
so it wouldn't matter?

48
00:01:57,420 --> 00:01:59,319
I wouldn't change
the state up here.

49
00:01:59,319 --> 00:02:02,480
Now we have Z, Z is a mess.

50
00:02:02,480 --> 00:02:05,079
And so this point
to add z up here,

51
00:02:05,079 --> 00:02:07,180
we're going over
the size of three,

52
00:02:07,180 --> 00:02:08,659
and so we have to
bump something out

53
00:02:08,659 --> 00:02:11,019
and we bump out from
this side, right?

54
00:02:11,019 --> 00:02:14,659
All right. Now we
have y. Y is a hit.

55
00:02:14,659 --> 00:02:17,339
I'm going to say check here.

56
00:02:17,339 --> 00:02:19,879
I don't change it
because I'm doing FIFO,

57
00:02:19,879 --> 00:02:22,959
and then finally X is a hit.

58
00:02:22,959 --> 00:02:24,480
Right? So, in this case,

59
00:02:24,480 --> 00:02:28,769
there were There are four
hits and four misses,

60
00:02:28,769 --> 00:02:30,810
so the hit rate is 0.5.

61
00:02:30,810 --> 00:02:33,529
Given these statistics,
I might also ask you to

62
00:02:33,529 --> 00:02:36,709
compute what the average
latency is, right?

63
00:02:36,709 --> 00:02:41,070
So these were the
hits, and then misses.

64
00:02:43,020 --> 00:02:52,180
I guess I should say mis rate
equals one -0.5 equals 0.5.

65
00:02:52,340 --> 00:02:54,879
The hit rate, I can

66
00:02:54,879 --> 00:02:56,879
basically do a weighted
average down here.

67
00:02:56,879 --> 00:02:59,839
There's 0.5 hits,
and the latency for

68
00:02:59,839 --> 00:03:04,059
those is 0.1 milliseconds.

69
00:03:04,460 --> 00:03:07,240
I'm just bringing
these down here,

70
00:03:07,240 --> 00:03:14,440
and then that will be plus
0.5 times 20 milliseconds,

71
00:03:14,440 --> 00:03:20,620
which will be 10.05.

72
00:03:20,840 --> 00:03:23,360
Milliseconds, right?
So I might ask you to

73
00:03:23,360 --> 00:03:25,420
compute an average latency,

74
00:03:25,420 --> 00:03:27,779
given some cash and some details

75
00:03:27,779 --> 00:03:30,500
about how long a
miss and a hit take.

76
00:03:30,500 --> 00:03:33,199
An Any questions about that one?

77
00:03:35,600 --> 00:03:40,299
All right. Cool. So we're
going come over to this side.

78
00:03:40,299 --> 00:03:43,759
And this is kind of an
interesting work load.

79
00:03:43,759 --> 00:03:44,920
Let's take a look at here.

80
00:03:44,920 --> 00:03:48,494
It goes three, four,
five, six, seven.

81
00:03:48,494 --> 00:03:51,729
You can imagine that being
some pass over a data set.

82
00:03:51,729 --> 00:03:54,830
And then we go three,
four, five, six, seven.

83
00:03:54,830 --> 00:03:57,349
Again, we're reading the
same data multiple times,

84
00:03:57,349 --> 00:03:58,989
maybe by many passes like that.

85
00:03:58,989 --> 00:04:00,309
There's all kinds of cases where

86
00:04:00,309 --> 00:04:01,909
you might end up
having to do that.

87
00:04:01,909 --> 00:04:04,430
One is in machine learning
in machine learning,

88
00:04:04,430 --> 00:04:06,490
you don't just loop
over your data once

89
00:04:06,490 --> 00:04:08,250
and then end up with a
machine learning model.

90
00:04:08,250 --> 00:04:09,629
A lot of machine learning algims

91
00:04:09,629 --> 00:04:11,490
involve repeatedly passing
over the data, right?

92
00:04:11,490 --> 00:04:14,429
This is a common pattern
we might end up with.

93
00:04:14,429 --> 00:04:16,189
And in this case,

94
00:04:16,189 --> 00:04:17,630
we're trying to
have an LRU to make

95
00:04:17,630 --> 00:04:19,890
this access pattern faster.

96
00:04:19,890 --> 00:04:21,229
So I'm going to go throw

97
00:04:21,229 --> 00:04:22,450
through this a
little bit quickly.

98
00:04:22,450 --> 00:04:23,890
Clearly, the first five

99
00:04:23,890 --> 00:04:25,470
are all the first
time they're seen,

100
00:04:25,470 --> 00:04:30,330
so these have to all
be misses. All right.

101
00:04:30,330 --> 00:04:32,530
And at that point, after
I've done all of these,

102
00:04:32,530 --> 00:04:35,469
I will have let me put
these in the cache.

103
00:04:35,469 --> 00:04:37,010
I'll start walking
a little bit more

104
00:04:37,010 --> 00:04:39,750
slowly, four, five, six.

105
00:04:39,750 --> 00:04:41,230
I just filled the cache with

106
00:04:41,230 --> 00:04:42,769
these that are all misses first.

107
00:04:42,769 --> 00:04:44,809
And when I got to
seven, that was a mess.

108
00:04:44,809 --> 00:04:46,510
And so when I add seven up here,

109
00:04:46,510 --> 00:04:48,489
I actually have
to do an eviction

110
00:04:48,489 --> 00:04:49,789
because it's of
size four, right?

111
00:04:49,789 --> 00:04:53,470
So I'm going to remove
that over there.

112
00:04:53,470 --> 00:04:56,610
Okay. The next one is three,

113
00:04:56,610 --> 00:04:58,849
which is a mess.

114
00:04:58,849 --> 00:05:00,829
And that's actually
very unfortunate

115
00:05:00,829 --> 00:05:03,270
because I literally
just removed three.

116
00:05:03,270 --> 00:05:05,470
Right before I ended
up needing it.

117
00:05:05,470 --> 00:05:08,210
So anyway, well, I'll
just follow the policy.

118
00:05:08,210 --> 00:05:10,910
Add three. I have to bump
out four to do that.

119
00:05:10,910 --> 00:05:15,349
Alright, now I have
four. That's a shame.

120
00:05:15,349 --> 00:05:18,069
Right? I literally
just got rid of four.

121
00:05:18,069 --> 00:05:19,950
So I bring four back in,

122
00:05:19,950 --> 00:05:23,190
and now five is gone. You
see the pattern here?

123
00:05:23,190 --> 00:05:24,630
Right? I just got rid of five.

124
00:05:24,630 --> 00:05:26,530
And so now I get a
mess on five when

125
00:05:26,530 --> 00:05:29,530
five comes back. All right.

126
00:05:29,530 --> 00:05:33,210
Six is a mess, even though
I just got rid of six.

127
00:05:33,210 --> 00:05:37,260
Alright. Seven is a mess.

128
00:05:37,260 --> 00:05:40,159
I just started of seven.
That's unfortunate, right?

129
00:05:40,159 --> 00:05:42,480
And we end up with a
giant zero, right?

130
00:05:42,480 --> 00:05:44,039
So we spent all this
memory on this cash.

131
00:05:44,039 --> 00:05:45,300
We did a bunch of logic in

132
00:05:45,300 --> 00:05:47,220
figuring out what's in the
cache and out of the cash.

133
00:05:47,220 --> 00:05:50,220
And it actually behaved
horribly, right?

134
00:05:50,220 --> 00:05:54,320
And would FIFO behave
any better here?

135
00:05:54,320 --> 00:05:56,780
No, FFO would actually
do the same thing.

136
00:05:56,780 --> 00:05:58,059
So both Five and LRU,

137
00:05:58,059 --> 00:05:59,840
they're trying to have some
like logic behind them,

138
00:05:59,840 --> 00:06:01,940
or they're trying to be
smart in some sense,

139
00:06:01,940 --> 00:06:03,800
you can try to justify that,

140
00:06:03,800 --> 00:06:06,520
but they're actually doing
the worst possible, right?

141
00:06:06,520 --> 00:06:08,519
And so this pattern
shows up sometimes.

142
00:06:08,519 --> 00:06:10,499
I want you to recognize
it when it happens.

143
00:06:10,499 --> 00:06:12,900
And then kind of a dumb policy

144
00:06:12,900 --> 00:06:15,340
like random eviction would
actually do quite well here.

145
00:06:15,340 --> 00:06:17,260
I I did random
eviction, you know,

146
00:06:17,260 --> 00:06:18,639
I would have probably
gotten four out of

147
00:06:18,639 --> 00:06:20,540
five of those last ones, right?

148
00:06:20,540 --> 00:06:22,200
So recognize those cases
where maybe you have to have

149
00:06:22,200 --> 00:06:24,300
a different policy for it.

150
00:06:24,300 --> 00:06:26,739
Any questions about
that pattern?

151
00:06:28,480 --> 00:06:32,260
Let's just see the
same thing down here.

152
00:06:32,260 --> 00:06:35,740
This is the same pattern, but
now I have a size of five.

153
00:06:35,740 --> 00:06:36,760
In this case, I'll kind of

154
00:06:36,760 --> 00:06:37,800
go through quickly again, right?

155
00:06:37,800 --> 00:06:42,779
Of course, the first five
are all going to be misses,

156
00:06:42,779 --> 00:06:44,780
and I'll end up with a
cache like this, three,

157
00:06:44,780 --> 00:06:47,979
four, five, six, seven.

158
00:06:47,979 --> 00:06:50,340
And then at this point,
everything is great, right?

159
00:06:50,340 --> 00:06:53,720
Be my whole dataset fits
in my cache, right?

160
00:06:53,720 --> 00:06:55,319
So three is a hit.

161
00:06:55,319 --> 00:06:56,719
I'll move three to the end,

162
00:06:56,719 --> 00:06:58,560
not that it's going
to matter for this.

163
00:06:58,560 --> 00:07:03,159
Four is a hit. Great, I'll
move four to the end.

164
00:07:03,210 --> 00:07:07,689
Five is a hit. Fantastic.
I'll move five to the end.

165
00:07:07,689 --> 00:07:11,729
Six is a hit. I'll
move six to the end,

166
00:07:11,729 --> 00:07:13,790
and seven is a hit,

167
00:07:13,790 --> 00:07:16,249
and I'll move seven to the end.

168
00:07:16,249 --> 00:07:19,970
Right? And then in this case,
my hit rate is 0.5, right?

169
00:07:19,970 --> 00:07:21,310
So when we have

170
00:07:21,310 --> 00:07:23,049
this type of pattern where
I keep scanning the data,

171
00:07:23,049 --> 00:07:24,669
and I have a cache it tends
to be all or nothing,

172
00:07:24,669 --> 00:07:25,850
either all my data hits in

173
00:07:25,850 --> 00:07:28,209
the cache, and it's
worked straight,

174
00:07:28,209 --> 00:07:30,430
or it's just a little
bit too small,

175
00:07:30,430 --> 00:07:32,929
and then I basically
get zero hits.

176
00:07:32,929 --> 00:07:34,610
Alright, cool. So that was

177
00:07:34,610 --> 00:07:36,650
the worksheet stuff
that I wanted to do.

178
00:07:36,650 --> 00:07:38,209
I'm my head over here now,

179
00:07:38,209 --> 00:07:42,025
and we will actually do some
real programming examples.

180
00:07:42,025 --> 00:07:45,440
And so here I have a
Jupiter notebook running.

181
00:07:45,440 --> 00:07:46,640
This is inside of a container.

182
00:07:46,640 --> 00:07:48,819
I already did the Doc
report forwarding stuff,

183
00:07:48,819 --> 00:07:50,259
the SSH tunnel.

184
00:07:50,259 --> 00:07:51,619
You can review on the old slides

185
00:07:51,619 --> 00:07:53,960
if you want to how
to set all that up.

186
00:07:54,040 --> 00:07:56,660
And I have some starter code

187
00:07:56,660 --> 00:07:58,139
over here that I'm ma to
use for this example.

188
00:07:58,139 --> 00:07:59,339
So I'm going to
head to resources

189
00:07:59,339 --> 00:08:00,820
and the lecture snippets.

190
00:08:00,820 --> 00:08:03,360
And right now we're
on Lecture nine.

191
00:08:03,360 --> 00:08:05,620
So I'm man copy this stuff
and just try to talk you

192
00:08:05,620 --> 00:08:08,640
through the problem as
we look at the code.

193
00:08:08,640 --> 00:08:09,980
So I'm going to get
this over here.

194
00:08:09,980 --> 00:08:12,320
I'm just going to split this up.

195
00:08:12,840 --> 00:08:18,010
L, so let me get a little
bit more room on the screen.

196
00:08:18,010 --> 00:08:22,739
Okay, that's fine. So I'm
importing a few Python modules.

197
00:08:22,739 --> 00:08:24,280
I'm going to have
to do some random

198
00:08:24,280 --> 00:08:25,859
number generation
for this example.

199
00:08:25,859 --> 00:08:28,920
Request, lets me
do HGDP requests.

200
00:08:28,920 --> 00:08:31,599
And then Pandas, most of you
probably have seen Pandas,

201
00:08:31,599 --> 00:08:32,360
but if you're coming from

202
00:08:32,360 --> 00:08:33,979
the Java side,
then probably not.

203
00:08:33,979 --> 00:08:35,379
That gives us data frames that

204
00:08:35,379 --> 00:08:37,455
are basically tables of data.

205
00:08:37,455 --> 00:08:39,730
Okay. And what we're starting

206
00:08:39,730 --> 00:08:41,809
with is this URL
right here and I

207
00:08:41,809 --> 00:08:43,950
can see that we're
doing an HTDP request

208
00:08:43,950 --> 00:08:46,030
to get the data
off of this page.

209
00:08:46,030 --> 00:08:48,070
Let me show you what
is on this page.

210
00:08:48,070 --> 00:08:49,810
It's a bunch of IDs

211
00:08:49,810 --> 00:08:52,709
corresponding to weather
stations, right?

212
00:08:52,709 --> 00:08:54,209
And so what I may
imagine is that

213
00:08:54,209 --> 00:08:55,949
I'm building some
kind of application

214
00:08:55,949 --> 00:08:57,870
that occasionally has to fetch

215
00:08:57,870 --> 00:08:59,810
data from different
weather stations.

216
00:08:59,810 --> 00:09:01,769
And sometimes the application
will actually go back and

217
00:09:01,769 --> 00:09:04,429
fetch the same data from
the same weather station,

218
00:09:04,429 --> 00:09:06,750
hence thing might
be useful, right?

219
00:09:06,750 --> 00:09:09,789
I have to download all this
data off of some website.

220
00:09:09,789 --> 00:09:12,569
And so if I actually
come down here,

221
00:09:13,240 --> 00:09:19,620
I can see that there are
all these CS G CSV GZ file,

222
00:09:19,620 --> 00:09:21,620
so GZ is a compression
technique.

223
00:09:21,620 --> 00:09:23,700
And so these are basically
compressed tables.

224
00:09:23,700 --> 00:09:27,620
And so what I can do is
each of these is basically

225
00:09:27,620 --> 00:09:30,239
referring to some weather

226
00:09:30,239 --> 00:09:32,379
station data that
I might download.

227
00:09:32,379 --> 00:09:33,899
So straight paste this here.

228
00:09:33,899 --> 00:09:36,879
I could do that and then would
try to download it for me.

229
00:09:36,879 --> 00:09:41,399
Okay. So I have

230
00:09:41,399 --> 00:09:42,319
the code down here that

231
00:09:42,319 --> 00:09:43,799
actually reads one
of these things in,

232
00:09:43,799 --> 00:09:45,419
so PD, that's Pandas,

233
00:09:45,419 --> 00:09:48,879
is able to read CSV files
directly from the Internet.

234
00:09:48,879 --> 00:09:52,000
So that's cool. There's a
bunch of columns in there.

235
00:09:52,000 --> 00:09:53,199
I'm going to get a
subset of those.

236
00:09:53,199 --> 00:09:55,340
We're talking about worry
too much what is there.

237
00:09:55,340 --> 00:09:59,224
CSV files only contain strings.

238
00:09:59,224 --> 00:10:01,189
But maybe weather
data might have

239
00:10:01,189 --> 00:10:02,909
some floats or things like
that if I'm trying to say,

240
00:10:02,909 --> 00:10:05,369
how much snow was there,
that would be a float.

241
00:10:05,369 --> 00:10:07,530
And so Pandas is doing something

242
00:10:07,530 --> 00:10:09,490
called schema and
foram will revisit.

243
00:10:09,490 --> 00:10:10,929
Basically, it's trying to scan

244
00:10:10,929 --> 00:10:12,989
all the strings in a column
and try to see like,

245
00:10:12,989 --> 00:10:17,010
a, All those strings look
suspiciously like float.

246
00:10:17,010 --> 00:10:18,310
Let's make a float column.

247
00:10:18,310 --> 00:10:19,450
That can take a lot of memory.

248
00:10:19,450 --> 00:10:20,869
And so if I don't say that, Hey,

249
00:10:20,869 --> 00:10:22,429
I have lots of
memory, then I'm just

250
00:10:22,429 --> 00:10:24,249
trying to get some errors
and warnings about it.

251
00:10:24,249 --> 00:10:26,069
So I just do that to
kind of suppress that.

252
00:10:26,069 --> 00:10:27,730
So this is reading
that in down there.

253
00:10:27,730 --> 00:10:28,929
Maybe I'll just grab one of

254
00:10:28,929 --> 00:10:30,129
these stations and show you what

255
00:10:30,129 --> 00:10:31,709
a data frame looks like

256
00:10:31,709 --> 00:10:33,629
if you haven't seen
it before, right?

257
00:10:33,629 --> 00:10:39,145
So here, I should actually
run this thing, right?

258
00:10:39,145 --> 00:10:41,339
So here I would get

259
00:10:41,339 --> 00:10:43,040
this data frame, and
I can see it here.

260
00:10:43,040 --> 00:10:46,479
It basically is like a table
that I can program with.

261
00:10:46,479 --> 00:10:48,019
Okay, so that was the
first piece, right?

262
00:10:48,019 --> 00:10:49,400
I'm getting that list, and then

263
00:10:49,400 --> 00:10:50,960
somehow what I want
to do instead of hard

264
00:10:50,960 --> 00:10:52,299
cutting this in is I want to

265
00:10:52,299 --> 00:10:54,459
have some kind of workload
I'm working with.

266
00:10:54,459 --> 00:10:55,879
I don't want to, you know,

267
00:10:55,879 --> 00:10:57,739
contrive some
complicated application.

268
00:10:57,739 --> 00:11:00,339
So this is a little bit
synthetic what I'm doing.

269
00:11:00,339 --> 00:11:01,599
What I'm going to do
is I'm going to take

270
00:11:01,599 --> 00:11:03,559
all the text off
of that web page,

271
00:11:03,559 --> 00:11:04,999
and I'm may have split it.

272
00:11:04,999 --> 00:11:07,060
So I basically get a list
of all these stations.

273
00:11:07,060 --> 00:11:10,080
Let me just take a look at
the stations down here.

274
00:11:10,080 --> 00:11:11,660
I'm going to get a Python list

275
00:11:11,660 --> 00:11:13,245
of all these different stations.

276
00:11:13,245 --> 00:11:15,390
And then you can see on
this line and I'm taking

277
00:11:15,390 --> 00:11:18,549
a sample to get ten of
those stations, right?

278
00:11:18,549 --> 00:11:22,330
So I have ten stations here,
just randomly selected.

279
00:11:22,330 --> 00:11:23,949
And then what I'm
going to do is I'm

280
00:11:23,949 --> 00:11:25,949
going to randomly
generate a work.

281
00:11:25,949 --> 00:11:27,330
Normally, this would
be kind of just based

282
00:11:27,330 --> 00:11:28,530
on what the application
is actually doing,

283
00:11:28,530 --> 00:11:31,229
but I'm just simulating that.

284
00:11:31,229 --> 00:11:33,630
And so I'm randomly
selecting stations,

285
00:11:33,630 --> 00:11:35,510
100 stations from
this list of ten,

286
00:11:35,510 --> 00:11:38,409
so there'll be some sampling
with replacement there.

287
00:11:38,409 --> 00:11:40,929
And maybe you can see
that here, for example,

288
00:11:40,929 --> 00:11:43,280
if I actually look
at the workload,

289
00:11:43,280 --> 00:11:47,169
And maybe if I kind of
print something like this,

290
00:11:47,169 --> 00:11:48,770
I can see it a
little bit better.

291
00:11:48,770 --> 00:11:50,670
If I see the series of requests,

292
00:11:50,670 --> 00:11:52,309
there's going to be a
bunch of repeats here.

293
00:11:52,309 --> 00:11:53,629
So, for example, like,

294
00:11:53,629 --> 00:11:56,249
this station is going to
show up multiple times,

295
00:11:56,249 --> 00:11:58,429
right because from these
ten stations, right?

296
00:11:58,429 --> 00:11:59,950
I'm sampling 100.

297
00:11:59,950 --> 00:12:02,010
I'm not doing it uniform random.

298
00:12:02,010 --> 00:12:03,610
I'm kind of passing
in some weights.

299
00:12:03,610 --> 00:12:05,249
So there's two stations

300
00:12:05,249 --> 00:12:07,050
that are a little more
popular than others.

301
00:12:07,050 --> 00:12:10,710
One has a 30% probability of
getting chosen or one 20%,

302
00:12:10,710 --> 00:12:12,109
and then the rest
all kind of have

303
00:12:12,109 --> 00:12:14,709
a smaller equal probability
of getting chosen.

304
00:12:14,709 --> 00:12:15,990
So anyway, so I kind of generate

305
00:12:15,990 --> 00:12:18,149
this workload, and our droll is,

306
00:12:18,149 --> 00:12:20,030
we're going to loop over all
of these, and each of them,

307
00:12:20,030 --> 00:12:22,950
we need to get one of these
data frames and memory.

308
00:12:22,950 --> 00:12:24,369
And the slow way
to do that is to

309
00:12:24,369 --> 00:12:25,910
download it again
from the Internet.

310
00:12:25,910 --> 00:12:28,850
But if there are some that
are appearing frequently,

311
00:12:28,850 --> 00:12:30,329
we want to have a
cache that would

312
00:12:30,329 --> 00:12:31,849
help us remember those.

313
00:12:31,849 --> 00:12:35,549
Okay? So that's the setup
we're working with here.

314
00:12:35,549 --> 00:12:37,909
A other details, I should
just fall out quick.

315
00:12:37,909 --> 00:12:40,049
Sometimes when you send a
request to a server, right?

316
00:12:40,049 --> 00:12:41,929
I'm asking for this.
It might send me

317
00:12:41,929 --> 00:12:44,090
back a valid response
that's like a four oh four,

318
00:12:44,090 --> 00:12:45,570
like page missing or something.

319
00:12:45,570 --> 00:12:48,480
And I could pull the text
off like the error message.

320
00:12:48,480 --> 00:12:49,969
This means that if I get

321
00:12:49,969 --> 00:12:51,149
kind of a weird
status like that,

322
00:12:51,149 --> 00:12:52,250
I actually want to
have an exception.

323
00:12:52,250 --> 00:12:54,150
Now, I don't want to
keep going with my code.

324
00:12:54,150 --> 00:12:56,669
Alright, you know, I know
most of you know Python,

325
00:12:56,669 --> 00:12:57,550
but some people are coming from

326
00:12:57,550 --> 00:12:58,830
a java background
and this is new.

327
00:12:58,830 --> 00:13:01,090
I'm not trying to spend a
lot of time teaching Python.

328
00:13:01,090 --> 00:13:02,669
But if there's
questions about stuff

329
00:13:02,669 --> 00:13:03,449
that's going to prevent you

330
00:13:03,449 --> 00:13:04,750
from understanding the example,

331
00:13:04,750 --> 00:13:06,109
you know, feel free to ask.

332
00:13:06,109 --> 00:13:11,269
Does anybody have any
questions so far? Right.

333
00:13:11,269 --> 00:13:13,630
Fantastic. So I
have this workload,

334
00:13:13,630 --> 00:13:16,089
and the way I'm
going to work with

335
00:13:16,089 --> 00:13:19,630
this is that instead of
directly reading the CSV,

336
00:13:19,630 --> 00:13:22,750
I'm going to write a
function called G station,

337
00:13:22,750 --> 00:13:24,810
and it's star to
take a station name,

338
00:13:24,810 --> 00:13:28,809
and it's starting to return
some data frame, right?

339
00:13:28,809 --> 00:13:30,970
I'll come back to
that. And the reason

340
00:13:30,970 --> 00:13:32,570
I often do this is a
function is that then

341
00:13:32,570 --> 00:13:33,849
if everybody like in

342
00:13:33,849 --> 00:13:35,870
this code base is
using that function,

343
00:13:35,870 --> 00:13:37,569
then I can just add some caching

344
00:13:37,569 --> 00:13:39,469
functionality to
that function later,

345
00:13:39,469 --> 00:13:41,230
and nobody has to
change their code.

346
00:13:41,230 --> 00:13:43,269
Their code will just start
running a little bit faster,

347
00:13:43,269 --> 00:13:45,250
but they don't have
to make any changes.

348
00:13:45,250 --> 00:13:46,549
So I think the first version I'm

349
00:13:46,549 --> 00:13:47,949
going to do is not going
to have any caching.

350
00:13:47,949 --> 00:13:49,689
I'm just going to come here, and

351
00:13:49,689 --> 00:13:51,850
I am going to grab
that data frame,

352
00:13:51,850 --> 00:13:54,029
and I'm just going to
return it down here.

353
00:13:54,029 --> 00:13:57,830
And I'm just going to make
sure my function is working.

354
00:13:57,830 --> 00:14:00,275
I'm going to say data frame.

355
00:14:00,275 --> 00:14:02,820
Let's say if I do
like a get station

356
00:14:02,820 --> 00:14:04,899
with that station, does it work.

357
00:14:04,899 --> 00:14:07,460
Only if I define
my function first,

358
00:14:07,460 --> 00:14:09,980
and then it works straight.

359
00:14:09,980 --> 00:14:11,840
You know, we're going to
be doing a bunch of well,

360
00:14:11,840 --> 00:14:14,659
actually, let me do this
now. Let's extend this.

361
00:14:14,659 --> 00:14:19,360
I'm going to say four
station and my workload.

362
00:14:19,360 --> 00:14:21,260
Remember my workload up here,

363
00:14:21,260 --> 00:14:24,099
that's this thing up here.

364
00:14:24,099 --> 00:14:28,085
For each station in the
workload, put this in here too.

365
00:14:28,085 --> 00:14:31,049
I'm going to try to get
the station, right?

366
00:14:31,049 --> 00:14:32,789
So I'm gonna get some
data frame for it.

367
00:14:32,789 --> 00:14:35,289
And then I don't know, maybe
phono I'll just print off

368
00:14:35,289 --> 00:14:37,570
the station and how many rows

369
00:14:37,570 --> 00:14:39,110
there are. It could be whatever.

370
00:14:39,110 --> 00:14:40,849
I could do that. Now, one

371
00:14:40,849 --> 00:14:42,110
of the things that you're
going to find is when you're

372
00:14:42,110 --> 00:14:43,229
working with big data sets is

373
00:14:43,229 --> 00:14:45,130
your code might take
a long time to run,

374
00:14:45,130 --> 00:14:46,710
and that's not good for kind

375
00:14:46,710 --> 00:14:48,230
of interactively
debugging things.

376
00:14:48,230 --> 00:14:50,009
And so one thing I'll
recommend you do,

377
00:14:50,009 --> 00:14:51,789
right instead of just
running your code like that.

378
00:14:51,789 --> 00:14:53,910
Find a small subset
of your big data

379
00:14:53,910 --> 00:14:56,930
set and program and
develop on that first.

380
00:14:56,930 --> 00:14:58,670
And then after that's working,

381
00:14:58,670 --> 00:15:01,930
and then go back to the full
data set. Alright, so great.

382
00:15:01,930 --> 00:15:03,430
I'll just start with five,
and after that's working,

383
00:15:03,430 --> 00:15:05,769
I'll eventually go
to the whole thing.

384
00:15:05,769 --> 00:15:07,450
Alright, so I have a function.

385
00:15:07,450 --> 00:15:08,650
The returns a data frame.

386
00:15:08,650 --> 00:15:10,410
There's no caching involved yet.

387
00:15:10,410 --> 00:15:11,949
And so now I want to

388
00:15:11,949 --> 00:15:13,869
introduce some kind
of caching in here.

389
00:15:13,869 --> 00:15:15,110
And when you're doing caching,

390
00:15:15,110 --> 00:15:17,210
there's basically two pieces
of code you have to write.

391
00:15:17,210 --> 00:15:19,070
You have to say, what
happens when there's a hit,

392
00:15:19,070 --> 00:15:21,149
and what happens if
there's a mess, right?

393
00:15:21,149 --> 00:15:22,849
So if there's a hit,

394
00:15:22,849 --> 00:15:25,089
I'll do something down here.

395
00:15:25,089 --> 00:15:27,949
Otherwise, it's a mess, right?

396
00:15:27,949 --> 00:15:30,489
And then I'll do something
down here, right?

397
00:15:30,489 --> 00:15:33,689
Maybe I'll just kind of
print miss down here,

398
00:15:33,689 --> 00:15:36,049
and then I'll print hit up here.

399
00:15:36,049 --> 00:15:39,595
All right. And then I'll figure
out what to put in there.

400
00:15:39,595 --> 00:15:41,539
All right, so what I'm going to

401
00:15:41,539 --> 00:15:44,259
do to figure out if
there's a hit is I have to

402
00:15:44,259 --> 00:15:46,259
have some kind of data
structure that keeps track of

403
00:15:46,259 --> 00:15:49,500
all the data that I'm
currently caching.

404
00:15:49,500 --> 00:15:51,239
And a good data
structure for that is

405
00:15:51,239 --> 00:15:53,939
often Python dictionary, right?

406
00:15:53,939 --> 00:15:55,900
Because it can
have values in it.

407
00:15:55,900 --> 00:15:57,280
To can be the
things I'm caching.

408
00:15:57,280 --> 00:15:58,160
And when you have a cache,

409
00:15:58,160 --> 00:15:59,240
you usually have
to have some way

410
00:15:59,240 --> 00:16:01,359
of labeling specific
entries, right?

411
00:16:01,359 --> 00:16:02,780
So if I have a name
for them or whatever,

412
00:16:02,780 --> 00:16:03,619
I can look them up.

413
00:16:03,619 --> 00:16:05,639
And if you're writing
a dictionary like

414
00:16:05,639 --> 00:16:07,800
this for caching or otherwise,

415
00:16:07,800 --> 00:16:09,739
I think a really useful
python comment that's

416
00:16:09,739 --> 00:16:11,819
just brief is to say what
the keys and values are.

417
00:16:11,819 --> 00:16:14,380
So for me, the key will
be a station name,

418
00:16:14,380 --> 00:16:21,939
and the value will be weather
data frame for it, right?

419
00:16:21,939 --> 00:16:23,899
I may have that.
And then when I'm

420
00:16:23,899 --> 00:16:25,899
down here and I have a
station name like this.

421
00:16:25,899 --> 00:16:28,339
Actually, I should
pulled that in.

422
00:16:28,339 --> 00:16:30,060
When I have a station name

423
00:16:30,060 --> 00:16:31,719
coming in, it's one
of these strings.

424
00:16:31,719 --> 00:16:32,539
What I can do is I can

425
00:16:32,539 --> 00:16:33,839
check if it's one
of the keys, right?

426
00:16:33,839 --> 00:16:35,519
So I station is in

427
00:16:35,519 --> 00:16:38,440
cash dot keys, then
that would be a hit.

428
00:16:38,440 --> 00:16:40,820
And Python, I can do this a
little bit more concisely.

429
00:16:40,820 --> 00:16:42,699
If I just check if something
is in a dictionary,

430
00:16:42,699 --> 00:16:45,480
what it's checking is, is
that key in a dictionary?

431
00:16:45,480 --> 00:16:49,079
Right? So I'll check, is
it like a hit or a miss?

432
00:16:49,079 --> 00:16:51,560
And and so far so good.

433
00:16:51,560 --> 00:16:54,579
And so this code right
here that I wrote before,

434
00:16:54,579 --> 00:16:57,600
I figure out which of these
two areas I should put it.

435
00:16:57,600 --> 00:16:59,240
So should I put this code

436
00:16:59,240 --> 00:17:01,879
under the hit part
or the mis part?

437
00:17:02,810 --> 00:17:06,109
Yeah, right here. Miss
part. Excellent, right?

438
00:17:06,109 --> 00:17:08,789
So the miss is when we have
to do the long slow thing.

439
00:17:08,789 --> 00:17:11,609
And that's what
this is right here.

440
00:17:11,609 --> 00:17:12,929
This is where we actually
have to go out to

441
00:17:12,929 --> 00:17:14,230
the Internet and
download something,

442
00:17:14,230 --> 00:17:16,009
and that slow, and

443
00:17:16,009 --> 00:17:18,809
we don't want to do it
any more than we have to.

444
00:17:18,809 --> 00:17:21,989
Alright. When we do

445
00:17:21,989 --> 00:17:23,650
have to go out and
find some data

446
00:17:23,650 --> 00:17:25,749
to the Internet like this
and do this slow thing,

447
00:17:25,749 --> 00:17:27,749
we want to remember it.

448
00:17:27,749 --> 00:17:29,049
So now would be a good time to

449
00:17:29,049 --> 00:17:30,210
store that data in our cash.

450
00:17:30,210 --> 00:17:31,710
I'll take the question
just a minute.

451
00:17:31,710 --> 00:17:34,229
So this point, I
can say, cache of

452
00:17:34,229 --> 00:17:36,649
the station is going to equal

453
00:17:36,649 --> 00:17:40,289
this data frame I found.
Yeah, cash right here.

454
00:17:48,530 --> 00:17:50,869
Yeah, that's an excellent
question, right?

455
00:17:50,869 --> 00:17:52,190
So this can kind
of you're saying,

456
00:17:52,190 --> 00:17:53,549
this can remember
things, but, like,

457
00:17:53,549 --> 00:17:55,230
how would I ever evix something?

458
00:17:55,230 --> 00:17:56,450
I'll just keep writing the code

459
00:17:56,450 --> 00:17:58,389
until it ends up looking like

460
00:17:58,389 --> 00:18:02,289
a real cash implementation
that has an eviction with it.

461
00:18:02,289 --> 00:18:04,209
So yeah, I'll get
there. Thank you.

462
00:18:04,209 --> 00:18:08,670
Yeah, other questions
people have so far. Cool.

463
00:18:08,670 --> 00:18:11,049
So far so good. I'm going
to put that in there.

464
00:18:11,049 --> 00:18:13,690
And then up here, what
I could do is I could

465
00:18:13,690 --> 00:18:17,249
return whatever that
entry is, right?

466
00:18:17,249 --> 00:18:18,669
That's one of the
things I could do.

467
00:18:18,669 --> 00:18:22,949
You know, Every program
rule has exceptions.

468
00:18:22,949 --> 00:18:24,349
I'm going to kind of say
something that I would

469
00:18:24,349 --> 00:18:25,889
consider good
guidance in general,

470
00:18:25,889 --> 00:18:27,090
but it has exceptions.

471
00:18:27,090 --> 00:18:28,409
It's usually nice if you just

472
00:18:28,409 --> 00:18:31,689
return from one
place in the code.

473
00:18:31,689 --> 00:18:34,349
One reason for that is
later, for example,

474
00:18:34,349 --> 00:18:36,190
I'm going to try to time how

475
00:18:36,190 --> 00:18:38,689
long it takes to get
a station, right?

476
00:18:38,689 --> 00:18:40,609
I'm going to put a
big time around that.

477
00:18:40,609 --> 00:18:42,029
If I'm returning in the middle,

478
00:18:42,029 --> 00:18:43,910
then it's a little bit
hard to do that timing.

479
00:18:43,910 --> 00:18:45,369
Instead of just
returning that directly,

480
00:18:45,369 --> 00:18:47,770
I'm going to put that
in a data frame,

481
00:18:47,770 --> 00:18:49,269
and I'll have return
at one point, right?

482
00:18:49,269 --> 00:18:50,730
So either way I
get a data frame,

483
00:18:50,730 --> 00:18:53,489
and then I return it
down here here at let's

484
00:18:53,489 --> 00:18:56,860
just run that and I see
that I have some misses.

485
00:18:56,860 --> 00:18:59,770
And then at the very
end, I have a hit.

486
00:18:59,770 --> 00:19:01,969
And is that right? So I
guess, like, right now,

487
00:19:01,969 --> 00:19:03,069
I don't have any limit on how

488
00:19:03,069 --> 00:19:04,369
many cash entries I can have.

489
00:19:04,369 --> 00:19:07,889
And so these four
are all unique.

490
00:19:07,889 --> 00:19:11,769
And then this one was a repeat
from what I saw earlier.

491
00:19:11,769 --> 00:19:13,629
So that makes sense that
that would be a hit.

492
00:19:13,629 --> 00:19:17,709
Okay. Now, you know,

493
00:19:17,709 --> 00:19:19,149
when you're doing the
project, you're kind of

494
00:19:19,149 --> 00:19:20,090
building a cash in general,

495
00:19:20,090 --> 00:19:21,069
you're going to
have bugs, right?

496
00:19:21,069 --> 00:19:22,704
Everybody has bugs, and

497
00:19:22,704 --> 00:19:24,520
Maybe you're running
like the auto greater,

498
00:19:24,520 --> 00:19:25,900
and you're like, Oh, I
have this number of hits.

499
00:19:25,900 --> 00:19:27,880
The auto grader says
that number of hits.

500
00:19:27,880 --> 00:19:30,079
It's kind of hard to know
where to start from that.

501
00:19:30,079 --> 00:19:31,800
I think the way you
debug these things

502
00:19:31,800 --> 00:19:33,700
is you look at you print a bunch

503
00:19:33,700 --> 00:19:35,379
of stuff out and you
kind of look I the

504
00:19:35,379 --> 00:19:37,339
cash doing what I expect to do?

505
00:19:37,339 --> 00:19:38,859
Think carefully about
what you expect,

506
00:19:38,859 --> 00:19:40,159
and then print some stuff off

507
00:19:40,159 --> 00:19:41,379
and make sure it's doing, right?

508
00:19:41,379 --> 00:19:43,039
So I just print like one example

509
00:19:43,039 --> 00:19:44,779
of what I was expecting to do.

510
00:19:44,779 --> 00:19:47,079
I may have more prints
of that nature.

511
00:19:47,079 --> 00:19:50,079
I'm just trying to clean this
up a little bit down here.

512
00:19:50,079 --> 00:19:51,480
And you know what
the other handma

513
00:19:51,480 --> 00:19:52,799
make it a little less confusing.

514
00:19:52,799 --> 00:19:54,640
I'm maya print the station name.

515
00:19:54,640 --> 00:19:56,199
And then after that,

516
00:19:56,199 --> 00:19:57,539
we'll see if that was a hit

517
00:19:57,539 --> 00:19:59,244
or a mess, right?
So I can do that.

518
00:19:59,244 --> 00:20:01,929
And so I can see that
this station was

519
00:20:01,929 --> 00:20:04,849
the first one that
was a hit. All right.

520
00:20:04,849 --> 00:20:07,069
Fantastic. And you know,

521
00:20:07,069 --> 00:20:08,749
if you have lots of memory,

522
00:20:08,749 --> 00:20:10,249
Code like this is actually

523
00:20:10,249 --> 00:20:11,469
useful in lots of places, right?

524
00:20:11,469 --> 00:20:13,769
Maybe all the data
frames fit in memory,

525
00:20:13,769 --> 00:20:15,209
and I could just stop here.

526
00:20:15,209 --> 00:20:16,409
I see code like
this all the time.

527
00:20:16,409 --> 00:20:18,029
It'd be a reasonable
thing to do.

528
00:20:18,029 --> 00:20:21,869
We're going to pretend that
we're tight on memory.

529
00:20:21,869 --> 00:20:24,350
And so we want to limit

530
00:20:24,350 --> 00:20:26,669
how many entries can
be in here, right?

531
00:20:26,669 --> 00:20:29,369
So I'm going to say cash size

532
00:20:29,369 --> 00:20:31,129
is let's start with like three.

533
00:20:31,129 --> 00:20:32,390
We can say we can have at most

534
00:20:32,390 --> 00:20:34,494
three cash entries in here.

535
00:20:34,494 --> 00:20:38,779
And then what we'll do
is when we have a mess,

536
00:20:38,779 --> 00:20:42,419
we're bringing something
in to that cache.

537
00:20:42,419 --> 00:20:46,059
And then we have to then
we have to figure out,

538
00:20:46,059 --> 00:20:47,479
do we have to evict
something, right?

539
00:20:47,479 --> 00:20:50,359
Do we have to evect, right?

540
00:20:50,359 --> 00:20:52,999
So maybe maybe after
I added this in,

541
00:20:52,999 --> 00:20:54,740
maybe there's like
four entries in there,

542
00:20:54,740 --> 00:20:56,259
but I'm only supposed
to have three.

543
00:20:56,259 --> 00:20:58,279
Right? So what I can
say is if the length of

544
00:20:58,279 --> 00:21:01,199
cash is greater
than the cash size,

545
00:21:01,199 --> 00:21:03,919
then indeed I do
have to ev, right?

546
00:21:03,919 --> 00:21:07,539
I have to say a victim
equals something.

547
00:21:07,539 --> 00:21:09,419
Who knows what that is. And then

548
00:21:09,419 --> 00:21:11,924
what I can do is
I can say cash p

549
00:21:11,924 --> 00:21:14,909
That. In this case, the
victim will be a key in

550
00:21:14,909 --> 00:21:17,749
the picture and I'll
remove it, right?

551
00:21:17,749 --> 00:21:22,269
So we have to have some kind
of eviction logic here.

552
00:21:22,269 --> 00:21:24,749
And when we do that, we often
have to have some kind of

553
00:21:24,749 --> 00:21:27,719
extra bookkeeping
going on, right?

554
00:21:27,719 --> 00:21:29,139
So let's try to figure out how

555
00:21:29,139 --> 00:21:30,559
to have some extra
bookkeeping here.

556
00:21:30,559 --> 00:21:31,879
What I might do is when

557
00:21:31,879 --> 00:21:33,379
we were doing the
worksheets, right?

558
00:21:33,379 --> 00:21:36,839
We had that area where we had
a bunch of entries in it,

559
00:21:36,839 --> 00:21:38,079
and we would kind
of keep track of

560
00:21:38,079 --> 00:21:39,999
what different entries
were in there.

561
00:21:39,999 --> 00:21:42,299
So I might do something
analogous to that on the code,

562
00:21:42,299 --> 00:21:44,680
and I'm may represent
that with a list.

563
00:21:44,680 --> 00:21:47,240
And Som call my list eviction,

564
00:21:47,240 --> 00:21:49,300
maybe I'll just
call evict order,

565
00:21:49,300 --> 00:21:51,280
and that will be a list.

566
00:21:51,280 --> 00:21:52,579
I'll kind of keep track when

567
00:21:52,579 --> 00:21:54,659
somebody gets pumped out, which
side will they come from?

568
00:21:54,659 --> 00:21:55,959
Maybe I'll make a
note here, right?

569
00:21:55,959 --> 00:21:58,480
So evict from left.

570
00:21:58,480 --> 00:22:02,740
Try to keep right hand side.

571
00:22:03,080 --> 00:22:06,219
Entries in memory, right?

572
00:22:06,219 --> 00:22:09,479
Is my goal here. All right.

573
00:22:09,479 --> 00:22:10,959
And so I'm going to have to

574
00:22:10,959 --> 00:22:13,119
do some bookkeeping with this.

575
00:22:13,320 --> 00:22:17,199
Here, I guess I am adding.

576
00:22:17,199 --> 00:22:21,920
I'm adding that station into
this primary data structure.

577
00:22:21,920 --> 00:22:23,420
And so what I should also

578
00:22:23,420 --> 00:22:24,959
do at that point is
I should figure out

579
00:22:24,959 --> 00:22:28,119
for this new entry,
where should I put it?

580
00:22:28,119 --> 00:22:29,619
So I'm going to put in

581
00:22:29,619 --> 00:22:35,059
eviction order I have to
somehow insert this station?

582
00:22:35,059 --> 00:22:36,459
Do I want to insert it at

583
00:22:36,459 --> 00:22:39,520
the beginning of this list
or the end of this list?

584
00:22:39,520 --> 00:22:42,580
Somebody can just shout
it out. End of the list?

585
00:22:42,580 --> 00:22:44,039
Excellent. I want to
do it at the end.

586
00:22:44,039 --> 00:22:46,920
I'm literally just adding
this data frame now,

587
00:22:46,920 --> 00:22:48,259
and so I want to
try to keep it in

588
00:22:48,259 --> 00:22:50,139
memory if I can, right?

589
00:22:50,139 --> 00:22:51,399
And so I don't have to have

590
00:22:51,399 --> 00:22:53,099
a whole data frame
here, I can just say,

591
00:22:53,099 --> 00:22:56,839
what is the station
that I'm interested in.

592
00:22:56,839 --> 00:22:58,520
I'm going to pen that there.

593
00:22:58,520 --> 00:23:01,179
And then now when
I choose a victim,

594
00:23:01,179 --> 00:23:02,899
does anybody want
to suggest how I

595
00:23:02,899 --> 00:23:06,035
could use my new data
structure to choose victim?

596
00:23:06,035 --> 00:23:11,250
Yeah, right here. Yeah, let's

597
00:23:11,250 --> 00:23:12,709
grab the one at
index zero, right?

598
00:23:12,709 --> 00:23:16,050
So I'm going to say
evict order dot pop

599
00:23:16,050 --> 00:23:17,810
at index zero, right?

600
00:23:17,810 --> 00:23:20,390
So when I pop a dictionary,
I'm popping by key.

601
00:23:20,390 --> 00:23:24,169
When I pop a list, I'm
popping by an index, right?

602
00:23:24,169 --> 00:23:26,849
So I think that should
hopefully be working.

603
00:23:26,849 --> 00:23:30,509
And, you know, I have
five things down here,

604
00:23:30,509 --> 00:23:31,589
and so there probably should be

605
00:23:31,589 --> 00:23:32,849
some eviction at
some point, right?

606
00:23:32,849 --> 00:23:36,530
I'm going to print am
I getting an eviction?

607
00:23:36,530 --> 00:23:38,789
Maybe what I'll
even do is I will

608
00:23:38,789 --> 00:23:41,330
print what I'm evicting.
That would be kind of cool.

609
00:23:41,330 --> 00:23:45,730
So I will print
what I am evicting.

610
00:23:46,530 --> 00:23:51,550
Down here, and then down here,

611
00:23:51,550 --> 00:23:54,769
sure enough, I I'm getting
an eviction happening here.

612
00:23:54,769 --> 00:23:57,030
And again, right, to try

613
00:23:57,030 --> 00:23:58,670
to make sure that these
things are worked

614
00:23:58,670 --> 00:24:00,269
that you want to print
extra suf and make sure it

615
00:24:00,269 --> 00:24:02,069
does what you think
it's supposed to do.

616
00:24:02,069 --> 00:24:04,489
One of the things I often
like to print is what

617
00:24:04,489 --> 00:24:06,189
that data structure is

618
00:24:06,189 --> 00:24:08,969
that's determining the
eviction order, right?

619
00:24:08,969 --> 00:24:11,149
So I'm going to do that.

620
00:24:11,149 --> 00:24:13,490
And now I can see there's

621
00:24:13,490 --> 00:24:15,549
that data structure
that's indicating that.

622
00:24:15,549 --> 00:24:17,889
And so for the
first three, right?

623
00:24:17,889 --> 00:24:19,830
As I'm accessing these,

624
00:24:19,830 --> 00:24:21,250
I'm adding it to the
end of that data

625
00:24:21,250 --> 00:24:23,215
structure until I
get to this point.

626
00:24:23,215 --> 00:24:26,120
Alright, so I'm at
this point right here.

627
00:24:26,120 --> 00:24:28,180
I just access those
three in order.

628
00:24:28,180 --> 00:24:30,039
And now I have something that is

629
00:24:30,039 --> 00:24:33,099
not in this list up here, right?

630
00:24:33,099 --> 00:24:34,440
And so I have a mess,

631
00:24:34,440 --> 00:24:36,480
which means I have
to evict something.

632
00:24:36,480 --> 00:24:39,039
I might check, Am I evicting
the right thing? I am.

633
00:24:39,039 --> 00:24:41,339
I'm supposed to evict what
is at the first entry.

634
00:24:41,339 --> 00:24:44,499
And so what I expect now is
that I'm evict that one.

635
00:24:44,499 --> 00:24:46,640
These two will be at the front.

636
00:24:46,640 --> 00:24:48,319
And then this one that

637
00:24:48,319 --> 00:24:50,500
I'm accessing now should
get added to the end.

638
00:24:50,500 --> 00:24:52,120
Let's just check if that's true.

639
00:24:52,120 --> 00:24:55,440
These two should
move to the front.

640
00:24:55,440 --> 00:24:57,760
Fantastic. And then
this new one should

641
00:24:57,760 --> 00:25:00,069
get added down here.
At the end, right?

642
00:25:00,069 --> 00:25:01,149
So that's kind of
what you should do.

643
00:25:01,149 --> 00:25:02,109
You should print
these things out.

644
00:25:02,109 --> 00:25:03,409
Look at you know,

645
00:25:03,409 --> 00:25:04,849
look at the first time
you have an eviction.

646
00:25:04,849 --> 00:25:06,010
That's often where
bugs are because

647
00:25:06,010 --> 00:25:07,290
that's kind of more
complicated rode.

648
00:25:07,290 --> 00:25:09,229
Look where you have an eviction
and try to figure out,

649
00:25:09,229 --> 00:25:11,909
is it doing doing
the right thing?

650
00:25:11,909 --> 00:25:16,049
Okay. And then after
that, I have a hit.

651
00:25:16,049 --> 00:25:18,950
And my hit is to this
entry right here.

652
00:25:18,950 --> 00:25:23,770
And then my cash data
structure looks the same.

653
00:25:23,770 --> 00:25:26,029
So I have a question
for you all.

654
00:25:26,029 --> 00:25:27,669
Well, first off,
I'll see if anybody

655
00:25:27,669 --> 00:25:29,850
here has any questions
for me first.

656
00:25:29,850 --> 00:25:35,069
Yeah, right over here. Where
did I find the workload?

657
00:25:35,069 --> 00:25:36,629
Yeah, I just to find
the workload up here.

658
00:25:36,629 --> 00:25:38,209
So first off, I just
said, we're only going

659
00:25:38,209 --> 00:25:40,309
to do like ten random
stations for this.

660
00:25:40,309 --> 00:25:44,309
And then I did a sample
with resampling.

661
00:25:44,309 --> 00:25:46,169
I got 100 from that list of ten.

662
00:25:46,169 --> 00:25:47,609
So when I did the sampling,

663
00:25:47,609 --> 00:25:48,870
I got a lot of repeats.

664
00:25:48,870 --> 00:25:50,769
And I also just put in
some weights here to

665
00:25:50,769 --> 00:25:52,670
say that instead of all
stations being equal,

666
00:25:52,670 --> 00:25:54,109
there's a couple that I guess,

667
00:25:54,109 --> 00:25:56,489
like hot stations that
show up more often,

668
00:25:56,489 --> 00:25:57,969
right? Yeah, thank you.

669
00:25:57,969 --> 00:26:00,369
Yeah. Other questions
people have.

670
00:26:01,770 --> 00:26:04,210
Oh, excellent. Which cash mp?

671
00:26:04,210 --> 00:26:05,349
That's what I was
trying to ask you all.

672
00:26:05,349 --> 00:26:06,249
So I will ask you all,

673
00:26:06,249 --> 00:26:08,449
what cash are we
implementing? Yeah, go ahead.

674
00:26:08,449 --> 00:26:11,569
We are doing FIFO. And what did

675
00:26:11,569 --> 00:26:15,149
you see that made you
feel like it's a FIFO?

676
00:26:15,149 --> 00:26:19,149
Well, we always.

677
00:26:19,149 --> 00:26:21,810
But we're not reordering.

678
00:26:23,050 --> 00:26:25,589
Excellent. We are not reordering

679
00:26:25,589 --> 00:26:27,129
when we have a hit, right?

680
00:26:27,129 --> 00:26:28,729
If this was LRU,

681
00:26:28,729 --> 00:26:31,469
then when I hadn't hit here,

682
00:26:31,469 --> 00:26:32,689
it would have moved
this one to the end

683
00:26:32,689 --> 00:26:34,489
because it will say, Oh,
we just used that one.

684
00:26:34,489 --> 00:26:35,910
Let's try to keep
that one around.

685
00:26:35,910 --> 00:26:37,509
That one's kind of
import it, right?

686
00:26:37,509 --> 00:26:39,090
So we'll come back
to this in a bed,

687
00:26:39,090 --> 00:26:42,509
and we're going to try to
see, can we make it an LRU.

688
00:26:42,509 --> 00:26:45,049
So excellent question,
an excellent answer.

689
00:26:45,049 --> 00:26:47,689
What other questions
do people have?

690
00:26:49,370 --> 00:26:51,329
Right.

691
00:26:51,329 --> 00:26:53,389
So before I try to
make it into an LRU,

692
00:26:53,389 --> 00:26:54,509
well, first off, you know, we

693
00:26:54,509 --> 00:26:55,629
should make a comment on that.

694
00:26:55,629 --> 00:26:57,769
Like, the policy should
be clear, right?

695
00:26:57,769 --> 00:27:03,030
So this is a FIFO cash
or it uses a FIFO cash.

696
00:27:03,030 --> 00:27:04,869
Maybe I'll say that. All right.

697
00:27:04,869 --> 00:27:07,969
Now, when you're doing
this cashing work, I mean,

698
00:27:07,969 --> 00:27:11,939
part of it is h you're trying
to make it correct, right?

699
00:27:11,939 --> 00:27:13,659
It's supposed to what
you wanted to do.

700
00:27:13,659 --> 00:27:16,580
But you also care about
performance. It should be fast.

701
00:27:16,580 --> 00:27:18,059
And so as you're doing
this, you should be

702
00:27:18,059 --> 00:27:19,719
taking different
performance measurements.

703
00:27:19,719 --> 00:27:21,459
I mean, the most basic
performance measurement

704
00:27:21,459 --> 00:27:22,819
is like time,

705
00:27:22,819 --> 00:27:24,419
how long are things taking.

706
00:27:24,419 --> 00:27:26,140
But you might also
want to explain

707
00:27:26,140 --> 00:27:27,780
the time things are taking
in terms of like, well,

708
00:27:27,780 --> 00:27:29,419
how many hits were
there, how many misses

709
00:27:29,419 --> 00:27:31,399
were there and stuff like that.

710
00:27:31,399 --> 00:27:35,299
And so let's add some
statistics to track.

711
00:27:35,299 --> 00:27:38,080
These are some perf stats
that we're going to track.

712
00:27:38,080 --> 00:27:39,939
And one of the things I
like to do is I like to

713
00:27:39,939 --> 00:27:42,059
keep track of the
latencies of each thing.

714
00:27:42,059 --> 00:27:43,959
And I often like to
put my units in there.

715
00:27:43,959 --> 00:27:48,059
So in milliseconds,
milliseconds,

716
00:27:48,059 --> 00:27:50,419
to grab each station.

717
00:27:50,419 --> 00:27:52,179
I may have one called that.

718
00:27:52,179 --> 00:27:54,119
And then what else
might I want to have?

719
00:27:54,119 --> 00:27:56,059
I want to keep track of
which ones are hits.

720
00:27:56,059 --> 00:27:58,179
And I might say one is a hit.

721
00:27:58,179 --> 00:28:01,159
Zero is a mess, right?

722
00:28:01,159 --> 00:28:03,540
I want to keep track of
these kinds of things.

723
00:28:03,540 --> 00:28:06,220
If I want to measure how
long something took,

724
00:28:06,220 --> 00:28:07,619
I mean, I will

725
00:28:07,619 --> 00:28:09,359
do it very similar the
way I do it in real life.

726
00:28:09,359 --> 00:28:11,500
I look at a clock,
I do something,

727
00:28:11,500 --> 00:28:12,840
and I look at a clock at again,

728
00:28:12,840 --> 00:28:14,079
I subtract and I know how long

729
00:28:14,079 --> 00:28:15,899
something took.
So let's do that.

730
00:28:15,899 --> 00:28:20,880
I am going to import
the time module.

731
00:28:21,220 --> 00:28:24,639
Import time. And so

732
00:28:24,639 --> 00:28:25,999
the way I would do
that in general is

733
00:28:25,999 --> 00:28:27,719
I'd say something
like time to time.

734
00:28:27,719 --> 00:28:30,939
That tells me how many
seconds have passed

735
00:28:30,939 --> 00:28:34,280
since a January 1 of 1970.

736
00:28:34,280 --> 00:28:35,219
That's kind of
like I don't know,

737
00:28:35,219 --> 00:28:36,399
on the early days of computing.

738
00:28:36,399 --> 00:28:39,419
They just considered 1970
to be the start of time.

739
00:28:39,419 --> 00:28:41,559
And so if I keep watching this,

740
00:28:41,559 --> 00:28:43,339
you can see it's ticking up.

741
00:28:43,339 --> 00:28:45,639
And so kind of a natural way
I would do this is I would

742
00:28:45,639 --> 00:28:48,319
say start equals
that, do something.

743
00:28:48,319 --> 00:28:50,899
And then I would say n
equals time that time.

744
00:28:50,899 --> 00:28:54,680
And then I could subtract
the n minus the start.

745
00:28:54,680 --> 00:28:56,519
I mean, this is an
exponential notation.

746
00:28:56,519 --> 00:28:58,520
That was super fast.
Let's do something slow.

747
00:28:58,520 --> 00:29:00,699
I'm going to sleep
for 3 seconds.

748
00:29:00,699 --> 00:29:04,199
And then I will
see that you know,

749
00:29:04,199 --> 00:29:05,499
it's about 3 seconds with

750
00:29:05,499 --> 00:29:08,785
some extra overhead for
drawing those functions.

751
00:29:08,785 --> 00:29:10,909
Fantastic. So I want
to do that down here.

752
00:29:10,909 --> 00:29:12,809
And that was kind of why I
was saying earlier, right?

753
00:29:12,809 --> 00:29:14,309
Even though we could, from

754
00:29:14,309 --> 00:29:15,909
the logical perspective
return here,

755
00:29:15,909 --> 00:29:17,429
kind of having one
return point at

756
00:29:17,429 --> 00:29:19,009
the end makes it
easier for me to

757
00:29:19,009 --> 00:29:20,409
instrument my code and measure

758
00:29:20,409 --> 00:29:22,349
how things are working, right?

759
00:29:22,349 --> 00:29:23,489
So up here, I may have

760
00:29:23,489 --> 00:29:25,909
a start time equals
time, that time.

761
00:29:25,909 --> 00:29:29,009
And then down here I will have

762
00:29:29,009 --> 00:29:33,789
an end time equals time time.

763
00:29:33,789 --> 00:29:37,969
Then I can say
atencs S dot to pen,

764
00:29:37,969 --> 00:29:41,609
and then I'll say end
time minus start time.

765
00:29:41,609 --> 00:29:46,089
And then since we just shot out,

766
00:29:46,089 --> 00:29:47,750
what soul I multiply this by?

767
00:29:47,750 --> 00:29:51,670
100 excellent because
this was in seconds,

768
00:29:51,670 --> 00:29:54,669
and then over here, I'm
tracking the milliseconds.

769
00:29:54,669 --> 00:29:56,949
So that's one of the
things I'm ready to do.

770
00:29:56,949 --> 00:29:59,569
The other thing I'm
trying to do is I'm just

771
00:29:59,569 --> 00:30:02,029
try to keep track of whether
I have hits or misses.

772
00:30:02,029 --> 00:30:03,509
Maybe it's a little bit easier.

773
00:30:03,509 --> 00:30:05,630
So I'm going to say hits to pend

774
00:30:05,630 --> 00:30:08,250
one because we got hit there,

775
00:30:08,250 --> 00:30:11,149
and then I'm going to
hits dot to pend zero.

776
00:30:11,149 --> 00:30:12,589
I often like to do
it this way because

777
00:30:12,589 --> 00:30:14,289
there's a few interesting
things I can do.

778
00:30:14,289 --> 00:30:15,649
I can just like summit,

779
00:30:15,649 --> 00:30:17,749
for example, to get the
total number of hits.

780
00:30:17,749 --> 00:30:18,989
I could take the average, and

781
00:30:18,989 --> 00:30:20,689
then I would have the hit ratio.

782
00:30:20,689 --> 00:30:22,489
So that will kind
of make it easy to

783
00:30:22,489 --> 00:30:24,410
keep track of our statistic.

784
00:30:24,410 --> 00:30:25,650
Let me just make sure it doesn't

785
00:30:25,650 --> 00:30:27,029
crash or anything when I run it.

786
00:30:27,029 --> 00:30:29,769
And now I think it's
appropriate time

787
00:30:29,769 --> 00:30:32,849
to go ahead and actually
run the whole thing, right?

788
00:30:32,849 --> 00:30:34,210
And so this will take a moment.

789
00:30:34,210 --> 00:30:36,950
So any questions
while that's running?

790
00:30:40,760 --> 00:30:43,019
All right, and it's done.

791
00:30:43,019 --> 00:30:44,820
So we're gonna come
down here now.

792
00:30:44,820 --> 00:30:47,020
And I guess I'm kind of
printing off too many things.

793
00:30:47,020 --> 00:30:48,399
Let me just clean all of this up

794
00:30:48,399 --> 00:30:51,999
because that's not really
our focus anymore.

795
00:30:51,999 --> 00:30:54,139
So I'm going to clean a
lot of this stuff up.

796
00:30:54,139 --> 00:30:55,879
Otherwise, it's just too much.

797
00:30:55,879 --> 00:30:57,159
You know, maybe what
I'll do is I'll

798
00:30:57,159 --> 00:30:59,000
actually say n equal space,

799
00:30:59,000 --> 00:31:00,459
and then I'll just see
a bunch of these on

800
00:31:00,459 --> 00:31:03,179
the on the same line, right?

801
00:31:03,179 --> 00:31:06,279
So then I can see
it's doing something.

802
00:31:07,200 --> 00:31:10,900
All right. Fantastic.
So that done.

803
00:31:10,900 --> 00:31:14,179
And so now what I have is
all of these latencies.

804
00:31:14,179 --> 00:31:17,459
Maybe it was latencies
MS, I think.

805
00:31:17,459 --> 00:31:19,479
And so I can try to figure out,

806
00:31:19,479 --> 00:31:21,060
kind of typical performance.

807
00:31:21,060 --> 00:31:22,219
So for example, I could say,

808
00:31:22,219 --> 00:31:25,199
like the average latencies,

809
00:31:25,199 --> 00:31:28,039
that might be a metric that
I'd be interested in, right?

810
00:31:28,039 --> 00:31:34,200
So maybe that'd be like average
latency and milliseconds.

811
00:31:34,200 --> 00:31:38,119
I would be kind of a
reasonable thing to print out.

812
00:31:38,119 --> 00:31:41,139
I might be interested in
something like tail latency

813
00:31:41,139 --> 00:31:46,080
can remind me what is
tail latency? Right.

814
00:31:48,120 --> 00:31:50,199
Excellent. So if I took like

815
00:31:50,199 --> 00:31:51,900
the 99th percentile latencies,

816
00:31:51,900 --> 00:31:54,419
then that would be an
example of a tail latency,

817
00:31:54,419 --> 00:31:56,699
and so it'd be like one
of the worst latencies.

818
00:31:56,699 --> 00:32:01,340
And so NumPi, which I'm
going to import as NP,

819
00:32:01,340 --> 00:32:05,480
actually has will help

820
00:32:05,480 --> 00:32:07,359
us quickly compute a
percentile like that.

821
00:32:07,359 --> 00:32:12,840
I guess, instead of
quantile or quantiles,

822
00:32:12,840 --> 00:32:14,459
let me just check my notes here.

823
00:32:14,459 --> 00:32:18,179
Instead of percentiles,
which go 0-100.

824
00:32:18,179 --> 00:32:19,559
They have quantiles, which is

825
00:32:19,559 --> 00:32:21,919
exactly the same idea,
but it goes 0-1.

826
00:32:21,919 --> 00:32:26,760
And so I can say something
like give me an array of data.

827
00:32:26,760 --> 00:32:28,020
I'm going to say my latencies

828
00:32:28,020 --> 00:32:30,939
MS. And then I can say
what quantile I'm at.

829
00:32:30,939 --> 00:32:33,799
So I'm going to say
something like 0.99,

830
00:32:33,799 --> 00:32:35,559
or maybe I could do 0.999 if

831
00:32:35,559 --> 00:32:37,440
I really want to in
explore the tail.

832
00:32:37,440 --> 00:32:41,299
I'm I call that my P 99
latency equals that.

833
00:32:41,299 --> 00:32:44,629
And then I could see
what that is, right?

834
00:32:44,629 --> 00:32:49,740
So I could say P
99 tail latency.

835
00:32:50,220 --> 00:32:53,919
And then I can say
whatever that is, right?

836
00:32:53,919 --> 00:32:56,680
Great. And of course,

837
00:32:56,680 --> 00:32:59,500
my tail latency is much worse
than my average latency.

838
00:32:59,500 --> 00:33:02,140
Is unless your whole
dataset pits in the cache,

839
00:33:02,140 --> 00:33:03,999
it's really hard to
beat tail latency

840
00:33:03,999 --> 00:33:05,559
because there's always going
to be some cash misses,

841
00:33:05,559 --> 00:33:07,519
and those are going
to be slow, right?

842
00:33:07,519 --> 00:33:11,320
But certainly we can make the
better case a lot better.

843
00:33:11,320 --> 00:33:12,679
We can also do things like

844
00:33:12,679 --> 00:33:14,660
figure out the hits,
so I have these hits.

845
00:33:14,660 --> 00:33:18,539
I could say, print total hits.

846
00:33:19,180 --> 00:33:23,259
As the sum of these hits.

847
00:33:23,259 --> 00:33:25,679
I could do that. And
then I might also be

848
00:33:25,679 --> 00:33:28,259
interested in the
average of that,

849
00:33:28,259 --> 00:33:30,279
and that would be
my hit rate, right?

850
00:33:30,279 --> 00:33:35,450
So my hit rate it
rate would be 0.48.

851
00:33:35,450 --> 00:33:36,030
And that makes sense

852
00:33:36,030 --> 00:33:37,769
because 0100 hundred
requests, right?

853
00:33:37,769 --> 00:33:39,650
So I can drove through
and do these statistics.

854
00:33:39,650 --> 00:33:43,509
And then you'll often be
trying to figure out, like,

855
00:33:43,509 --> 00:33:45,809
should I have a
different cash size

856
00:33:45,809 --> 00:33:48,090
or should I have a
different cash policy?

857
00:33:48,090 --> 00:33:49,270
So you do a lot of experiments.

858
00:33:49,270 --> 00:33:51,149
You'll run the same thing
with different settings,

859
00:33:51,149 --> 00:33:52,509
and you'll be you
should be able,

860
00:33:52,509 --> 00:33:55,109
talk about these statistics
and make an argument

861
00:33:55,109 --> 00:33:58,589
for the cashing decisions
that you might want to make.

862
00:33:58,589 --> 00:34:00,629
For example, one of the
things that you might

863
00:34:00,629 --> 00:34:03,569
do is You might

864
00:34:03,569 --> 00:34:06,029
rerun this experiment with

865
00:34:06,029 --> 00:34:09,850
a whole bunch of
different cash sizes,

866
00:34:09,850 --> 00:34:12,229
maybe like 0-100 or whatever,

867
00:34:12,229 --> 00:34:13,929
and then you might
create a plot.

868
00:34:13,929 --> 00:34:15,810
On the x axis, you
might put something

869
00:34:15,810 --> 00:34:18,569
like the cash size,

870
00:34:18,569 --> 00:34:20,129
and on the y axis, you might put

871
00:34:20,129 --> 00:34:22,010
something like the hit ratio.

872
00:34:22,010 --> 00:34:23,389
And what will that look like?

873
00:34:23,389 --> 00:34:25,449
Well, it'll be a line

874
00:34:25,449 --> 00:34:27,529
that's kind of like going up
as you have a bigger cash,

875
00:34:27,529 --> 00:34:28,849
you'll have a better,
better hit rate.

876
00:34:28,849 --> 00:34:30,229
But eventually, it does the best

877
00:34:30,229 --> 00:34:31,649
you can do, and it'll
just level off.

878
00:34:31,649 --> 00:34:32,929
And so you could make
a plot like that,

879
00:34:32,929 --> 00:34:34,589
and you could tell
people that a ca

880
00:34:34,589 --> 00:34:36,669
of such and such
a size is useful,

881
00:34:36,669 --> 00:34:39,140
and beyond that, there's
diminishing returns,

882
00:34:39,140 --> 00:34:40,539
you should be able to
make arguments like that

883
00:34:40,539 --> 00:34:42,599
and kind of reason through
that sort of thing.

884
00:34:42,599 --> 00:34:44,939
So no, we actually just try and

885
00:34:44,939 --> 00:34:47,819
see if we have a
bigger cash size,

886
00:34:47,819 --> 00:34:50,760
what would happen?
Hopefully, it's faster.

887
00:34:50,760 --> 00:34:52,479
It looks like it's
running slow right now,

888
00:34:52,479 --> 00:34:55,199
so maybe this will undermine
my point I'm making.

889
00:34:55,199 --> 00:34:58,120
So let's just remember this.
So the average was 37.

890
00:34:58,120 --> 00:34:59,659
And now, okay, great,

891
00:34:59,659 --> 00:35:01,900
we have a bigger cash,
and it's a little faster.

892
00:35:01,900 --> 00:35:03,439
And instead of 48 hits,

893
00:35:03,439 --> 00:35:05,699
we have 64 hits, right?

894
00:35:05,699 --> 00:35:09,599
So a bigger cash size does
have some benefit here, right?

895
00:35:09,599 --> 00:35:12,139
I had a cash size of ten,
then I'd be getting what?

896
00:35:12,139 --> 00:35:14,740
Hit rates of 100%.

897
00:35:14,740 --> 00:35:17,169
Alright. Do people have

898
00:35:17,169 --> 00:35:19,029
any questions about
these statistics?

899
00:35:19,029 --> 00:35:24,049
Here. Oh, that's an
excellent point, right?

900
00:35:24,049 --> 00:35:26,510
So I guess in the best case I
would did a hit rate of 90%

901
00:35:26,510 --> 00:35:28,290
because the first ten always

902
00:35:28,290 --> 00:35:30,349
have to be misses.
Excellent point.

903
00:35:30,349 --> 00:35:33,269
Y. Yeah, are points or
questions people have.

904
00:35:33,990 --> 00:35:36,309
Let's go ahead, and

905
00:35:36,309 --> 00:35:38,129
I'm going to go back
to three for a moment.

906
00:35:38,129 --> 00:35:40,449
And then what I'm going to do

907
00:35:40,449 --> 00:35:47,179
is What I may do is I may see,

908
00:35:47,179 --> 00:35:49,019
can we with that same cash size,

909
00:35:49,019 --> 00:35:52,540
can we get better performance
if we switch to LRU?

910
00:35:52,540 --> 00:35:56,659
So I'm doing FIFO,
can we do LRU, right?

911
00:35:56,659 --> 00:35:59,720
And so remember, right, I
always have these two pieces.

912
00:35:59,720 --> 00:36:01,680
I have the hit code,

913
00:36:01,680 --> 00:36:03,939
and I have the miss code.

914
00:36:03,939 --> 00:36:06,439
And so my question
for you all is,

915
00:36:06,439 --> 00:36:09,080
when I start doing LRU,
what should I change?

916
00:36:09,080 --> 00:36:12,299
Can somebody just shout
it out for me? Hit.

917
00:36:12,299 --> 00:36:14,799
Excellent. I have to change
the hit code, right?

918
00:36:14,799 --> 00:36:19,009
Be because I have this
evict order up here, right?

919
00:36:19,009 --> 00:36:21,389
If I use some entry in
the middle of that,

920
00:36:21,389 --> 00:36:23,769
I should kind of move it, right?

921
00:36:23,769 --> 00:36:26,129
If I used it, then I want
to keep it around, right?

922
00:36:26,129 --> 00:36:27,490
I want the least recently

923
00:36:27,490 --> 00:36:28,769
used things on the
left hand side.

924
00:36:28,769 --> 00:36:30,169
That's why it's called LR U,

925
00:36:30,169 --> 00:36:32,189
least recently used on the left.

926
00:36:32,189 --> 00:36:33,709
And then the important
stuff that I just

927
00:36:33,709 --> 00:36:36,489
touched should be on
the right hand side.

928
00:36:36,489 --> 00:36:38,549
Alright, let's try that.

929
00:36:38,549 --> 00:36:41,589
And so what we'll do
here is I can say,

930
00:36:41,589 --> 00:36:47,044
I can say evict order
evict order dot

931
00:36:47,044 --> 00:36:51,660
Remove, and I will
remove that station,

932
00:36:51,660 --> 00:36:54,959
and then I will add
it back at the end.

933
00:36:55,200 --> 00:36:59,459
Evict order dot a pen
station at the end, right?

934
00:36:59,459 --> 00:37:04,679
So I may say move station
to the end, right?

935
00:37:04,679 --> 00:37:09,579
So it stays in memory
longer, right?

936
00:37:09,579 --> 00:37:12,359
And so let's run this.

937
00:37:19,660 --> 00:37:23,640
Alright. Let's just
look at these numbers.

938
00:37:23,640 --> 00:37:25,979
Da they're about
to change? I think

939
00:37:25,979 --> 00:37:28,199
that LRU will do
better in this case.

940
00:37:28,199 --> 00:37:31,079
So let's hope that the
average latency goes down.

941
00:37:31,079 --> 00:37:33,059
I guess a little bit, right?

942
00:37:33,059 --> 00:37:36,199
And then let's take a look
at the total hit rate.

943
00:37:36,199 --> 00:37:39,779
Okay. In the morning lecture
was worked out better.

944
00:37:39,779 --> 00:37:42,519
I mean, there's some
randomness here, right?

945
00:37:42,519 --> 00:37:44,459
But maybe I was wrong.

946
00:37:44,459 --> 00:37:48,019
Maybe they perform
similarly here, right?

947
00:37:48,300 --> 00:37:50,859
So cash size and cash policy are

948
00:37:50,859 --> 00:37:52,759
things that are going
to influence this.

949
00:37:52,759 --> 00:37:57,879
Usually more than this
example right here. Cool.

950
00:37:57,879 --> 00:38:00,259
So I just want to pause on this.

951
00:38:00,660 --> 00:38:02,680
Do people have any questions

952
00:38:02,680 --> 00:38:06,579
about how we turn
this into LR U cash?

953
00:38:08,500 --> 00:38:11,880
Now, notice that to do
either of these policies,

954
00:38:11,880 --> 00:38:15,339
I had to do a little bit
of extra bookkeeping here.

955
00:38:15,339 --> 00:38:18,439
And one of these things

956
00:38:18,439 --> 00:38:20,719
I'm doing with the
bookkeeping is not great.

957
00:38:20,719 --> 00:38:22,579
Anybody who kind of
knows the details about

958
00:38:22,579 --> 00:38:24,980
how Python lists
work internally,

959
00:38:24,980 --> 00:38:29,179
what are you a little bit
worried about here? There here.

960
00:38:29,179 --> 00:38:34,299
Oh. Yeah, remove I

961
00:38:34,299 --> 00:38:35,459
might have to look
through the whole list.

962
00:38:35,459 --> 00:38:39,280
So that's not great.
Maybe even worse.

963
00:38:39,280 --> 00:38:41,399
When I find it, a Python list

964
00:38:41,399 --> 00:38:43,519
is a lot like a Java, ray list.

965
00:38:43,519 --> 00:38:45,959
I kind of all these things
are packed consecutively.

966
00:38:45,959 --> 00:38:47,539
And so when I pull out, say,

967
00:38:47,539 --> 00:38:49,459
like an entry at Index five,

968
00:38:49,459 --> 00:38:51,400
then I have to shift
over all the other items

969
00:38:51,400 --> 00:38:53,199
at index like six,
seven, eight, so on.

970
00:38:53,199 --> 00:38:54,920
And so this is an
order and operation.

971
00:38:54,920 --> 00:38:57,019
For a cash list size, it
doesn't really matter.

972
00:38:57,019 --> 00:38:58,959
Like the cashing
overhead, doesn't matter.

973
00:38:58,959 --> 00:39:00,360
If we had something
a lot bigger,

974
00:39:00,360 --> 00:39:01,779
then that might
actually matter to me,

975
00:39:01,779 --> 00:39:03,760
and I might try to pick a
different data structure.

976
00:39:03,760 --> 00:39:05,659
Does anybody know a
data structure that

977
00:39:05,659 --> 00:39:07,679
might be good for kind
of what I'm doing,

978
00:39:07,679 --> 00:39:09,239
like the removing and
adding it at both ends?

979
00:39:09,239 --> 00:39:11,879
Yeah, go ahead. A length list,

980
00:39:11,879 --> 00:39:13,039
like a double length
list will be.

981
00:39:13,039 --> 00:39:17,419
Yeah, you want to add on
that. Hh Maybe ash map.

982
00:39:17,419 --> 00:39:18,899
So hash maps are
ordered. In fact,

983
00:39:18,899 --> 00:39:20,259
I even think maybe cache is

984
00:39:20,259 --> 00:39:21,899
in recent Python
versions, right?

985
00:39:21,899 --> 00:39:23,339
The leng list, I think that

986
00:39:23,339 --> 00:39:25,039
might be a good
solution, right here.

987
00:39:25,039 --> 00:39:27,339
A DQ, right? Able length list is

988
00:39:27,339 --> 00:39:29,719
often how people will
implement a D Q.

989
00:39:29,719 --> 00:39:32,819
So DQ can let us add and
remove from both sides.

990
00:39:32,819 --> 00:39:34,779
A link list would be
one example of a DQ.

991
00:39:34,779 --> 00:39:37,859
Some people call it a
double edged Q or a deck.

992
00:39:37,859 --> 00:39:39,119
But we want to do
something like that.

993
00:39:39,119 --> 00:39:40,799
Yeah, question right here.

994
00:39:40,799 --> 00:39:42,819
That's an excellent
question. Can we

995
00:39:42,819 --> 00:39:44,240
still remove from the middle?

996
00:39:44,240 --> 00:39:46,620
And if you just
did a generic DQ,

997
00:39:46,620 --> 00:39:48,540
like the one that
comes with Python,

998
00:39:48,540 --> 00:39:50,219
the answer is no, right?

999
00:39:50,219 --> 00:39:52,579
And so this is not great for us.

1000
00:39:52,579 --> 00:39:54,040
If I was doing FIFO,

1001
00:39:54,040 --> 00:39:56,159
then everything would
have been good, right?

1002
00:39:56,159 --> 00:39:57,399
A DQ would work great.

1003
00:39:57,399 --> 00:39:58,919
What I often find myself doing

1004
00:39:58,919 --> 00:40:00,459
when I end up writing LRU code,

1005
00:40:00,459 --> 00:40:02,579
and I've had to do this in
a few different scenarios,

1006
00:40:02,579 --> 00:40:05,919
is I often end up implementing
a doublen list for my DQ,

1007
00:40:05,919 --> 00:40:08,740
and then I kind of optimize
it for this scenario.

1008
00:40:08,740 --> 00:40:11,969
And the way you can
optimize it is that You

1009
00:40:11,969 --> 00:40:13,429
have to have some
way of jumping into

1010
00:40:13,429 --> 00:40:15,269
the middle of the length list,

1011
00:40:15,269 --> 00:40:17,110
the nth list, and find
a node in the middle.

1012
00:40:17,110 --> 00:40:19,090
And if you have a
supplementary dictionary,

1013
00:40:19,090 --> 00:40:20,409
you can do that, right?

1014
00:40:20,409 --> 00:40:21,830
We don't want to have
just a dictionary

1015
00:40:21,830 --> 00:40:24,490
from stations to data frames.

1016
00:40:24,490 --> 00:40:24,889
I need to have

1017
00:40:24,889 --> 00:40:26,609
another dictionary that
would kind of take me

1018
00:40:26,609 --> 00:40:29,529
to a double length list
node in this thing, right?

1019
00:40:29,529 --> 00:40:31,109
I can try quickly find
something in the middle.

1020
00:40:31,109 --> 00:40:33,129
And then once you do that,
you could remove it, right?

1021
00:40:33,129 --> 00:40:34,089
So you might end up having

1022
00:40:34,089 --> 00:40:35,329
some extra data structures here,

1023
00:40:35,329 --> 00:40:36,789
but, you know, that's more
of an algorithm thing.

1024
00:40:36,789 --> 00:40:39,509
We won't get too deep into
that in this course, right?

1025
00:40:39,509 --> 00:40:40,729
And it's not a horrible amount

1026
00:40:40,729 --> 00:40:42,269
of code to do
something like that.

1027
00:40:42,269 --> 00:40:43,869
Alright. Fantastic.

1028
00:40:43,869 --> 00:40:45,529
So, what questions do people

1029
00:40:45,529 --> 00:40:48,729
have about our cashing
implementation?

1030
00:40:50,110 --> 00:40:52,729
Alright, so you all
will go and do that,

1031
00:40:52,729 --> 00:40:56,749
and hopefully that's fun
to do on the project, too.

1032
00:40:56,749 --> 00:40:58,109
And hopefully, hopefully
this helps you.

1033
00:40:58,109 --> 00:41:00,089
You know, I may have
saved this for you all,

1034
00:41:00,089 --> 00:41:03,330
and the way I may do this is
I may do a file download,

1035
00:41:03,330 --> 00:41:06,050
and then I can save my
notebook somewhere.

1036
00:41:06,050 --> 00:41:07,709
And you should
remember that too,

1037
00:41:07,709 --> 00:41:09,810
because if you're working
on a Jupiter notebook

1038
00:41:09,810 --> 00:41:12,570
inside a container and
you kill your container,

1039
00:41:12,570 --> 00:41:15,169
well, your files are gone.

1040
00:41:15,169 --> 00:41:16,949
Well, eventually, we see
you in kind of another way,

1041
00:41:16,949 --> 00:41:18,650
like when we learn more
about docker storage,

1042
00:41:18,650 --> 00:41:20,009
how to do that.

1043
00:41:20,009 --> 00:41:21,769
But for now, if you're
doing work inside

1044
00:41:21,769 --> 00:41:23,570
of a Docker container
and uper notebook,

1045
00:41:23,570 --> 00:41:25,190
make sure you save
it out regularly,

1046
00:41:25,190 --> 00:41:27,984
so you don't lose it.
Alright, fantastic.

1047
00:41:27,984 --> 00:41:30,339
I'm going to jump
ahead a little bit to

1048
00:41:30,339 --> 00:41:31,779
Wednesday's lecture
because we have

1049
00:41:31,779 --> 00:41:33,459
a little bit of
time, fortunately.

1050
00:41:33,459 --> 00:41:35,199
And kind of what
we've been doing so

1051
00:41:35,199 --> 00:41:37,419
far is we first started with,

1052
00:41:37,419 --> 00:41:39,319
like, let's just see,
like the purpose of

1053
00:41:39,319 --> 00:41:41,580
a cash and some cash policies.

1054
00:41:41,580 --> 00:41:43,399
And then today we kind of
go our hands sturdy, like,

1055
00:41:43,399 --> 00:41:46,139
how would we actually
build a cash?

1056
00:41:46,139 --> 00:41:48,259
This next lecture is things

1057
00:41:48,259 --> 00:41:50,719
that you might actually be
thinking about cashing a lot,

1058
00:41:50,719 --> 00:41:53,380
and we'll definitely have
hands on applications.

1059
00:41:53,380 --> 00:41:54,520
I'm going to look
at some existing

1060
00:41:54,520 --> 00:41:55,919
tools that kind of interact with

1061
00:41:55,919 --> 00:41:57,399
cashing and see how we can get

1062
00:41:57,399 --> 00:41:58,899
better performance out of them,

1063
00:41:58,899 --> 00:42:01,259
given some of the things
that we've learned.

1064
00:42:01,259 --> 00:42:03,040
And most of those
will be around Piero,

1065
00:42:03,040 --> 00:42:04,320
which is a tool introduced,

1066
00:42:04,320 --> 00:42:06,320
and then also around this
other thing called umpi.

1067
00:42:06,320 --> 00:42:08,299
And so one of my learning
objectives for you is that

1068
00:42:08,299 --> 00:42:10,480
you should grow and write
cash friendly code.

1069
00:42:10,480 --> 00:42:14,019
Cash friendly coded that is
ting to run faster because

1070
00:42:14,019 --> 00:42:15,659
of the cache is trying to maybe

1071
00:42:15,659 --> 00:42:17,680
have more hits and fewer misses.

1072
00:42:17,680 --> 00:42:19,379
And there are things
that you can decide that

1073
00:42:19,379 --> 00:42:20,359
will influence that when

1074
00:42:20,359 --> 00:42:21,720
you're building
your application.

1075
00:42:21,720 --> 00:42:23,599
Secondly, we're going to
learn about how we can

1076
00:42:23,599 --> 00:42:25,680
use these things called
memory mappings with Piero,

1077
00:42:25,680 --> 00:42:27,319
and that will be kind
of a natural way

1078
00:42:27,319 --> 00:42:29,319
for us to have a table

1079
00:42:29,319 --> 00:42:33,419
where we're using memory to
cache portions of our table,

1080
00:42:33,419 --> 00:42:35,880
which really lives
on disk somewhere.

1081
00:42:35,880 --> 00:42:37,339
We don't necessarily
have to think about it.

1082
00:42:37,339 --> 00:42:38,599
It's going to hapen
automatically

1083
00:42:38,599 --> 00:42:40,954
for us if we set
things up right.

1084
00:42:40,954 --> 00:42:43,089
Another way caching
shows up is with

1085
00:42:43,089 --> 00:42:45,070
this thing called swapping.

1086
00:42:45,070 --> 00:42:46,930
Sometimes if there's
too much data,

1087
00:42:46,930 --> 00:42:49,609
the operating system will put
some of that data to disk,

1088
00:42:49,609 --> 00:42:51,709
and then only the hottest
data will stay in RAM,

1089
00:42:51,709 --> 00:42:53,149
so that's effectively a cache.

1090
00:42:53,149 --> 00:42:55,050
And then finally when I
see how we can configure

1091
00:42:55,050 --> 00:42:57,309
some docker limits
on memory used.

1092
00:42:57,309 --> 00:43:00,189
That one's actually
important for kind of

1093
00:43:00,189 --> 00:43:02,109
troubleshooting stuff
because what will happen to

1094
00:43:02,109 --> 00:43:04,309
all of us probably is
that at some point,

1095
00:43:04,309 --> 00:43:05,890
we'll have some
dockerized application

1096
00:43:05,890 --> 00:43:07,150
that's using too much memory.

1097
00:43:07,150 --> 00:43:08,150
And then it's really annoying

1098
00:43:08,150 --> 00:43:09,310
because the whole
virtual machine

1099
00:43:09,310 --> 00:43:10,629
becomes non responsive,

1100
00:43:10,629 --> 00:43:11,949
and you have to go reset it.

1101
00:43:11,949 --> 00:43:13,189
You can go on the
console and do like

1102
00:43:13,189 --> 00:43:14,389
a reset and it'll be fine.

1103
00:43:14,389 --> 00:43:15,589
But still, it's annoying to have

1104
00:43:15,589 --> 00:43:17,409
a VM that freezes up on you.

1105
00:43:17,409 --> 00:43:19,230
We can avoid that by setting

1106
00:43:19,230 --> 00:43:21,289
limits on our docker
containers so that

1107
00:43:21,289 --> 00:43:23,349
that docker container
dies instead of

1108
00:43:23,349 --> 00:43:26,309
the whole virtual machine
becoming non responsive.

1109
00:43:26,309 --> 00:43:28,109
Alright, let's
review a little bit.

1110
00:43:28,109 --> 00:43:30,329
So when we're writing
cashwaR code,

1111
00:43:30,329 --> 00:43:31,909
one of the caches we
should be aware of

1112
00:43:31,909 --> 00:43:33,810
is the CPU caches.

1113
00:43:33,810 --> 00:43:35,589
And so I'm going to
take a look at the CP,

1114
00:43:35,589 --> 00:43:37,990
remember that the CPU
has these caches.

1115
00:43:37,990 --> 00:43:40,169
L one, L two and L three.

1116
00:43:40,169 --> 00:43:41,830
And, you can imagine

1117
00:43:41,830 --> 00:43:43,790
different policies that
might have for eviction.

1118
00:43:43,790 --> 00:43:45,849
Another question that we

1119
00:43:45,849 --> 00:43:48,430
have is that when I
touch a piece of data,

1120
00:43:48,430 --> 00:43:50,550
I want to bring that
into the cache,

1121
00:43:50,550 --> 00:43:52,249
but should I just bring
that piece of data,

1122
00:43:52,249 --> 00:43:54,810
or should I kind of bring
a bigger chunk of data?

1123
00:43:54,810 --> 00:43:58,289
For example, if I'm
looping over an array,

1124
00:43:58,289 --> 00:44:03,030
and those entries in the
array are in the CPUs cache,

1125
00:44:03,030 --> 00:44:05,049
do I want to bring one
teger in at a time,

1126
00:44:05,049 --> 00:44:06,370
or when I access one eger,

1127
00:44:06,370 --> 00:44:08,269
should I bring in a few, right?

1128
00:44:08,269 --> 00:44:09,489
So this question of granularity.

1129
00:44:09,489 --> 00:44:12,490
The way we talk about
that with CPUs,

1130
00:44:12,490 --> 00:44:14,689
as we call it cash
lines cash lines

1131
00:44:14,689 --> 00:44:16,069
are the granularity at which

1132
00:44:16,069 --> 00:44:17,670
we pull things into the cache.

1133
00:44:17,670 --> 00:44:19,209
And, you know, people have

1134
00:44:19,209 --> 00:44:22,289
tried bigger cash lines
and smaller cash lines,

1135
00:44:22,289 --> 00:44:24,779
and bigger, smaller n
necessarily better.

1136
00:44:24,779 --> 00:44:26,219
It really depends on
your workload, right?

1137
00:44:26,219 --> 00:44:29,160
If I'm kind of sequentially
accessing a bunch of stuff,

1138
00:44:29,160 --> 00:44:31,039
then I would want a
bigger cash line.

1139
00:44:31,039 --> 00:44:33,059
If I'm randomly jumping around,

1140
00:44:33,059 --> 00:44:34,399
a bigger cash line
is actually bad.

1141
00:44:34,399 --> 00:44:35,819
I don't want a
smaller cash line.

1142
00:44:35,819 --> 00:44:38,319
Anyway, for a long
time, most CPUs,

1143
00:44:38,319 --> 00:44:39,860
modern CPUs have had 64,

1144
00:44:39,860 --> 00:44:42,040
so I'll kind of just like
assume that in most cases.

1145
00:44:42,040 --> 00:44:44,659
Like some of the, you
know, in the past,

1146
00:44:44,659 --> 00:44:46,620
we've had bigger ones and
kind of more recently,

1147
00:44:46,620 --> 00:44:47,839
Apple's experimenting with some

1148
00:44:47,839 --> 00:44:49,859
bigger cash line sizes as well.

1149
00:44:49,859 --> 00:44:51,805
But we have these
cash line sizes.

1150
00:44:51,805 --> 00:44:53,869
T to be very clear. What
is the problem here?

1151
00:44:53,869 --> 00:44:56,650
If these cash lines
are too small,

1152
00:44:56,650 --> 00:44:58,009
then right after we have a mess,

1153
00:44:58,009 --> 00:44:58,949
we're going to have
another mess when

1154
00:44:58,949 --> 00:45:00,269
we touch adjacent data.

1155
00:45:00,269 --> 00:45:03,330
They're too big, then
we're wasting resources

1156
00:45:03,330 --> 00:45:07,509
pulling data into the cash
that we will never use.

1157
00:45:07,509 --> 00:45:10,869
Alright, so let's see
how this might play out.

1158
00:45:11,200 --> 00:45:14,499
This example confuses
people a lot.

1159
00:45:14,499 --> 00:45:16,860
I'm going to go through
kind of slowly.

1160
00:45:16,860 --> 00:45:18,940
I'm using a language,

1161
00:45:18,940 --> 00:45:20,879
maybe like CPS plus
or something that

1162
00:45:20,879 --> 00:45:23,720
lets me specify the
size of my integers,

1163
00:45:23,720 --> 00:45:25,139
and I'm going to create

1164
00:45:25,139 --> 00:45:28,440
an array of integers that
are consecutive in memory,

1165
00:45:28,440 --> 00:45:30,700
and I'm going to use 64.

1166
00:45:30,700 --> 00:45:32,699
So let me think about that.

1167
00:45:32,699 --> 00:45:34,960
In 64 bits, there
are eight bytes.

1168
00:45:34,960 --> 00:45:36,940
So I have eight byte integers,

1169
00:45:36,940 --> 00:45:41,039
and there are 64 bytes
in a cache line.

1170
00:45:41,039 --> 00:45:42,959
So that means I have

1171
00:45:42,959 --> 00:45:45,959
eight integers can fit
in one cache line.

1172
00:45:45,959 --> 00:45:50,370
Okay. Now, I have 16
integers in my array.

1173
00:45:50,370 --> 00:45:53,210
So that means they're spread
across two cash lines.

1174
00:45:53,210 --> 00:45:55,109
Okay? Now, just because I

1175
00:45:55,109 --> 00:45:57,610
have an array or a
list or whatever,

1176
00:45:57,610 --> 00:45:59,089
and memory doesn't mean that I

1177
00:45:59,089 --> 00:46:00,749
have to access all
of the data in it.

1178
00:46:00,749 --> 00:46:03,509
So, for example, I
could write a program

1179
00:46:03,509 --> 00:46:04,989
that loops through
the first four

1180
00:46:04,989 --> 00:46:06,749
numbers and prints them.

1181
00:46:06,749 --> 00:46:08,629
And so to illustrate that,

1182
00:46:08,629 --> 00:46:10,789
I made some of these red, right?

1183
00:46:10,789 --> 00:46:13,189
So I have an array of 16 things,

1184
00:46:13,189 --> 00:46:15,189
but I'm only looping over the

1185
00:46:15,189 --> 00:46:18,229
first four and printing
out what those are.

1186
00:46:18,229 --> 00:46:21,789
Okay? And so then we can look
at this, and we can say,

1187
00:46:21,789 --> 00:46:25,410
when I do this, when I
access these four numbers,

1188
00:46:25,410 --> 00:46:28,469
how many misses, will
there be in the cash?

1189
00:46:28,469 --> 00:46:30,309
How many cash lines
do I have to pull

1190
00:46:30,309 --> 00:46:32,069
in would be another way of
phrasing that same question.

1191
00:46:32,069 --> 00:46:35,169
Yeah, go ahead. There
would just be one, right?

1192
00:46:35,169 --> 00:46:37,910
So even though I'm axing
these four numbers,

1193
00:46:37,910 --> 00:46:38,429
there will only be

1194
00:46:38,429 --> 00:46:40,269
one cash line mess because
I read the first one.

1195
00:46:40,269 --> 00:46:41,729
That's a mess I bring it in.

1196
00:46:41,729 --> 00:46:43,709
And then the next three
are hits because even

1197
00:46:43,709 --> 00:46:46,189
though I'm axing those
numbers for the first time,

1198
00:46:46,189 --> 00:46:48,970
they're part of a cash line
that I've used recently.

1199
00:46:48,970 --> 00:46:50,849
Alright, so we saw
the first one,

1200
00:46:50,849 --> 00:46:52,329
we'll have one cash line mess.

1201
00:46:52,329 --> 00:46:53,529
Maybe everybody
together can hold

1202
00:46:53,529 --> 00:46:54,950
up some number of fingers.

1203
00:46:54,950 --> 00:46:57,329
How many cash line
misses will there be?

1204
00:46:57,329 --> 00:47:00,090
And the second example,

1205
00:47:01,880 --> 00:47:05,300
a few people say two,
which is correct.

1206
00:47:05,300 --> 00:47:06,839
When I access the integer at

1207
00:47:06,839 --> 00:47:08,839
index zero, there's
a cash line miss.

1208
00:47:08,839 --> 00:47:10,459
I'll bring all of
this in a little bit

1209
00:47:10,459 --> 00:47:12,580
unfortunately because I don't
actually use those values.

1210
00:47:12,580 --> 00:47:15,119
And then I access another
integer at Index eight.

1211
00:47:15,119 --> 00:47:16,399
That's in a different cash line,

1212
00:47:16,399 --> 00:47:17,760
so then I have another mess.

1213
00:47:17,760 --> 00:47:20,800
Okay? And then what about
this third example?

1214
00:47:20,800 --> 00:47:22,379
How many cash line misses
that I have there?

1215
00:47:22,379 --> 00:47:24,960
I already hold up some
number of fingers.

1216
00:47:25,550 --> 00:47:29,449
Kind of a MX. It's two.

1217
00:47:29,449 --> 00:47:31,210
So when I access
that first number,

1218
00:47:31,210 --> 00:47:32,469
it will be a cash line mess,

1219
00:47:32,469 --> 00:47:34,349
and I access the next seven
and those will all be

1220
00:47:34,349 --> 00:47:36,529
heads because I already pulled
in that whole cash line.

1221
00:47:36,529 --> 00:47:38,389
Then I go to the
one at dex eight.

1222
00:47:38,389 --> 00:47:39,669
That will be another
mess, and I'll

1223
00:47:39,669 --> 00:47:40,969
bring in a whole
other cash line,

1224
00:47:40,969 --> 00:47:43,889
and all the rest of these
will be heads, right?

1225
00:47:43,889 --> 00:47:46,029
So the one on the
far left, right,

1226
00:47:46,029 --> 00:47:48,029
we have one cash line mess,

1227
00:47:48,029 --> 00:47:49,389
and the one in the
middle we have two,

1228
00:47:49,389 --> 00:47:51,209
and one right we have two.

1229
00:47:51,209 --> 00:47:55,704
And I think the way people
kind of naturally intuitively,

1230
00:47:55,704 --> 00:47:57,779
think about their code, as
they might look at this,

1231
00:47:57,779 --> 00:47:58,559
and they might say,

1232
00:47:58,559 --> 00:48:01,060
how many different
numbers am I accessing.

1233
00:48:01,060 --> 00:48:02,919
And kind of it
feels like that is

1234
00:48:02,919 --> 00:48:03,959
what's going to determine how

1235
00:48:03,959 --> 00:48:05,519
long your program takes to run.

1236
00:48:05,519 --> 00:48:06,899
What I want to start
thinking about

1237
00:48:06,899 --> 00:48:08,299
is not how many numbers
are I touching,

1238
00:48:08,299 --> 00:48:09,459
but how many cash lines are

1239
00:48:09,459 --> 00:48:11,500
my touching, because honestly,

1240
00:48:11,500 --> 00:48:13,140
these two on the right probably

1241
00:48:13,140 --> 00:48:14,960
have kind of similar
performance,

1242
00:48:14,960 --> 00:48:17,300
and the one on the left
is going to be faster,

1243
00:48:17,300 --> 00:48:18,540
even though it's accessing

1244
00:48:18,540 --> 00:48:21,020
more numbers than the
one in the middle.

1245
00:48:21,020 --> 00:48:23,240
Let me just show you, like,
a really cool experiment

1246
00:48:23,240 --> 00:48:24,879
on this blog that does this.

1247
00:48:24,879 --> 00:48:26,319
It's a one line program.

1248
00:48:26,319 --> 00:48:28,899
And it's writing a loop in
kind of a language like,

1249
00:48:28,899 --> 00:48:30,119
you know, maybe, like, Java or

1250
00:48:30,119 --> 00:48:31,439
C Sharp or something like that.

1251
00:48:31,439 --> 00:48:34,204
We have an I that we're
using for our four loop.

1252
00:48:34,204 --> 00:48:36,869
And we're looping up until
the length of the array,

1253
00:48:36,869 --> 00:48:40,709
this array has four
byte integers in it.

1254
00:48:40,709 --> 00:48:42,610
And as we step forward,

1255
00:48:42,610 --> 00:48:44,210
we step forward by
different amounts.

1256
00:48:44,210 --> 00:48:45,489
So we specify a k value.

1257
00:48:45,489 --> 00:48:47,510
If K was one, then I
would be accessing

1258
00:48:47,510 --> 00:48:51,029
every integer and I'd be
multiplying it by three.

1259
00:48:51,029 --> 00:48:52,889
I K was two,

1260
00:48:52,889 --> 00:48:54,430
then I would do the
integer at position

1261
00:48:54,430 --> 00:48:56,549
zero at position two
at position four.

1262
00:48:56,549 --> 00:48:59,129
Basically, the bigger K,

1263
00:48:59,129 --> 00:49:01,309
the less multiplication
I have to do.

1264
00:49:01,309 --> 00:49:02,469
And so what they
did is they tried

1265
00:49:02,469 --> 00:49:04,410
different k values
on the x axis,

1266
00:49:04,410 --> 00:49:06,649
and then they measured
how long it took.

1267
00:49:06,649 --> 00:49:07,890
And it's really
kind of striking.

1268
00:49:07,890 --> 00:49:11,299
When I go from K equals
one to k equals two,

1269
00:49:11,299 --> 00:49:14,209
The multiplications
I do is cut in half,

1270
00:49:14,209 --> 00:49:15,869
but it's not any faster because

1271
00:49:15,869 --> 00:49:18,030
I'm touching the same
number of cash lines.

1272
00:49:18,030 --> 00:49:20,549
When I go from K
s two to K four,

1273
00:49:20,549 --> 00:49:22,869
I'm cutting the
multiplications in half again.

1274
00:49:22,869 --> 00:49:25,269
No any faster. Be the same
amount of cash lines.

1275
00:49:25,269 --> 00:49:26,830
The only time it
really gets faster

1276
00:49:26,830 --> 00:49:28,730
is when K gets bigger than 16,

1277
00:49:28,730 --> 00:49:30,889
then I start skipping
every other cash line.

1278
00:49:30,889 --> 00:49:33,050
So the multiplications
here are irrelevant.

1279
00:49:33,050 --> 00:49:34,929
The only thing that matters
to performance here

1280
00:49:34,929 --> 00:49:37,150
is how many cash
lines am I touching.

1281
00:49:37,150 --> 00:49:38,329
Alright, so I'll leap off on

1282
00:49:38,329 --> 00:49:39,589
that thought and
we'll come back next

1283
00:49:39,589 --> 00:49:42,349
time and have some more
concrete examples like this.

1284
00:49:42,349 --> 00:49:44,649
So a fantastic day.
