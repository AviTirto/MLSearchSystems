1
00:00:00,000 --> 00:00:01,920
We've been learning about
these different resources,

2
00:00:01,920 --> 00:00:04,620
and right now, we're
on compute resources.

3
00:00:04,620 --> 00:00:06,400
And we've been learning about

4
00:00:06,400 --> 00:00:09,439
how modern CPUs kind
of what they give us.

5
00:00:09,439 --> 00:00:10,979
The clock speeds have not really

6
00:00:10,979 --> 00:00:12,559
been getting faster
in recent years,

7
00:00:12,559 --> 00:00:14,979
but we tend to get more
and more cores over time.

8
00:00:14,979 --> 00:00:16,979
So we want to figure out how
to take advantage of those.

9
00:00:16,979 --> 00:00:18,919
One way is you could
just have a bunch of

10
00:00:18,919 --> 00:00:21,160
different single
threaded processes.

11
00:00:21,160 --> 00:00:23,819
What we learned about on
Friday is that we could also

12
00:00:23,819 --> 00:00:25,199
have a single process with lots

13
00:00:25,199 --> 00:00:26,579
of different threads in it.

14
00:00:26,579 --> 00:00:28,019
So that solves one
problem, right,

15
00:00:28,019 --> 00:00:30,135
being able to use
these compute cores.

16
00:00:30,135 --> 00:00:32,669
But we also saw that that
introduced new problems.

17
00:00:32,669 --> 00:00:34,149
If we aren't really
careful on how we do that,

18
00:00:34,149 --> 00:00:36,029
there can be race conditions.

19
00:00:36,029 --> 00:00:38,110
If we get context
which is at bad times,

20
00:00:38,110 --> 00:00:40,149
maybe we get bad output or

21
00:00:40,149 --> 00:00:42,449
maybe sometimes we
get dread output.

22
00:00:42,449 --> 00:00:44,549
It's kind of very hard to
test that sort of thing.

23
00:00:44,549 --> 00:00:47,470
And so maybe last Friday
was a little pessimistic.

24
00:00:47,470 --> 00:00:49,529
Today we'll be talking
about a solution,

25
00:00:49,529 --> 00:00:51,269
which is to use locks,

26
00:00:51,269 --> 00:00:52,669
and so we're going to
be learning about how

27
00:00:52,669 --> 00:00:53,769
to use locks effectively.

28
00:00:53,769 --> 00:00:55,230
And that will couple
with its own problems.

29
00:00:55,230 --> 00:00:56,509
We're going to learn
about another kind of

30
00:00:56,509 --> 00:00:59,094
concurrency bug today
called the deadlock.

31
00:00:59,094 --> 00:01:01,039
So I have a few
learning objectives

32
00:01:01,039 --> 00:01:02,579
I want you to walk away with.

33
00:01:02,579 --> 00:01:04,040
First, in order to be able to

34
00:01:04,040 --> 00:01:05,180
think about concurrent code,

35
00:01:05,180 --> 00:01:06,580
there's a skill you
need to develop,

36
00:01:06,580 --> 00:01:08,200
which is looking
at your code and

37
00:01:08,200 --> 00:01:10,180
identifying critical
sections, right?

38
00:01:10,180 --> 00:01:12,900
We can't think very deeply
about code it all the time.

39
00:01:12,900 --> 00:01:14,880
But there are certain
pieces of code where

40
00:01:14,880 --> 00:01:16,859
these concurrency bugs become

41
00:01:16,859 --> 00:01:18,900
relevant, and we want
to identify those.

42
00:01:18,900 --> 00:01:21,700
Second, I want you to be
able to have a mechanism

43
00:01:21,700 --> 00:01:24,439
where you can protect
those pieces of code,

44
00:01:24,439 --> 00:01:25,839
where we can basically say, Hey,

45
00:01:25,839 --> 00:01:27,519
I'm trying to do all
these lines of code,

46
00:01:27,519 --> 00:01:30,060
and I don't want to get
interrupted at a bad time.

47
00:01:30,060 --> 00:01:33,374
And that mechanism
is called the lock.

48
00:01:33,374 --> 00:01:35,350
Third, we're going to

49
00:01:35,350 --> 00:01:36,589
be able to learn how
to write code that

50
00:01:36,589 --> 00:01:38,229
avoids common concurrency bugs

51
00:01:38,229 --> 00:01:39,489
in particular race conditions,

52
00:01:39,489 --> 00:01:41,989
which we all have already
seen and deadlocks.

53
00:01:41,989 --> 00:01:43,410
And then finally,
I'm probably going

54
00:01:43,410 --> 00:01:45,049
to push this to
Wednesday honestly.

55
00:01:45,049 --> 00:01:47,670
We're look a little bit
more specifically at

56
00:01:47,670 --> 00:01:48,950
an infamous lock and

57
00:01:48,950 --> 00:01:50,709
the Python interpreter called

58
00:01:50,709 --> 00:01:52,310
the Global Interpreter Lock.

59
00:01:52,310 --> 00:01:54,530
You know, this might actually
be going away, maybe not.

60
00:01:54,530 --> 00:01:55,810
It's a little hard
to see. We're going

61
00:01:55,810 --> 00:01:57,050
to do a little bit
of a deeper dive and

62
00:01:57,050 --> 00:01:59,609
see how things actually
run in Python,

63
00:01:59,609 --> 00:02:01,549
whereas most of what I'm
talking about today is kind of

64
00:02:01,549 --> 00:02:04,330
general to a lot of different
programming languages.

65
00:02:04,330 --> 00:02:05,929
Alright, so first, let's talk

66
00:02:05,929 --> 00:02:07,870
about some critical sections.

67
00:02:07,870 --> 00:02:10,929
And so I have a piece of code
here called transfer EOs.

68
00:02:10,929 --> 00:02:12,150
And it's a little bit similar to

69
00:02:12,150 --> 00:02:14,009
the banking example
I had last time,

70
00:02:14,009 --> 00:02:15,369
but it's a little
bit more general.

71
00:02:15,369 --> 00:02:17,549
So what I'm may to imagine
here is that I'm a bank,

72
00:02:17,549 --> 00:02:20,049
and I have bank
accounts X Y and Z.

73
00:02:20,049 --> 00:02:22,569
Everybody has some number
of dollars in there.

74
00:02:22,569 --> 00:02:23,870
And those are dollars,

75
00:02:23,870 --> 00:02:25,990
by I'm calling this
transfer Euros function.

76
00:02:25,990 --> 00:02:27,689
And I'm may have a
source in a destination.

77
00:02:27,689 --> 00:02:29,369
Those might be
things like X and Y,

78
00:02:29,369 --> 00:02:31,369
and I'll specify
which bank account

79
00:02:31,369 --> 00:02:32,804
I'm transferring from and two.

80
00:02:32,804 --> 00:02:34,380
Um, since these are in dollars,

81
00:02:34,380 --> 00:02:36,819
I'm may have to first convert
those zeros to dollars.

82
00:02:36,819 --> 00:02:38,659
And then I have some
code down here.

83
00:02:38,659 --> 00:02:40,219
I'm going to say that my

84
00:02:40,219 --> 00:02:41,799
bank account cannot
draw negative.

85
00:02:41,799 --> 00:02:42,420
I'm going to check?

86
00:02:42,420 --> 00:02:44,279
Do I have enough money
to do this transfer?

87
00:02:44,279 --> 00:02:45,739
If so, we subtract from

88
00:02:45,739 --> 00:02:47,539
the source, add to
the destination.

89
00:02:47,539 --> 00:02:49,599
And then finally, we'll
say whether or not

90
00:02:49,599 --> 00:02:52,499
the transfer was able
to succeed, right?

91
00:02:52,499 --> 00:02:54,039
And I'm going to imagine that

92
00:02:54,039 --> 00:02:55,659
since let's say I'm a big bank,

93
00:02:55,659 --> 00:02:57,079
and I have lots of
users, I want to be

94
00:02:57,079 --> 00:02:58,899
able to do multiple
transfers concurrently,

95
00:02:58,899 --> 00:03:00,900
and I'm going to have
a bunch of threads.

96
00:03:00,900 --> 00:03:03,160
And, of course, I have
a bunch of threads.

97
00:03:03,160 --> 00:03:05,259
There might be some
context which is going on.

98
00:03:05,259 --> 00:03:07,319
So I want to look at this
very carefully and see,

99
00:03:07,319 --> 00:03:09,285
are there some lines of code

100
00:03:09,285 --> 00:03:12,130
where a context switch
would be convenient.

101
00:03:12,130 --> 00:03:14,410
What would be a bad time
to have a context switch.

102
00:03:14,410 --> 00:03:15,729
So I'm going to look at this.

103
00:03:15,729 --> 00:03:17,169
And if you think you
know pop up a hand,

104
00:03:17,169 --> 00:03:18,270
and then you can
tell me what some of

105
00:03:18,270 --> 00:03:20,169
these lines are that
you're worried about.

106
00:03:20,169 --> 00:03:23,030
Yeah, somebody here is
worried about some lines.

107
00:03:32,650 --> 00:03:35,270
Great. So you're saying
lines nine and ten?

108
00:03:35,270 --> 00:03:38,390
Absolutely. That would be
kind of bad context switch

109
00:03:38,390 --> 00:03:39,749
in between those, potentially.

110
00:03:39,749 --> 00:03:42,529
Anything else that we
should be worried about?

111
00:03:47,050 --> 00:03:50,729
Yeah, right over here. Is
that a handout? Or no.

112
00:03:53,490 --> 00:03:56,430
I could switch in
between these two lines,

113
00:03:56,430 --> 00:03:57,249
but I think there's a

114
00:03:57,249 --> 00:03:58,649
little bit more I
have to worry about.

115
00:03:58,649 --> 00:04:00,889
What else might I
have to worry about?

116
00:04:07,930 --> 00:04:10,529
Yeah, right here.

117
00:04:11,650 --> 00:04:15,049
Switching between these two,
I'm worried about that.

118
00:04:15,049 --> 00:04:17,290
And I think I'm

119
00:04:17,290 --> 00:04:19,829
also worried about switching
between these two, right?

120
00:04:19,829 --> 00:04:21,490
Like, what if I check

121
00:04:21,490 --> 00:04:23,169
that I have enough money,
and I'm like, Good.

122
00:04:23,169 --> 00:04:24,450
One of the things we
need to remember is that

123
00:04:24,450 --> 00:04:25,750
when we have an F
statement we evaluate

124
00:04:25,750 --> 00:04:28,429
whether it's true or
false, that's final.

125
00:04:28,429 --> 00:04:30,390
It doesn't re evaluate
it again later.

126
00:04:30,390 --> 00:04:32,464
So we might decide, Oh,
we have enough money.

127
00:04:32,464 --> 00:04:34,619
Context switch, and maybe
the money goes away,

128
00:04:34,619 --> 00:04:36,499
context switch back, and
then we would do a transfer,

129
00:04:36,499 --> 00:04:38,240
and we could potentially
go negative.

130
00:04:38,240 --> 00:04:39,500
So we have to worry about that.

131
00:04:39,500 --> 00:04:41,860
So I think what we have
to identify here is

132
00:04:41,860 --> 00:04:45,280
that these three lines of
code are a critical section,

133
00:04:45,280 --> 00:04:46,500
and we have to
figure out some way

134
00:04:46,500 --> 00:04:47,740
to make sure that those are

135
00:04:47,740 --> 00:04:50,800
not interrupted at
a bad time, right?

136
00:04:50,800 --> 00:04:52,719
And so for these
critical sections,

137
00:04:52,719 --> 00:04:53,779
there's a couple of properties

138
00:04:53,779 --> 00:04:54,880
that we want to get from them.

139
00:04:54,880 --> 00:04:55,960
And I'm going to
throw out a couple

140
00:04:55,960 --> 00:04:57,780
of words, Adamicity,
inconsistency.

141
00:04:57,780 --> 00:04:59,320
Where I see those
words again, later,

142
00:04:59,320 --> 00:05:00,820
sometimes in different
communities,

143
00:05:00,820 --> 00:05:02,380
people mean different
things by these.

144
00:05:02,380 --> 00:05:04,120
I'm going to give
one definition now.

145
00:05:04,120 --> 00:05:05,739
Adamicity means that we really

146
00:05:05,739 --> 00:05:07,660
want all or nothing, right?

147
00:05:07,660 --> 00:05:10,595
And so I'm doing two
changes, right? And

148
00:05:10,595 --> 00:05:12,130
Even though I can't, you know,

149
00:05:12,130 --> 00:05:13,470
magically snap my fingers and

150
00:05:13,470 --> 00:05:15,190
make two things happen
at the same time,

151
00:05:15,190 --> 00:05:17,010
I want it to kind
of appear that way.

152
00:05:17,010 --> 00:05:18,249
If there's another piece of code

153
00:05:18,249 --> 00:05:19,590
that's looking at
the bank accounts,

154
00:05:19,590 --> 00:05:21,709
they shouldn't see that my money

155
00:05:21,709 --> 00:05:23,470
disappeared before it
showed up somewhere else.

156
00:05:23,470 --> 00:05:24,550
That would probably cause

157
00:05:24,550 --> 00:05:26,130
a phone call or
cause some alarm.

158
00:05:26,130 --> 00:05:27,530
So I want antimicity.

159
00:05:27,530 --> 00:05:28,630
I want either both of these

160
00:05:28,630 --> 00:05:30,089
changes or none of
them to happen.

161
00:05:30,089 --> 00:05:32,210
And then the other one which
is a little bit harder to

162
00:05:32,210 --> 00:05:34,469
pin down is this
idea of consistency.

163
00:05:34,469 --> 00:05:38,590
Consistency means that all
our invariants are satisfied.

164
00:05:38,590 --> 00:05:39,850
And variant is another kind of

165
00:05:39,850 --> 00:05:42,069
funny word. What
is an invariant?

166
00:05:42,069 --> 00:05:44,250
Well, it's some rule that people

167
00:05:44,250 --> 00:05:47,089
make call about
what makes sense.

168
00:05:47,089 --> 00:05:48,270
And so I actually kind

169
00:05:48,270 --> 00:05:49,530
of slipped in an in
variant earlier.

170
00:05:49,530 --> 00:05:52,829
I said a bank account
cannot go negative.

171
00:05:52,829 --> 00:05:54,670
Is that true? Maybe
for this bank?

172
00:05:54,670 --> 00:05:56,090
I don't know, maybe I
was pre approved for

173
00:05:56,090 --> 00:05:57,610
some amount of
loan or something?

174
00:05:57,610 --> 00:05:59,550
Maybe some banks it is
okay to go negative.

175
00:05:59,550 --> 00:06:01,349
Right? That's a rule
that humans made

176
00:06:01,349 --> 00:06:03,310
up for our circumstances.

177
00:06:03,310 --> 00:06:04,950
And I think that consistency

178
00:06:04,950 --> 00:06:05,990
in these invariants is one of

179
00:06:05,990 --> 00:06:07,430
the reasons it's hard to have

180
00:06:07,430 --> 00:06:09,430
a computer do this
automatically for us.

181
00:06:09,430 --> 00:06:10,450
Humans have to be involved and

182
00:06:10,450 --> 00:06:11,809
think about how to do locking

183
00:06:11,809 --> 00:06:13,290
because humans are making

184
00:06:13,290 --> 00:06:15,150
up these rules, these
invariants, right?

185
00:06:15,150 --> 00:06:16,970
Like, if I have some program

186
00:06:16,970 --> 00:06:18,690
that's trying to automatically
add locks for me,

187
00:06:18,690 --> 00:06:20,230
how does it know whether or

188
00:06:20,230 --> 00:06:22,149
not it's okay for a bank
account to go negative?

189
00:06:22,149 --> 00:06:22,310
Right?

190
00:06:22,310 --> 00:06:23,190
That's why we have to think very

191
00:06:23,190 --> 00:06:25,089
carefully about these things.

192
00:06:25,089 --> 00:06:28,149
Alright, so once we identify
a critical section,

193
00:06:28,149 --> 00:06:29,689
by thinking very carefully,

194
00:06:29,689 --> 00:06:31,830
then we have to have
some way to protect it.

195
00:06:31,830 --> 00:06:33,350
And the way we're
going to protect it

196
00:06:33,350 --> 00:06:35,910
is with something called a lock.

197
00:06:35,910 --> 00:06:37,869
So I'm up here using that
threading library from

198
00:06:37,869 --> 00:06:40,090
last time I'm painting this
lock object right here.

199
00:06:40,090 --> 00:06:42,210
And the two most important
methods you're going to

200
00:06:42,210 --> 00:06:44,250
call it a lock are
acquire and release.

201
00:06:44,250 --> 00:06:45,069
And so here I'm calling

202
00:06:45,069 --> 00:06:46,609
a qui at the beginning
of my function,

203
00:06:46,609 --> 00:06:49,589
and I call a lock at the
release of the function.

204
00:06:49,589 --> 00:06:51,449
And for all this
code in between,

205
00:06:51,449 --> 00:06:55,449
what I'll say is that this
thread is holding the lock.

206
00:06:55,449 --> 00:06:59,475
It's held in between the
acquire and the release, okay?

207
00:06:59,475 --> 00:07:01,780
Now, what does the
lock do for me?

208
00:07:01,780 --> 00:07:03,300
It has this guarantee here.

209
00:07:03,300 --> 00:07:05,460
A lock may only be held at

210
00:07:05,460 --> 00:07:08,480
one thread by one thread
at a time, right?

211
00:07:08,480 --> 00:07:10,580
That's very helpful
because if I'm

212
00:07:10,580 --> 00:07:12,780
running this function here
and I've acquired the lock,

213
00:07:12,780 --> 00:07:14,620
and then there's another thread

214
00:07:14,620 --> 00:07:15,700
that's calling the same function

215
00:07:15,700 --> 00:07:16,839
as trying to acquire the lock,

216
00:07:16,839 --> 00:07:18,039
it's not trying to be able to.

217
00:07:18,039 --> 00:07:19,020
It's going to have to wait.

218
00:07:19,020 --> 00:07:20,440
It's going to be blocked, right?

219
00:07:20,440 --> 00:07:22,620
It's going to block
until I release it.

220
00:07:22,620 --> 00:07:24,720
And so only one thread can

221
00:07:24,720 --> 00:07:27,200
be running this little
bit of code at a time.

222
00:07:27,200 --> 00:07:28,560
And I want to be very
explicit, right?

223
00:07:28,560 --> 00:07:31,585
Sometimes people think that
a lock does more than that.

224
00:07:31,585 --> 00:07:33,470
I might be able to
context switch to

225
00:07:33,470 --> 00:07:35,249
a different thread during
this because maybe

226
00:07:35,249 --> 00:07:36,990
some other thread is
doing some computation

227
00:07:36,990 --> 00:07:39,610
totally unrelated to what
I'm doing here, right?

228
00:07:39,610 --> 00:07:41,509
So context switches
can still happen.

229
00:07:41,509 --> 00:07:44,250
But if somebody else is
trying to run some code that

230
00:07:44,250 --> 00:07:45,490
might mess up with what I'm

231
00:07:45,490 --> 00:07:46,969
doing, they're going
to get blocked.

232
00:07:46,969 --> 00:07:48,550
They're going to have
to wait until I'm done.

233
00:07:48,550 --> 00:07:52,830
We're going to take
turns. Any questions

234
00:07:52,830 --> 00:07:55,430
about what the lock is
giving you or what it's not?

235
00:07:55,430 --> 00:07:58,150
Yeah, question right here.

236
00:08:00,660 --> 00:08:02,999
Oh, how does it
know if a context

237
00:08:02,999 --> 00:08:04,620
switch will interfere with this?

238
00:08:04,620 --> 00:08:06,180
It doesn't. The scheduler can

239
00:08:06,180 --> 00:08:07,920
contact switch anytime it wants.

240
00:08:07,920 --> 00:08:09,800
So where I get safety is that

241
00:08:09,800 --> 00:08:12,080
if there's a switches
to another thread,

242
00:08:12,080 --> 00:08:14,399
and that thread is about
to require that lock.

243
00:08:14,399 --> 00:08:15,580
At that point, we'll say, Oh,

244
00:08:15,580 --> 00:08:17,240
that lock has already held.

245
00:08:17,240 --> 00:08:18,939
I have to wait.

246
00:08:18,939 --> 00:08:21,239
Right? So the scheduler
doesn't know anything.

247
00:08:21,239 --> 00:08:23,179
The scheduler can
contact switch wherever.

248
00:08:23,179 --> 00:08:24,560
But if somebody
else tries to get

249
00:08:24,560 --> 00:08:26,239
the lock, they're
going to get blocked,

250
00:08:26,239 --> 00:08:27,879
and the thread will
not be able to

251
00:08:27,879 --> 00:08:30,019
run until that lock is released.

252
00:08:30,019 --> 00:08:31,320
So that makes sense? Yeah.

253
00:08:31,320 --> 00:08:33,479
Thanks. So all the
Smarts is in us,

254
00:08:33,479 --> 00:08:34,699
people, the programmers who

255
00:08:34,699 --> 00:08:36,479
are choosing where
to put these locks.

256
00:08:36,479 --> 00:08:38,019
Other questions
people have. I saw

257
00:08:38,019 --> 00:08:40,860
another hand up play just a
minute ago. Yeah, right here.

258
00:08:45,620 --> 00:08:47,120
Exactly.

259
00:08:47,120 --> 00:08:48,920
Here, it's protecting
this segment of code,

260
00:08:48,920 --> 00:08:51,879
so only one thread
can run it at a time.

261
00:08:51,879 --> 00:08:54,320
Other functions can
be doing other stuff,

262
00:08:54,320 --> 00:08:56,480
that's fine, but I'm
protecting this piece of code.

263
00:08:56,480 --> 00:08:57,699
Yeah other questions people have

264
00:08:57,699 --> 00:08:59,360
about this locking mechanism.

265
00:08:59,360 --> 00:09:01,339
Yeah, right here.

266
00:09:15,180 --> 00:09:17,240
That's really
interesting question.

267
00:09:17,240 --> 00:09:19,060
You're saying like one lock

268
00:09:19,060 --> 00:09:21,080
one function is
conflicting with itself.

269
00:09:21,080 --> 00:09:22,860
You mean like a recursive
function or you mean that

270
00:09:22,860 --> 00:09:25,540
different threads are
calling the same function.

271
00:09:29,780 --> 00:09:37,499
Yeah, uh huh. Oh.

272
00:09:37,499 --> 00:09:39,579
Yeah, that's a good point.

273
00:09:39,579 --> 00:09:40,939
You're saying that,
like, a, like,

274
00:09:40,939 --> 00:09:42,919
I kind of have to make sure
people aren't touching

275
00:09:42,919 --> 00:09:45,199
this data structure at the
same time or threads or not,

276
00:09:45,199 --> 00:09:46,419
but you're saying
that there might be

277
00:09:46,419 --> 00:09:47,979
other things that might
conflict with each other,

278
00:09:47,979 --> 00:09:49,779
but they do not conflict
with me here, right?

279
00:09:49,779 --> 00:09:51,540
Yeah, absolutely. I
can make as many of

280
00:09:51,540 --> 00:09:53,879
these locking objects as I want.

281
00:09:53,879 --> 00:09:55,500
I cannot have two threads

282
00:09:55,500 --> 00:09:57,169
holding the same lock
at the same time.

283
00:09:57,169 --> 00:09:59,040
That's like the one
thing I'm guaranteed.

284
00:09:59,040 --> 00:10:00,260
Totally fine to have different

285
00:10:00,260 --> 00:10:01,420
threads holding different locks.

286
00:10:01,420 --> 00:10:03,339
That happens all
the time, right?

287
00:10:03,339 --> 00:10:05,599
This is the one
guarantee I have here.

288
00:10:05,599 --> 00:10:06,720
Other than that,
there's a lot of

289
00:10:06,720 --> 00:10:08,439
flexibility in terms
of what can happen.

290
00:10:08,439 --> 00:10:11,019
Yeah. Lots of excellent
questions today. Thank you.

291
00:10:11,019 --> 00:10:12,460
So when you're doing

292
00:10:12,460 --> 00:10:14,280
locking,re's different ways
you could do it, right?

293
00:10:14,280 --> 00:10:16,559
This covered my whole
critical section, right?

294
00:10:16,559 --> 00:10:18,619
And this is actually a
reasonable thing to do, right?

295
00:10:18,619 --> 00:10:20,580
It's hard to think about this
if you're not quite sure.

296
00:10:20,580 --> 00:10:22,759
And even when I was asking
you all, we're like,

297
00:10:22,759 --> 00:10:25,300
uh, is it these two lines
or is it these three lines?

298
00:10:25,300 --> 00:10:26,760
You're not sure.
It's not necessarily

299
00:10:26,760 --> 00:10:27,780
a bad idea to just say, Hey,

300
00:10:27,780 --> 00:10:29,079
I'm gonna hold the lock for this

301
00:10:29,079 --> 00:10:31,000
whole duration of
this whole function.

302
00:10:31,000 --> 00:10:33,600
Now, if we tighten
it up a little bit,

303
00:10:33,600 --> 00:10:34,900
then that might mean I can run

304
00:10:34,900 --> 00:10:37,179
more things at the same time.

305
00:10:37,179 --> 00:10:39,099
There's kind of, like,
how hard do I think

306
00:10:39,099 --> 00:10:42,260
about it versus how fast
is my code going to be.

307
00:10:42,260 --> 00:10:44,479
What I'm going to
say is that what you

308
00:10:44,479 --> 00:10:46,339
really want to do is you
want to look for lines

309
00:10:46,339 --> 00:10:48,639
of code that might
be really slow and

310
00:10:48,639 --> 00:10:49,760
that don't need a
lock and really

311
00:10:49,760 --> 00:10:51,339
make sure that those
are not part of it.

312
00:10:51,339 --> 00:10:53,660
Something like success
equals false. That's fast.

313
00:10:53,660 --> 00:10:55,979
I don't really care if
it's in or out of it.

314
00:10:55,979 --> 00:10:57,439
What about Euros to dollars?

315
00:10:57,439 --> 00:11:00,769
Is that fast? Didn't
show it, but maybe.

316
00:11:00,769 --> 00:11:03,230
I mean, if I'm just multiplying
by some constant as fast,

317
00:11:03,230 --> 00:11:06,230
but if I'm doing some API and
growing over the Internet,

318
00:11:06,230 --> 00:11:07,149
then that might be slow and

319
00:11:07,149 --> 00:11:08,309
I definitely wouldn't
want to hold

320
00:11:08,309 --> 00:11:10,629
the lock necessarily
while I'm doing that.

321
00:11:10,629 --> 00:11:10,810
Right?

322
00:11:10,810 --> 00:11:11,649
So you can have to figure out

323
00:11:11,649 --> 00:11:12,909
how tightly do you
want to do it.

324
00:11:12,909 --> 00:11:14,369
And you have to be
careful because

325
00:11:14,369 --> 00:11:16,029
if you go kind of
too tight around it,

326
00:11:16,029 --> 00:11:17,430
maybe actually some
of your critical

327
00:11:17,430 --> 00:11:18,669
sections outside of your lock.

328
00:11:18,669 --> 00:11:20,069
This would be an example of

329
00:11:20,069 --> 00:11:22,309
an incorrect implementation.
I can't do this, right?

330
00:11:22,309 --> 00:11:24,130
Because then I could
grow negative.

331
00:11:24,130 --> 00:11:26,609
It wouldn't be a
consistent implementation.

332
00:11:26,609 --> 00:11:28,009
All right. So people
have any questions

333
00:11:28,009 --> 00:11:30,089
about that idea of
lock granularity.

334
00:11:30,089 --> 00:11:38,639
Yeah, up here. I caught
the first part of it.

335
00:11:38,639 --> 00:11:41,019
So it protects bank
accunts and then what?

336
00:11:45,220 --> 00:11:47,820
What I mean by protecting
bank accounts?

337
00:11:47,820 --> 00:11:49,240
I don't want different threads

338
00:11:49,240 --> 00:11:52,419
messing around with the bank
accounts at the same time.

339
00:11:55,140 --> 00:11:58,859
You're saying the bank accounts
are the same across all.

340
00:11:58,859 --> 00:12:02,099
We, well, yeah, I
don't I don't want

341
00:12:02,099 --> 00:12:03,499
different threads
to be modifying

342
00:12:03,499 --> 00:12:04,499
the bank accounts
at the same time

343
00:12:04,499 --> 00:12:05,820
because we saw even before,

344
00:12:05,820 --> 00:12:07,390
something like you know,

345
00:12:07,390 --> 00:12:08,710
adding one to an integer.

346
00:12:08,710 --> 00:12:11,349
That could be interrupted
at a bad time, right?

347
00:12:11,349 --> 00:12:13,889
So if there's multiple
concurrent accesses to

348
00:12:13,889 --> 00:12:16,830
the same bank account and
there's a bad inter leaving,

349
00:12:16,830 --> 00:12:18,429
I could get weird
results, right?

350
00:12:18,429 --> 00:12:20,810
So by protecting it,
what I mean is that I

351
00:12:20,810 --> 00:12:23,409
only want one thread
touching it at a time.

352
00:12:23,409 --> 00:12:25,029
And that kind of brings
us back to how we

353
00:12:25,029 --> 00:12:26,949
actually identify these
critical sections, right?

354
00:12:26,949 --> 00:12:28,169
What I'm looking for are

355
00:12:28,169 --> 00:12:29,589
things that multiple
threads might touch.

356
00:12:29,589 --> 00:12:30,869
So global variables are one of

357
00:12:30,869 --> 00:12:32,309
the first things I'm
going to key in when I'm

358
00:12:32,309 --> 00:12:35,230
trying to identify
a critical section.

359
00:12:35,230 --> 00:12:36,789
You know, a local variable could

360
00:12:36,789 --> 00:12:38,850
also reference something
that's shared on the heap.

361
00:12:38,850 --> 00:12:40,350
I might have to worry
about that as well.

362
00:12:40,350 --> 00:12:41,669
But that's what we're trying
to do. We're trying to

363
00:12:41,669 --> 00:12:43,330
identify things that
might be accessed by

364
00:12:43,330 --> 00:12:44,889
different threads at the
same time and then make

365
00:12:44,889 --> 00:12:47,629
sure those are protected
with these locks.

366
00:12:47,880 --> 00:12:50,720
Yeah, question right here.

367
00:12:57,670 --> 00:13:00,070
Mm hm.

368
00:13:03,270 --> 00:13:05,730
Yeah. First off the comment

369
00:13:05,730 --> 00:13:07,610
was that local variables
are on the heap.

370
00:13:07,610 --> 00:13:09,969
That's actually true
in some sense, right?

371
00:13:09,969 --> 00:13:11,450
Let's create like
a string variable

372
00:13:11,450 --> 00:13:12,309
or something like that.

373
00:13:12,309 --> 00:13:14,129
Then I have that variable,

374
00:13:14,129 --> 00:13:15,369
which is on the stack, but it's

375
00:13:15,369 --> 00:13:17,349
referring to something
on the heap, right?

376
00:13:17,349 --> 00:13:18,769
So just because
something's on the heap

377
00:13:18,769 --> 00:13:20,489
doesn't mean I have a problem.

378
00:13:20,489 --> 00:13:22,029
I start worrying when I have

379
00:13:22,029 --> 00:13:24,210
multiple different references
to that thing on that heap,

380
00:13:24,210 --> 00:13:27,789
and maybe different threads
can see different references.

381
00:13:27,789 --> 00:13:29,449
If I know I'm the
only one who can

382
00:13:29,449 --> 00:13:31,390
see it on the heap,
then I'm fine.

383
00:13:31,390 --> 00:13:33,470
I don't have to worry,
right? Does that make sense?

384
00:13:33,470 --> 00:13:36,450
Yeah, y, you're right. There's
some more nuance there.

385
00:13:36,450 --> 00:13:38,469
Yeah, lots of excellent points

386
00:13:38,469 --> 00:13:40,109
today and questions. All right.

387
00:13:40,109 --> 00:13:41,649
Let's do I'm going to do

388
00:13:41,649 --> 00:13:43,469
a couple of worksheet
examples and then do

389
00:13:43,469 --> 00:13:45,429
some coding demos and

390
00:13:45,429 --> 00:13:49,189
try to make this all a little
bit more concrete for us.

391
00:13:49,790 --> 00:13:51,209
All right.

392
00:13:51,209 --> 00:13:54,050
And so I have two
snippets of code here.

393
00:13:54,050 --> 00:13:56,269
And I'm going to

394
00:13:56,269 --> 00:13:57,970
try I walk through the
data structures first.

395
00:13:57,970 --> 00:13:59,389
I have this y variable, which is

396
00:13:59,389 --> 00:14:00,950
kind of not that
important to the example.

397
00:14:00,950 --> 00:14:03,490
Honestly. I have a list,

398
00:14:03,490 --> 00:14:05,049
which has two elements in it.

399
00:14:05,049 --> 00:14:07,929
And then I have this x
variable, which is two.

400
00:14:07,929 --> 00:14:11,450
And I'm imagining that
the variant that I as

401
00:14:11,450 --> 00:14:13,209
the programmer I'm going
for is that I want

402
00:14:13,209 --> 00:14:15,730
x to be equal to the
length of the list.

403
00:14:15,730 --> 00:14:18,609
And right now I can see that
the variant is satisfied.

404
00:14:18,609 --> 00:14:20,770
At this moment in time, right?

405
00:14:20,770 --> 00:14:22,629
And so when I look
at thread one,

406
00:14:22,629 --> 00:14:25,449
thread one acquires a
lock, it appends three.

407
00:14:25,449 --> 00:14:27,489
It increases X, it releases it.

408
00:14:27,489 --> 00:14:28,990
Great. So the logic in thread

409
00:14:28,990 --> 00:14:31,189
one is maintaining
that in variant.

410
00:14:31,189 --> 00:14:33,709
And then thread two is
acquiring the lock,

411
00:14:33,709 --> 00:14:35,629
and it's saying
length of minus x,

412
00:14:35,629 --> 00:14:37,069
and it's storing that in depth.

413
00:14:37,069 --> 00:14:40,629
And so if everything's working
well, what would d be?

414
00:14:42,910 --> 00:14:44,809
Zero, excellent, right?

415
00:14:44,809 --> 00:14:46,889
So if x is equal to
the length of L,

416
00:14:46,889 --> 00:14:48,329
then D will be zero, right?

417
00:14:48,329 --> 00:14:50,089
So that's what I want. And this

418
00:14:50,089 --> 00:14:51,570
is kind of a weird example.

419
00:14:51,570 --> 00:14:53,349
I want to make sure I
don't confuse people.

420
00:14:53,349 --> 00:14:55,329
What I've done is I've

421
00:14:55,329 --> 00:14:57,329
drawn an inter leaving with
some context switches,

422
00:14:57,329 --> 00:14:58,490
and I wrote out something that's

423
00:14:58,490 --> 00:15:00,169
actually impossible, right?

424
00:15:00,169 --> 00:15:02,089
If locks are doing what
they're supposed to

425
00:15:02,089 --> 00:15:04,189
do, this cannot happen.

426
00:15:04,189 --> 00:15:05,890
And when the thing that
happens that shouldn't,

427
00:15:05,890 --> 00:15:07,710
then lots of other weird
things happen, too.

428
00:15:07,710 --> 00:15:09,489
That's the point here. I'm
not saying this can happen.

429
00:15:09,489 --> 00:15:11,110
I'm saying it actually
cannot happen,

430
00:15:11,110 --> 00:15:12,810
but I want you to
help me pinpoint

431
00:15:12,810 --> 00:15:15,049
what is the thing
that cannot happen.

432
00:15:15,049 --> 00:15:16,959
So L et's walk through this.

433
00:15:16,959 --> 00:15:20,419
So y plus equals one, so
we're running thread two.

434
00:15:20,419 --> 00:15:23,440
Great, so y goes four to
five, context switch.

435
00:15:23,440 --> 00:15:27,680
Thread one acquires
a lock. Okay, fine.

436
00:15:27,680 --> 00:15:31,339
Now, context switches
to thread two,

437
00:15:31,339 --> 00:15:34,519
and I want everybody
to gi me a thumbs up.

438
00:15:34,519 --> 00:15:36,159
Yeah, this is something
that could happen,

439
00:15:36,159 --> 00:15:38,320
or no, that's not allowed.

440
00:15:38,320 --> 00:15:40,040
It's impossible.

441
00:15:43,310 --> 00:15:45,590
In kind of a mix of things.

442
00:15:45,590 --> 00:15:48,429
This is totally okay, right?

443
00:15:48,429 --> 00:15:50,409
Holding a lock does not

444
00:15:50,409 --> 00:15:53,329
prevent a context
switch. And why what?

445
00:15:53,329 --> 00:15:55,290
Right? This? Why
stuff is totally

446
00:15:55,290 --> 00:15:57,109
unrelated to what the locking

447
00:15:57,109 --> 00:15:58,350
is with. That is totally okay.

448
00:15:58,350 --> 00:15:59,969
That happens all
the time. Locks do

449
00:15:59,969 --> 00:16:01,110
not prevent context switch.

450
00:16:01,110 --> 00:16:03,510
This is common misconception,
I see again and again.

451
00:16:03,510 --> 00:16:06,310
Okay, great. So, I
context switch back here.

452
00:16:06,310 --> 00:16:07,950
I have penned three
to L. So now,

453
00:16:07,950 --> 00:16:09,949
instead of 54, it's 543.

454
00:16:09,949 --> 00:16:11,769
Great. I context switch here.

455
00:16:11,769 --> 00:16:13,909
And then I call

456
00:16:13,909 --> 00:16:16,970
a qui return successfully.
Can that happen?

457
00:16:16,970 --> 00:16:18,650
Give me a thumbs up
if it can happen,

458
00:16:18,650 --> 00:16:22,630
thumbs down if it
cannot happen. Awesome.

459
00:16:22,630 --> 00:16:24,169
People are getting
it. This cannot

460
00:16:24,169 --> 00:16:26,549
happen. This is impossible.

461
00:16:27,550 --> 00:16:29,070
Right?

462
00:16:29,070 --> 00:16:31,429
If locking is working
correctly, right,

463
00:16:31,429 --> 00:16:33,290
which it generally does,

464
00:16:33,290 --> 00:16:34,889
then this could
never happen, right?

465
00:16:34,889 --> 00:16:36,329
And I should, maybe, honestly,

466
00:16:36,329 --> 00:16:37,750
finish the example there be it

467
00:16:37,750 --> 00:16:38,989
kind of confuses
people think about

468
00:16:38,989 --> 00:16:40,349
like if something
impossible happens,

469
00:16:40,349 --> 00:16:41,689
while other weird things happen.

470
00:16:41,689 --> 00:16:43,630
But let's just cherry
on for a moment.

471
00:16:43,630 --> 00:16:48,129
So D equals length of L
minus x, that would be one.

472
00:16:48,129 --> 00:16:50,229
So already, I kind of
broke my invariant.

473
00:16:50,229 --> 00:16:51,410
If locks were not giving

474
00:16:51,410 --> 00:16:52,649
me what they're
supposed to give me,

475
00:16:52,649 --> 00:16:54,369
then weird things like
that would happen.

476
00:16:54,369 --> 00:16:56,010
Here, I would release the lock.

477
00:16:56,010 --> 00:16:58,474
Okay. And so this point,
nobody's holding the lock.

478
00:16:58,474 --> 00:17:00,499
And then let's say we
contact switch over here.

479
00:17:00,499 --> 00:17:02,419
And then, oh, this is
actually a double release,

480
00:17:02,419 --> 00:17:02,979
so then I would have

481
00:17:02,979 --> 00:17:04,920
a double release
exception over here.

482
00:17:04,920 --> 00:17:06,339
Again, this can't happen

483
00:17:06,339 --> 00:17:08,019
because we'd have never
gotten this far, right?

484
00:17:08,019 --> 00:17:11,080
So so this would be a
double release exception.

485
00:17:11,080 --> 00:17:13,400
And you might see
that at some point.

486
00:17:13,400 --> 00:17:15,159
Why is it an exception to

487
00:17:15,159 --> 00:17:17,700
release a lock that's
already released?

488
00:17:17,700 --> 00:17:20,040
Well, if you write code
that's releasing a lock,

489
00:17:20,040 --> 00:17:21,859
that kind of implies that
you were holding it,

490
00:17:21,859 --> 00:17:23,319
and if you weren't
actually holding it,

491
00:17:23,319 --> 00:17:25,359
that's almost certainly
a bug, right?

492
00:17:25,359 --> 00:17:28,100
So if you see a double
release exception,

493
00:17:28,100 --> 00:17:29,419
it's probably not there.

494
00:17:29,419 --> 00:17:30,660
It's probably earlier
that you meant

495
00:17:30,660 --> 00:17:32,820
to acquire, and you didn't.

496
00:17:32,820 --> 00:17:33,899
All right.

497
00:17:33,899 --> 00:17:43,590
Questions about that
example. Alright. Fantastic.

498
00:17:43,590 --> 00:17:45,570
So now we're going
to do a top hat.

499
00:17:45,570 --> 00:17:47,830
And so I have an
example down here.

500
00:17:47,830 --> 00:17:52,930
And what we can see is that
I have this Q variable.

501
00:17:52,930 --> 00:17:54,369
It starts off being like two,

502
00:17:54,369 --> 00:17:56,710
and then thread two is
trying to change it to zero,

503
00:17:56,710 --> 00:17:58,609
and thread one is trying
to take the verse of it.

504
00:17:58,609 --> 00:18:01,789
So you can already see like
1/0. That's a problem.

505
00:18:01,789 --> 00:18:03,830
And so I'm using some locks.

506
00:18:03,830 --> 00:18:05,169
I want you to help me write out

507
00:18:05,169 --> 00:18:07,670
an example where I'm going
to get that divided by zero.

508
00:18:07,670 --> 00:18:08,930
And rather than doing

509
00:18:08,930 --> 00:18:10,470
kind of a full, like,
back and forth trace,

510
00:18:10,470 --> 00:18:12,569
I want you to say
something like, you know,

511
00:18:12,569 --> 00:18:15,540
like, line X ran
and then line Y Rn.

512
00:18:15,540 --> 00:18:16,899
Just have something
simple like that.

513
00:18:16,899 --> 00:18:18,660
I might leave that up there,

514
00:18:18,660 --> 00:18:19,959
and meanwhile might open up

515
00:18:19,959 --> 00:18:21,619
top hat on here so you can all

516
00:18:21,619 --> 00:18:25,200
whip out your phones
and when you're ready,

517
00:18:25,200 --> 00:18:27,479
you can submit what
you think will happen.

518
00:18:27,479 --> 00:18:30,799
And I'm going to give you
2 minutes to do this.

519
00:18:30,799 --> 00:18:33,439
And I'll just remind

520
00:18:33,439 --> 00:18:35,020
you when there's about,
like, 1 minute left.

521
00:18:35,020 --> 00:18:36,579
So go ahead, kind of
work through that and

522
00:18:36,579 --> 00:18:39,200
then put it on top hat
when you're ready.

523
00:19:24,850 --> 00:19:27,849
Oh, left.

524
00:20:09,850 --> 00:20:11,209
All right.

525
00:20:11,209 --> 00:20:14,489
15 seconds. I'll put
something in soon, please.

526
00:20:31,120 --> 00:20:33,220
Alright, fantastic, things.

527
00:20:33,220 --> 00:20:35,459
So let's come over here and
work through this together.

528
00:20:35,459 --> 00:20:37,460
Let's just do it as a
group. There's a couple

529
00:20:37,460 --> 00:20:39,379
of right answers, but
let's just do one.

530
00:20:39,379 --> 00:20:41,519
Does somebody want to shout
out? What should we say?

531
00:20:41,519 --> 00:20:43,740
What line executes first?

532
00:20:43,740 --> 00:20:46,200
Let's say an A executes first.

533
00:20:46,200 --> 00:20:48,319
Okay. That sounds good
to me. So we'll say A.

534
00:20:48,319 --> 00:20:51,060
And at this moment,
A is t. And again,

535
00:20:51,060 --> 00:20:52,199
the really important
thing is that

536
00:20:52,199 --> 00:20:53,680
once we've decided it's true,

537
00:20:53,680 --> 00:20:55,719
the instruction is going
to keep moving on.

538
00:20:55,719 --> 00:20:58,959
We're not trying to reevaluate
that again. All right.

539
00:20:58,959 --> 00:21:00,920
And then somebody else.

540
00:21:00,920 --> 00:21:03,439
What happens next?
Yeah, right over here.

541
00:21:03,439 --> 00:21:08,520
L et's context switch and
say that x runs next, okay?

542
00:21:10,440 --> 00:21:12,180
And then at this point,

543
00:21:12,180 --> 00:21:13,579
I mean, we could
context switch back,

544
00:21:13,579 --> 00:21:15,040
and we might try telling a qui,

545
00:21:15,040 --> 00:21:16,559
but acquire will not return

546
00:21:16,559 --> 00:21:20,199
successfully until Thread
two finishes, right?

547
00:21:20,199 --> 00:21:21,399
So maybe we might context

548
00:21:21,399 --> 00:21:22,599
switch here and
context switch back,

549
00:21:22,599 --> 00:21:24,379
but we won't actually be able
to acquire in T thread one.

550
00:21:24,379 --> 00:21:25,719
And that means at
this point, we just

551
00:21:25,719 --> 00:21:27,639
have to run this through, right?

552
00:21:27,639 --> 00:21:29,799
So x y z.

553
00:21:29,799 --> 00:21:32,059
So this point we've
finished thread two.

554
00:21:32,059 --> 00:21:33,799
All that's left to
do is switch back.

555
00:21:33,799 --> 00:21:35,069
We're going to do B.

556
00:21:35,069 --> 00:21:37,660
And then C. And at this point,

557
00:21:37,660 --> 00:21:39,379
we get a divide by zero, right?

558
00:21:39,379 --> 00:21:41,519
Because when y ran, right?

559
00:21:41,519 --> 00:21:43,419
Then we had then we had what?

560
00:21:43,419 --> 00:21:45,200
We had Q equal zero.

561
00:21:45,200 --> 00:21:47,739
And then here we have a
divide by zero, right?

562
00:21:47,739 --> 00:21:50,499
Divide by zero, right?

563
00:21:50,499 --> 00:21:51,260
So we have to be really

564
00:21:51,260 --> 00:21:52,699
careful about kind
of getting those.

565
00:21:52,699 --> 00:21:54,559
That locking granularity, right.

566
00:21:54,559 --> 00:21:56,119
Alright. Fantastic.
Any questions about

567
00:21:56,119 --> 00:21:58,779
that before we do some
programming demos?

568
00:22:00,150 --> 00:22:04,250
All right. My head over
here to my laptop.

569
00:22:04,250 --> 00:22:06,749
And the first one I might do

570
00:22:06,749 --> 00:22:10,969
is the one we were
working on last time.

571
00:22:10,969 --> 00:22:14,129
So what were we doing last time?

572
00:22:14,129 --> 00:22:15,949
I was starting up these
two different threads.

573
00:22:15,949 --> 00:22:17,649
And in each case, I was passing

574
00:22:17,649 --> 00:22:19,969
1 million into this ad function.

575
00:22:19,969 --> 00:22:21,530
So looping 1 million times,

576
00:22:21,530 --> 00:22:23,190
and I was adding one to total.

577
00:22:23,190 --> 00:22:26,090
And you might remember
from last time that well,

578
00:22:26,090 --> 00:22:27,489
I had hoped for 2 million I

579
00:22:27,489 --> 00:22:29,149
wasn't getting it. Why was that?

580
00:22:29,149 --> 00:22:31,630
We did a little disassembly
down here and we saw

581
00:22:31,630 --> 00:22:34,190
that When we look at
the byte road level,

582
00:22:34,190 --> 00:22:35,089
like this one line of

583
00:22:35,089 --> 00:22:36,269
code is actually a
few things, right?

584
00:22:36,269 --> 00:22:37,390
We're loading the
variable, we're

585
00:22:37,390 --> 00:22:39,070
loading a constant
adding, storing.

586
00:22:39,070 --> 00:22:41,369
That can get interrupted
by the scheduler, right?

587
00:22:41,369 --> 00:22:43,189
So even something as
simple as like this,

588
00:22:43,189 --> 00:22:44,589
I could have a context switch in

589
00:22:44,589 --> 00:22:46,109
the middle of that
plus equals one,

590
00:22:46,109 --> 00:22:48,089
and then the math
doesn't add up.

591
00:22:48,089 --> 00:22:51,270
Okay, so let's actually go
ahead and fix this now.

592
00:22:51,270 --> 00:22:55,670
I am going to say my lock
equals threading, dot, lock.

593
00:22:55,670 --> 00:23:00,945
And then down here, what I can
say is lock, dot, acquire.

594
00:23:00,945 --> 00:23:03,900
Locked out acquir
and I could say lock

595
00:23:03,900 --> 00:23:06,619
dot, release. All right.

596
00:23:06,619 --> 00:23:09,519
So let's do that. And I

597
00:23:09,519 --> 00:23:10,360
think that this will also

598
00:23:10,360 --> 00:23:11,699
probably run a little
bit slower now.

599
00:23:11,699 --> 00:23:13,419
So I want to import some
time and I want to see

600
00:23:13,419 --> 00:23:15,439
how long this whole
business takes, right?

601
00:23:15,439 --> 00:23:18,300
So I may say start time
equals time dot time here.

602
00:23:18,300 --> 00:23:21,360
And then down here, I may
say n equals time dot.

603
00:23:21,360 --> 00:23:22,740
And then I can just print off,

604
00:23:22,740 --> 00:23:25,379
how long did this whole
thing take, right?

605
00:23:25,379 --> 00:23:27,020
So I'm going to run
that for a moment.

606
00:23:27,020 --> 00:23:29,559
And let's do a little bigger.

607
00:23:29,559 --> 00:23:30,860
So I have something that
actually runs a while.

608
00:23:30,860 --> 00:23:32,439
Let's do like 10 million.

609
00:23:32,439 --> 00:23:35,180
Alright. We're going to do
that. We can see first off,

610
00:23:35,180 --> 00:23:37,519
I got the right answer,
so that's good news.

611
00:23:37,519 --> 00:23:39,120
So that will run for a while.

612
00:23:39,120 --> 00:23:41,899
And then finally, I
see that it took about

613
00:23:41,899 --> 00:23:45,859
5.5 seconds to get that
20 million, right?

614
00:23:45,859 --> 00:23:47,500
Okay, great. That
solves a problem.

615
00:23:47,500 --> 00:23:49,019
A quick question for you all.

616
00:23:49,019 --> 00:23:50,419
Now that I have locking here,

617
00:23:50,419 --> 00:23:52,599
do I still need
join for anything?

618
00:23:52,599 --> 00:23:54,800
Is that useful? What is Join

619
00:23:54,800 --> 00:23:57,699
giving me? Now that
I have locking?

620
00:24:03,650 --> 00:24:06,250
Yeah, right here.

621
00:24:07,530 --> 00:24:09,649
I need to make sure
the road actually

622
00:24:09,649 --> 00:24:10,949
finishes before I
look at the results.

623
00:24:10,949 --> 00:24:12,210
So what Locking is really good

624
00:24:12,210 --> 00:24:13,569
at is to make sure two pieces of

625
00:24:13,569 --> 00:24:15,069
code are not running at

626
00:24:15,069 --> 00:24:16,730
the same time. That's
what locking does.

627
00:24:16,730 --> 00:24:18,729
Sometimes I further
care about that

628
00:24:18,729 --> 00:24:21,509
this piece of code runs
before that piece of code.

629
00:24:21,509 --> 00:24:23,269
Joining is one of the things
that will help us do that.

630
00:24:23,269 --> 00:24:24,850
There's other stuff out
there if you like to go take

631
00:24:24,850 --> 00:24:27,050
the OS course 53070 to learn
about some other things.

632
00:24:27,050 --> 00:24:28,290
The two primitives we learn

633
00:24:28,290 --> 00:24:29,490
in this course is
locks for making

634
00:24:29,490 --> 00:24:30,569
sure things don't happen at

635
00:24:30,569 --> 00:24:32,489
the same time and join
to make sure that,

636
00:24:32,489 --> 00:24:34,630
you know, Code A runs before

637
00:24:34,630 --> 00:24:37,110
Code B. Alright,
so that's great.

638
00:24:37,110 --> 00:24:38,709
We solved that problem.

639
00:24:38,709 --> 00:24:40,949
And what I'm doing here is what

640
00:24:40,949 --> 00:24:43,429
we might call fine
grained locking.

641
00:24:43,429 --> 00:24:45,869
I kind of acquire a lock, and
I do a small piece of work,

642
00:24:45,869 --> 00:24:47,790
and then I release a lock.

643
00:24:47,790 --> 00:24:49,990
Okay? And if I do
fine grain locking,

644
00:24:49,990 --> 00:24:52,190
maybe I can be having lots
of different threads doing

645
00:24:52,190 --> 00:24:54,949
things maybe roughly
at the same same time.

646
00:24:54,949 --> 00:24:57,869
Now, a lot of people have
this intuition that, oh,

647
00:24:57,869 --> 00:24:59,850
I need finer drain locks
to get better performance,

648
00:24:59,850 --> 00:25:01,610
and that's not always true.

649
00:25:01,610 --> 00:25:04,649
Unfortunately, locking has
a lot of overhead to it,

650
00:25:04,649 --> 00:25:06,289
and so doing just a little bit

651
00:25:06,289 --> 00:25:07,890
of work with each lock
is not always best.

652
00:25:07,890 --> 00:25:09,089
So I'm just try to
make a note here.

653
00:25:09,089 --> 00:25:12,509
This is what I would call
fine grained locking.

654
00:25:12,509 --> 00:25:14,149
What I'm going to
do is I'm going

655
00:25:14,149 --> 00:25:15,329
to copy this whole business,

656
00:25:15,329 --> 00:25:17,029
and I'm going to come down
here and I want to see

657
00:25:17,029 --> 00:25:19,729
what is core strain
locking like.

658
00:25:19,729 --> 00:25:21,509
So I to do some core
strain locking.

659
00:25:21,509 --> 00:25:23,589
And here, I'm just going to

660
00:25:23,589 --> 00:25:25,809
the opposite of doing one thing.

661
00:25:25,809 --> 00:25:27,290
I'm going to do
10 million things

662
00:25:27,290 --> 00:25:29,889
before I release that lock
and I'm going to run that.

663
00:25:29,889 --> 00:25:34,309
And what I'll see is that
instead of taking 5.7 seconds,

664
00:25:34,309 --> 00:25:36,429
it is 1.5 seconds.

665
00:25:36,429 --> 00:25:37,909
One of the takeaways
here is that

666
00:25:37,909 --> 00:25:39,909
all this stuff with locking
and the performance of it,

667
00:25:39,909 --> 00:25:41,889
a lot of it is very
counterintuitive,

668
00:25:41,889 --> 00:25:43,569
and I want you to
get in the habit

669
00:25:43,569 --> 00:25:45,729
of measuring your code.

670
00:25:45,729 --> 00:25:47,929
Don't take some
code that's simple

671
00:25:47,929 --> 00:25:50,464
and make it super complicated
to have a bunch of locks.

672
00:25:50,464 --> 00:25:52,159
And then accidently
make it slower.

673
00:25:52,159 --> 00:25:53,580
That's just like the
worst of all worlds.

674
00:25:53,580 --> 00:25:54,439
It happened to me once.

675
00:25:54,439 --> 00:25:57,719
I was working on this
bioinformatics open source thing,

676
00:25:57,719 --> 00:26:00,239
and I was like, really slow
and I was kind of diving in.

677
00:26:00,239 --> 00:26:03,440
And what I saw is that they
had to read this large file,

678
00:26:03,440 --> 00:26:05,539
and that was like the slow
thing they had to do.

679
00:26:05,539 --> 00:26:07,620
And so this bioinformatician,

680
00:26:07,620 --> 00:26:09,100
what they did is
they had a bunch

681
00:26:09,100 --> 00:26:10,820
of threads and they
would acquire the lock,

682
00:26:10,820 --> 00:26:13,440
read the line of the file,
and then release the lock,

683
00:26:13,440 --> 00:26:14,699
and they would draw line by line

684
00:26:14,699 --> 00:26:16,179
and they probably saw it was
slow and they're just like,

685
00:26:16,179 --> 00:26:17,239
I'm going to optimize this and

686
00:26:17,239 --> 00:26:18,679
break and pat
themselves on the back.

687
00:26:18,679 --> 00:26:21,020
I deleted all of that, made
it a single thread version,

688
00:26:21,020 --> 00:26:22,599
and was like ten
times faster, right?

689
00:26:22,599 --> 00:26:24,720
So measure things. Don't assume

690
00:26:24,720 --> 00:26:26,399
that you're making
things faster.

691
00:26:26,399 --> 00:26:28,319
Yeah, question right here.

692
00:26:30,390 --> 00:26:32,709
What's that?

693
00:26:33,910 --> 00:26:36,609
Yeah, what is the reason
for it to be faster?

694
00:26:36,609 --> 00:26:37,929
So in this case,
there's probably not

695
00:26:37,929 --> 00:26:39,649
very many context
switches, right?

696
00:26:39,649 --> 00:26:41,050
It's probably just like
going to be running

697
00:26:41,050 --> 00:26:43,269
this one for a long time.

698
00:26:43,269 --> 00:26:45,369
I don't want to get too much
on the hardware details

699
00:26:45,369 --> 00:26:46,729
of it as well.

700
00:26:46,729 --> 00:26:48,449
But we spent all this
time learning about

701
00:26:48,449 --> 00:26:51,470
the cashes like the
l1l2, L three cash.

702
00:26:51,470 --> 00:26:53,430
We kind of have to be a little

703
00:26:53,430 --> 00:26:54,609
bit careful about how cashing

704
00:26:54,609 --> 00:26:57,289
works if we have locking, right?

705
00:26:57,289 --> 00:26:59,130
So we'll maybe
take it as a given

706
00:26:59,130 --> 00:27:01,070
that it's slower without
getting too much details.

707
00:27:01,070 --> 00:27:02,370
And we can talk more offline

708
00:27:02,370 --> 00:27:04,629
as well. Yeah,
question right here.

709
00:27:06,630 --> 00:27:12,709
S Yeah.

710
00:27:17,430 --> 00:27:19,929
Yeah, what actually happens.

711
00:27:19,929 --> 00:27:21,290
So I guess, in this case,

712
00:27:21,290 --> 00:27:23,090
let's say thread
one starts first,

713
00:27:23,090 --> 00:27:24,889
acquires that lock
for a long time.

714
00:27:24,889 --> 00:27:26,190
Now you're saying
Lock two comes along.

715
00:27:26,190 --> 00:27:27,249
It tries to a You're

716
00:27:27,249 --> 00:27:28,909
saying what happens
with T thread two?

717
00:27:28,909 --> 00:27:31,389
Yeah. Yeah, that's a
great question, right?

718
00:27:31,389 --> 00:27:33,749
So we have a little help
from the operating system.

719
00:27:33,749 --> 00:27:35,729
And what we learned last time,

720
00:27:35,729 --> 00:27:38,109
maybe a couple of times ago was

721
00:27:38,109 --> 00:27:40,470
that threads can be
one of three states.

722
00:27:40,470 --> 00:27:42,710
They can be actually
running out of CPU.

723
00:27:42,710 --> 00:27:45,449
They can be ready to
run, given the option,

724
00:27:45,449 --> 00:27:46,789
or they can be blocked on

725
00:27:46,789 --> 00:27:49,949
like Deskio or Internet
or anything, right?

726
00:27:49,949 --> 00:27:53,550
When you try to acquire a lock
and that lock is not free,

727
00:27:53,550 --> 00:27:54,689
the operating system
is going to say,

728
00:27:54,689 --> 00:27:55,830
Oh, you are blocked now,

729
00:27:55,830 --> 00:27:57,730
and the scheduler
will not even try

730
00:27:57,730 --> 00:28:02,229
to run it until that lock is
There's other variants too.

731
00:28:02,229 --> 00:28:02,889
I'm just thinking like one

732
00:28:02,889 --> 00:28:03,630
of the things that could happen.

733
00:28:03,630 --> 00:28:04,349
That's what happened here.

734
00:28:04,349 --> 00:28:06,009
There's other ways
people do locks as well,

735
00:28:06,009 --> 00:28:07,790
but that's what would
generally happen.

736
00:28:07,790 --> 00:28:09,070
Yeah, yeah, great question.

737
00:28:09,070 --> 00:28:11,189
Yeah. Other questions
people have.

738
00:28:11,930 --> 00:28:14,289
All right. Cool.

739
00:28:14,289 --> 00:28:16,629
So, what I want to do

740
00:28:16,629 --> 00:28:19,410
now is jump over to
another example.

741
00:28:19,410 --> 00:28:21,149
And this is in my
lecture snippets.

742
00:28:21,149 --> 00:28:22,549
So if you go to the
website and you like

743
00:28:22,549 --> 00:28:26,270
resources and lecture snippets,

744
00:28:26,270 --> 00:28:28,910
I have that banking example

745
00:28:28,910 --> 00:28:31,909
from earlier, which I will copy.

746
00:28:31,909 --> 00:28:35,289
And I will start that in
a new notebook over here,

747
00:28:35,289 --> 00:28:37,930
and I'm going to
import threading,

748
00:28:37,930 --> 00:28:43,040
and I mean, I guess it's not
really doing anything yet.

749
00:28:43,040 --> 00:28:44,679
We can actually see
that they already do

750
00:28:44,679 --> 00:28:46,780
some locking here.
They create a lock.

751
00:28:46,780 --> 00:28:48,439
It's a very coarse
screen locking.

752
00:28:48,439 --> 00:28:49,739
I think that's all fine, right?

753
00:28:49,739 --> 00:28:51,280
So all is good.

754
00:28:51,280 --> 00:28:53,540
Let me just try running this
code with a few transfers.

755
00:28:53,540 --> 00:28:57,479
I'm going to say, let's
transfer let's say,

756
00:28:57,479 --> 00:28:58,900
from X to Y,

757
00:28:58,900 --> 00:29:00,620
and we're going to
transfer like $5.

758
00:29:00,620 --> 00:29:01,799
And then after
that I want to see

759
00:29:01,799 --> 00:29:03,860
what is in my bank accounts.

760
00:29:03,860 --> 00:29:05,819
Let's take a look at that.

761
00:29:05,819 --> 00:29:07,239
Okay, that worked fine, right?

762
00:29:07,239 --> 00:29:08,479
Now, I'm going to actually

763
00:29:08,479 --> 00:29:09,840
do something that's
going to fail.

764
00:29:09,840 --> 00:29:13,799
I'm going to say, let's
transfer from W to Y.

765
00:29:13,799 --> 00:29:15,319
And that's going to be a problem

766
00:29:15,319 --> 00:29:17,780
because Well, there's no W here.

767
00:29:17,780 --> 00:29:19,379
And if you try to look

768
00:29:19,379 --> 00:29:21,079
up a key that doesn't
exist like this,

769
00:29:21,079 --> 00:29:22,520
if I'm trying to
look up that value,

770
00:29:22,520 --> 00:29:24,300
then I would get a
key error exception.

771
00:29:24,300 --> 00:29:27,040
And so let's see I get
my key error exception.

772
00:29:27,040 --> 00:29:28,639
Okay, fine, right?

773
00:29:28,639 --> 00:29:31,079
I'll make a note here,
right. So there is

774
00:29:31,079 --> 00:29:34,040
no W. And, fine.

775
00:29:34,040 --> 00:29:36,679
Let's do this from something
else. I will do it from Z.

776
00:29:36,679 --> 00:29:38,539
There's a Z. And so
I'm going to say,

777
00:29:38,539 --> 00:29:40,699
let's grow from z to y, right?

778
00:29:40,699 --> 00:29:42,399
I know there's a Z,
I know there's a Y.

779
00:29:42,399 --> 00:29:46,249
Let me do that. And Huh?

780
00:29:46,249 --> 00:29:48,810
Well, that's taking
a long time to run.

781
00:29:48,810 --> 00:29:50,969
I wonder what happened
there. Let me

782
00:29:50,969 --> 00:29:52,990
take a look back at
this code up here.

783
00:29:52,990 --> 00:29:55,230
And let's take a moment.

784
00:29:55,230 --> 00:29:56,909
And if anybody has

785
00:29:56,909 --> 00:29:58,890
any thoughts on why
I'm suddenly stuck,

786
00:29:58,890 --> 00:30:00,930
yeah, pop up a hand.
Yeah, right here already.

787
00:30:00,930 --> 00:30:02,994
Is still acquired from previous.

788
00:30:02,994 --> 00:30:05,559
The lock is still acquired.
Excellent, right?

789
00:30:05,559 --> 00:30:06,840
Be what happened before?

790
00:30:06,840 --> 00:30:08,800
I acquired the lock,
I was drawing lock.

791
00:30:08,800 --> 00:30:11,019
I had an exception,
and I popped out of

792
00:30:11,019 --> 00:30:13,699
that function before we
actually ever ever released.

793
00:30:13,699 --> 00:30:15,580
So that's a problem.
You want to not only

794
00:30:15,580 --> 00:30:18,520
write Dod like threading
code and locking code.

795
00:30:18,520 --> 00:30:21,660
You want to make sure it's
exception safe as well.

796
00:30:21,660 --> 00:30:23,519
And so one of the ways
we can do that with

797
00:30:23,519 --> 00:30:25,959
Python is with something
called a context manager.

798
00:30:25,959 --> 00:30:28,780
I'm just trying to kill this
notebook, if you don't mind.

799
00:30:28,780 --> 00:30:30,819
And I'll come down here
and I'm going to fix this.

800
00:30:30,819 --> 00:30:33,239
So instead of doing the
lock acquisition like this,

801
00:30:33,239 --> 00:30:35,729
I can say, with lock, right?

802
00:30:35,729 --> 00:30:36,889
And what this means is that

803
00:30:36,889 --> 00:30:38,689
the lock is a context manager,

804
00:30:38,689 --> 00:30:40,449
and I can have a
block of code here.

805
00:30:40,449 --> 00:30:42,589
And what will happen
down here is that it

806
00:30:42,589 --> 00:30:45,329
will automatically release it,

807
00:30:45,329 --> 00:30:48,049
even if there's an
exception, right?

808
00:30:48,049 --> 00:30:49,909
So this is the way you should
generally be doing locking

809
00:30:49,909 --> 00:30:51,990
unless you have a good
reason to do it another way.

810
00:30:51,990 --> 00:30:53,729
I don't even have
to do this anymore.

811
00:30:53,729 --> 00:30:55,329
Maybe I can just
print this here,

812
00:30:55,329 --> 00:30:58,249
I can say locked,

813
00:30:58,249 --> 00:31:00,629
and I can say locked dot locked,

814
00:31:00,629 --> 00:31:01,949
and I can take a peek at that.

815
00:31:01,949 --> 00:31:05,050
And then after this
block of code,

816
00:31:05,050 --> 00:31:06,450
I'm going to come
down here, and I'm

817
00:31:06,450 --> 00:31:08,189
going to say I locked down here.

818
00:31:08,189 --> 00:31:11,069
And let's just try calling
it a couple of times, right?

819
00:31:11,069 --> 00:31:13,720
I'm going to say
something like I'll

820
00:31:13,720 --> 00:31:15,300
do this transfer,
which was fine.

821
00:31:15,300 --> 00:31:18,049
I can see that inside, it's
locked outside, it's not.

822
00:31:18,049 --> 00:31:21,359
I am trying to try the
broken one again, right?

823
00:31:21,359 --> 00:31:23,420
I had an exception as before.

824
00:31:23,420 --> 00:31:26,119
And then let's try
one more grod one.

825
00:31:26,119 --> 00:31:27,840
I'll do like another x to y.

826
00:31:27,840 --> 00:31:29,980
And then it still
works just fine.

827
00:31:29,980 --> 00:31:31,579
Right? So we want to
use context managers.

828
00:31:31,579 --> 00:31:33,279
In general, when you're
doing systems programming,

829
00:31:33,279 --> 00:31:35,440
we care about resources.
What is a resource?

830
00:31:35,440 --> 00:31:36,840
It could be a lock. It could

831
00:31:36,840 --> 00:31:40,239
be an open file,
things like that.

832
00:31:40,239 --> 00:31:41,800
We want to use context managers

833
00:31:41,800 --> 00:31:43,739
when we can to free
those things up.

834
00:31:43,739 --> 00:31:45,539
You know, Maybe an equivalent
that more people have

835
00:31:45,539 --> 00:31:47,399
seen is you might have
a try accept finally.

836
00:31:47,399 --> 00:31:49,420
I think that to actually
looks pretty ugly, frankly.

837
00:31:49,420 --> 00:31:50,999
I don't try except finally.

838
00:31:50,999 --> 00:31:52,900
Context manager is a better way

839
00:31:52,900 --> 00:31:55,654
to do that in a very
pythonic way to do that.

840
00:31:55,654 --> 00:32:00,249
All right. Cool. Do people
have any questions about

841
00:32:00,249 --> 00:32:07,949
that example the width
statement? Right.

842
00:32:07,949 --> 00:32:14,050
Cool. So let me head over here.

843
00:32:14,050 --> 00:32:15,970
I want to go back
to this worksheet,

844
00:32:15,970 --> 00:32:18,189
where I do some more
examples on the worksheet.

845
00:32:18,189 --> 00:32:20,750
I'm to go to the do cam.

846
00:32:20,990 --> 00:32:24,230
And let's head to
the other side.

847
00:32:24,230 --> 00:32:29,569
All right. So here's a
little snippet of code.

848
00:32:29,569 --> 00:32:33,314
And I see that I'm using
both doin and locking.

849
00:32:33,314 --> 00:32:34,899
I just want to try to figure out

850
00:32:34,899 --> 00:32:36,679
what I can guarantee
about my variable.

851
00:32:36,679 --> 00:32:38,480
So the variable I'm really

852
00:32:38,480 --> 00:32:40,859
interested in is x.
X starts as one,

853
00:32:40,859 --> 00:32:44,539
and at some point x is
two. And I'm very careful.

854
00:32:44,539 --> 00:32:46,640
Whenever I look at x,

855
00:32:46,640 --> 00:32:49,399
I'm using a lock. I
say with lock here.

856
00:32:49,399 --> 00:32:51,779
Down here, I'm using
W lock as well.

857
00:32:51,779 --> 00:32:53,759
And then the question here is,

858
00:32:53,759 --> 00:32:55,339
what is A, B and C?

859
00:32:55,339 --> 00:32:56,859
And that's really asking what

860
00:32:56,859 --> 00:32:58,059
x is at different
points in time.

861
00:32:58,059 --> 00:33:00,219
I I say A equals x, B equals x,

862
00:33:00,219 --> 00:33:02,539
C equals x. I want to
see if we can reason

863
00:33:02,539 --> 00:33:06,159
through the values of x at
these three points in time.

864
00:33:06,159 --> 00:33:09,359
And sometimes maybe we know
exactly what it'll be.

865
00:33:09,359 --> 00:33:11,569
Other times, the depend, right?

866
00:33:11,569 --> 00:33:13,670
It might depend on the scheduler

867
00:33:13,670 --> 00:33:15,749
and when context
switches happen.

868
00:33:15,749 --> 00:33:18,230
Okay. And so we're going
to do all this together.

869
00:33:18,230 --> 00:33:20,389
And the way we'll do
it is, if I ask you,

870
00:33:20,389 --> 00:33:23,229
you'll say, either one
finger up, two fingers up,

871
00:33:23,229 --> 00:33:25,669
or if we can't know,
kind of, you know,

872
00:33:25,669 --> 00:33:27,269
struke your chin like, Hmm,

873
00:33:27,269 --> 00:33:28,929
I'm not sure about that if

874
00:33:28,929 --> 00:33:30,290
we don't have a good
way of knowing.

875
00:33:30,290 --> 00:33:32,590
Okay, so let's do A first.

876
00:33:32,590 --> 00:33:34,949
So at this point, A equals X,

877
00:33:34,949 --> 00:33:36,130
and at this point in time, I'm

878
00:33:36,130 --> 00:33:37,909
wondering, what is
the value of A?

879
00:33:37,909 --> 00:33:39,309
Is it one, two,

880
00:33:39,309 --> 00:33:41,989
or can't really know.

881
00:33:50,240 --> 00:33:52,899
I'm seeing some ones,
which is correct.

882
00:33:52,899 --> 00:33:56,040
Does anybody who has a one
up want to volunteer y?

883
00:33:56,040 --> 00:33:57,880
Yeah, right over here.

884
00:33:57,880 --> 00:34:01,679
You said to one before
any things happen.

885
00:34:01,679 --> 00:34:05,199
Yeah, I said to one before
retting actions happen.

886
00:34:05,199 --> 00:34:06,459
Yeah. And at this point, we

887
00:34:06,459 --> 00:34:07,859
haven't even started y, right?

888
00:34:07,859 --> 00:34:09,259
So threats are not
involved, right?

889
00:34:09,259 --> 00:34:11,180
We haven't started running
this other threat.

890
00:34:11,180 --> 00:34:13,459
So I agree that will
definitely be one.

891
00:34:13,459 --> 00:34:14,819
Let's skip around a bit.

892
00:34:14,819 --> 00:34:17,159
Let's do C. All right.

893
00:34:17,159 --> 00:34:19,019
I C going to be one, two,

894
00:34:19,019 --> 00:34:21,959
or can't really tell.

895
00:34:27,690 --> 00:34:30,069
People seem less
sure on this one.

896
00:34:30,069 --> 00:34:32,610
I see a few twos up,
which is Correct.

897
00:34:32,610 --> 00:34:34,869
Does anybody want to help
me reason through it?

898
00:34:34,869 --> 00:34:37,769
Why do I know that C
is going to be two?

899
00:34:39,050 --> 00:34:43,249
Yeah, go ahead. C
is changed x after

900
00:34:43,249 --> 00:34:48,789
join in changing x to two.

901
00:34:48,789 --> 00:34:51,309
Yeah, you're like changing
these along, right?

902
00:34:51,309 --> 00:34:52,589
This happens after the join,

903
00:34:52,589 --> 00:34:55,130
and the join happens after
the task finish is running.

904
00:34:55,130 --> 00:34:57,369
Therefore, x equals
two before C equals x.

905
00:34:57,369 --> 00:35:01,129
So I agree it is going
to be two there.

906
00:35:01,129 --> 00:35:03,469
Excellent. A, C. Let's do B now.

907
00:35:03,469 --> 00:35:07,729
Is it one, two, or We can't
really know for sure.

908
00:35:17,570 --> 00:35:20,589
People don't seem to be as
confident about this one.

909
00:35:20,589 --> 00:35:21,869
We can't really know for sure.

910
00:35:21,869 --> 00:35:23,329
We put a question
here. We don't know.

911
00:35:23,329 --> 00:35:25,369
Does anybody who
reason through that?

912
00:35:25,369 --> 00:35:26,590
Does anybody want to
share their thoughts?

913
00:35:26,590 --> 00:35:28,329
Yeah, right over here.

914
00:35:54,180 --> 00:35:55,880
Yeah. Excellent.

915
00:35:55,880 --> 00:35:57,800
Depending on when the
context switch happens,

916
00:35:57,800 --> 00:35:59,119
either one could hit the lock.

917
00:35:59,119 --> 00:36:01,539
Maybe the main thread
hits the lock first.

918
00:36:01,539 --> 00:36:05,099
In which case, it would be
one. Maybe the task thread

919
00:36:05,099 --> 00:36:06,339
hits the lock first and

920
00:36:06,339 --> 00:36:07,799
then it would be
two. We don't know.

921
00:36:07,799 --> 00:36:09,419
Yeah, question right
here. Can there be

922
00:36:09,419 --> 00:36:13,939
a context and the
first line of task?

923
00:36:15,460 --> 00:36:17,539
Can there be a context switch

924
00:36:17,539 --> 00:36:20,439
between start and
which one? Local x.

925
00:36:20,439 --> 00:36:23,559
Yeah, absolutely. When
I say t dot start,

926
00:36:23,559 --> 00:36:26,080
the scheduler really
has full freedom.

927
00:36:26,080 --> 00:36:27,499
When I say to start, maybe it

928
00:36:27,499 --> 00:36:29,980
runs that thread immediately,

929
00:36:29,980 --> 00:36:31,179
maybe it runs it
for a long time.

930
00:36:31,179 --> 00:36:32,619
Maybe when I say t dot start,

931
00:36:32,619 --> 00:36:33,739
it just puts a sign says,

932
00:36:33,739 --> 00:36:35,039
we'll run that later
and it might keep

933
00:36:35,039 --> 00:36:36,419
running the main thread.

934
00:36:36,419 --> 00:36:38,440
Now, when we actually
run the code,

935
00:36:38,440 --> 00:36:40,339
it'll probably do
one or the other.

936
00:36:40,339 --> 00:36:41,979
I'll probably either
often run the task

937
00:36:41,979 --> 00:36:44,019
first or tend to run main first,

938
00:36:44,019 --> 00:36:45,560
but we don't have any guarantee.

939
00:36:45,560 --> 00:36:48,060
Maybe in a week, there's
a minor version update,

940
00:36:48,060 --> 00:36:49,659
and might do something
different, right?

941
00:36:49,659 --> 00:36:50,919
That's why it's so
tricky, we have to

942
00:36:50,919 --> 00:36:53,219
reason through it rather
than just testing it.

943
00:36:53,219 --> 00:36:55,839
We have no guarantee if the
main thread will run first

944
00:36:55,839 --> 00:36:58,554
or the child task
will run first.

945
00:36:58,554 --> 00:37:00,049
Yeah, that's a good question.

946
00:37:00,049 --> 00:37:02,409
Other questions people
have about this.

947
00:37:03,650 --> 00:37:11,029
All right. Cool. So, let's

948
00:37:11,029 --> 00:37:14,400
learn about a new kind of
bug called a deadlock.

949
00:37:14,400 --> 00:37:17,509
And we've been talking

950
00:37:17,509 --> 00:37:19,190
about whether our locks

951
00:37:19,190 --> 00:37:21,330
are kind of like coarse
or fine and drained.

952
00:37:21,330 --> 00:37:22,789
When I've been using ample cab,

953
00:37:22,789 --> 00:37:23,909
what I'm really meaning, like,

954
00:37:23,909 --> 00:37:25,609
is it a lock covering a lot

955
00:37:25,609 --> 00:37:27,269
of code or a little
bit of a code?

956
00:37:27,269 --> 00:37:28,869
Another way that a lock could

957
00:37:28,869 --> 00:37:30,549
be either coarse or
fine and drain might be

958
00:37:30,549 --> 00:37:32,669
with respect to what

959
00:37:32,669 --> 00:37:34,649
data structures that
it's covering, right?

960
00:37:34,649 --> 00:37:35,469
Do I have kind of, like,

961
00:37:35,469 --> 00:37:36,909
one course grained
global lock that

962
00:37:36,909 --> 00:37:39,969
protects everything
or do I have,

963
00:37:39,969 --> 00:37:42,890
you know, different locks for
different pieces of data?

964
00:37:42,890 --> 00:37:45,589
And so this is a lot like
that banking example I have.

965
00:37:45,589 --> 00:37:48,189
And here I have bank
accounts A and B,

966
00:37:48,189 --> 00:37:50,529
but you know, you could
generalize, imagine it's more.

967
00:37:50,529 --> 00:37:51,949
And I'm imagining that I have

968
00:37:51,949 --> 00:37:54,390
a lock for each bank account.

969
00:37:54,390 --> 00:37:56,229
You know, in the
general use case,

970
00:37:56,229 --> 00:37:58,749
I probably have some
weird dictionary where

971
00:37:58,749 --> 00:38:01,530
I have a lock for every
entry in the dictionary.

972
00:38:01,530 --> 00:38:03,210
So I could really have a
lock for every bank account.

973
00:38:03,210 --> 00:38:05,809
That would be totally normal,
reasonable thing people do.

974
00:38:05,809 --> 00:38:07,829
And so what that means is that,

975
00:38:07,829 --> 00:38:09,710
since I now have a lock
for each bank account

976
00:38:09,710 --> 00:38:12,010
and I want to do the
transfer together.

977
00:38:12,010 --> 00:38:13,789
I want to pull from one account
and put it in the other,

978
00:38:13,789 --> 00:38:14,730
and I want that to appear

979
00:38:14,730 --> 00:38:16,129
as if it happened
at the same time.

980
00:38:16,129 --> 00:38:17,810
That means that I
actually have to acquire

981
00:38:17,810 --> 00:38:20,389
two locks before I can
do a transfer, right?

982
00:38:20,389 --> 00:38:21,789
So I have one transfer
that's drawing from

983
00:38:21,789 --> 00:38:23,749
A to B and one
that's from B to A.

984
00:38:23,749 --> 00:38:25,289
And so I'm just trying to

985
00:38:25,289 --> 00:38:26,749
kind of walk through
what might happen here.

986
00:38:26,749 --> 00:38:32,070
So imagine that thread one
does a lock A dot acquire.

987
00:38:32,380 --> 00:38:35,039
All right, so I may
acquire over here?

988
00:38:35,039 --> 00:38:36,899
Let's say we context switch now,

989
00:38:36,899 --> 00:38:38,819
and I may say, right,

990
00:38:38,819 --> 00:38:41,640
now when I say that we
do a lock B acquire.

991
00:38:41,640 --> 00:38:47,260
Ack Bt acquire.

992
00:38:47,500 --> 00:38:51,280
And hopefully everybody can
help with some nodding.

993
00:38:51,280 --> 00:38:55,199
Can Thread two acquire
Lock A right now?

994
00:38:55,199 --> 00:38:58,839
No. The one role we have is
that for any given lock,

995
00:38:58,839 --> 00:39:01,539
it can be held by at most
one thread at a time.

996
00:39:01,539 --> 00:39:03,019
Lock A is already held.

997
00:39:03,019 --> 00:39:04,879
We cannot acquire Lock A.

998
00:39:04,879 --> 00:39:07,200
Okay. So this thread
will be blocked,

999
00:39:07,200 --> 00:39:09,439
and it will context
switch over here.

1000
00:39:09,439 --> 00:39:13,899
Can Thread one acquire lock B?

1001
00:39:14,290 --> 00:39:15,829
No.

1002
00:39:15,829 --> 00:39:18,489
It's already held. Can't
be held by more than once.

1003
00:39:18,489 --> 00:39:20,209
So what will happen
is that we're just

1004
00:39:20,209 --> 00:39:22,110
going to be blocked forever.

1005
00:39:22,110 --> 00:39:24,450
I'm going to write that
down. We're blocked forever.

1006
00:39:24,450 --> 00:39:28,549
We're just stuck. Okay? And so

1007
00:39:28,549 --> 00:39:30,350
you have to think about
when you're doing locking.

1008
00:39:30,350 --> 00:39:31,749
I mean, you can decide,
like, maybe I just

1009
00:39:31,749 --> 00:39:33,310
want to have like a
single threaded process.

1010
00:39:33,310 --> 00:39:35,350
I don't have to worry
about any of this stuff.

1011
00:39:35,350 --> 00:39:38,169
Maybe I have multiple threads
in a single global lock,

1012
00:39:38,169 --> 00:39:38,949
then I have to worry about

1013
00:39:38,949 --> 00:39:40,945
race conditions but
not deadlocked.

1014
00:39:40,945 --> 00:39:42,819
Maybe I want to get
really fancy and I

1015
00:39:42,819 --> 00:39:44,539
want to have a lot of fine
grain locking like that.

1016
00:39:44,539 --> 00:39:46,459
Now you have to worry
about deadlock, too.

1017
00:39:46,459 --> 00:39:48,979
You can kind of choose make
these decisions about.

1018
00:39:48,979 --> 00:39:50,280
If I want to get
better performance,

1019
00:39:50,280 --> 00:39:51,439
I might have more complexity,

1020
00:39:51,439 --> 00:39:54,139
but then I have to worry
about more times of bugs may

1021
00:39:54,139 --> 00:39:57,200
or may not be worth it,
given your situation.

1022
00:39:57,200 --> 00:39:58,899
And what do people
do here, right?

1023
00:39:58,899 --> 00:40:00,919
The way you solve
this? It's really

1024
00:40:00,919 --> 00:40:03,879
a circular dependency
like A b4b, B B four A.

1025
00:40:03,879 --> 00:40:06,119
To really break this,
we have to agree that

1026
00:40:06,119 --> 00:40:08,579
we always acquire locks
in the same order.

1027
00:40:08,579 --> 00:40:09,799
If you do that,
it's okay to have

1028
00:40:09,799 --> 00:40:11,860
multiple locks and we
won't have deadlock.

1029
00:40:11,860 --> 00:40:13,400
And so a very common comment

1030
00:40:13,400 --> 00:40:14,619
you'll see and that
you should have in

1031
00:40:14,619 --> 00:40:18,360
code like this is we could
say, like, lock order.

1032
00:40:19,070 --> 00:40:25,969
And we might say something
like Lock A before Lock B.

1033
00:40:25,969 --> 00:40:28,529
And we have to make sure any
piece of code follows that,

1034
00:40:28,529 --> 00:40:30,390
otherwise, you could
get a deadlock.

1035
00:40:30,390 --> 00:40:31,850
And of course that could
be much more complicated.

1036
00:40:31,850 --> 00:40:33,809
I've read some phone in the
Linux kernel, for example,

1037
00:40:33,809 --> 00:40:35,169
where they maybe have like

1038
00:40:35,169 --> 00:40:36,769
eight or ten different
kinds of locks,

1039
00:40:36,769 --> 00:40:38,589
and they have a whole
read me about it.

1040
00:40:38,589 --> 00:40:40,469
And a lot of the read me
what it's saying is like,

1041
00:40:40,469 --> 00:40:41,989
this is the order you're
going to acquire locks,

1042
00:40:41,989 --> 00:40:43,409
and you have to
acquire these ones

1043
00:40:43,409 --> 00:40:45,089
to make such and
such updates, right?

1044
00:40:45,089 --> 00:40:47,030
It can really get
quite complicated,

1045
00:40:47,030 --> 00:40:48,309
right? And that's
not always worth it.

1046
00:40:48,309 --> 00:40:49,609
But if you are going
that route, make

1047
00:40:49,609 --> 00:40:51,129
sure you document well how

1048
00:40:51,129 --> 00:40:54,469
people should actually use
the locking. All right.

1049
00:40:54,469 --> 00:40:56,750
Any questions people
have about that example

1050
00:40:56,750 --> 00:40:59,190
or about deadlocking in general?

1051
00:41:00,270 --> 00:41:03,389
Yeah, question right over here.

1052
00:41:07,990 --> 00:41:10,470
Yeah, that's a really
interesting question.

1053
00:41:10,470 --> 00:41:13,910
So, how would I know
that I had a deadlock?

1054
00:41:13,910 --> 00:41:15,249
Well, first off, like, we'll see

1055
00:41:15,249 --> 00:41:17,029
it just like everything
kind of hung up.

1056
00:41:17,029 --> 00:41:19,470
How do I know it
specifically a deadlock?

1057
00:41:19,470 --> 00:41:21,289
Well, one of the
things you could do is

1058
00:41:21,289 --> 00:41:23,149
if you had a debugger,
you could attach to it,

1059
00:41:23,149 --> 00:41:25,170
and you could see for
each of your threads,

1060
00:41:25,170 --> 00:41:27,689
You could do a
back trace, right?

1061
00:41:27,689 --> 00:41:29,570
Back race looks a lot
like an exception.

1062
00:41:29,570 --> 00:41:31,650
When I have an exception thrown,
I get some line numbers,

1063
00:41:31,650 --> 00:41:33,229
I could do a back
trace for each thread,

1064
00:41:33,229 --> 00:41:34,810
and I could see, uh,

1065
00:41:34,810 --> 00:41:36,690
program's not making progress.

1066
00:41:36,690 --> 00:41:39,629
All my threads are waiting
to acquire a lock,

1067
00:41:39,629 --> 00:41:40,729
and I could look at the code,

1068
00:41:40,729 --> 00:41:42,329
and I could try
to figure it out.

1069
00:41:42,329 --> 00:41:43,649
Or you could do prints, right?

1070
00:41:43,649 --> 00:41:44,809
Sometimes I'll do a print

1071
00:41:44,809 --> 00:41:47,129
like before and after
I acquire a lock,

1072
00:41:47,129 --> 00:41:48,589
and I could t do just like

1073
00:41:48,589 --> 00:41:50,850
simple print debugging
to see it happens.

1074
00:41:50,850 --> 00:41:52,429
But the first symptom
that will make you

1075
00:41:52,429 --> 00:41:54,469
investigate is that
it just hangs up.

1076
00:41:54,469 --> 00:41:56,679
Nobody's making progress, right?

1077
00:41:56,679 --> 00:41:58,670
And honestly, like,
of these two bugs,

1078
00:41:58,670 --> 00:42:00,070
I would much rather
have a deadlock

1079
00:42:00,070 --> 00:42:02,110
because it's like
everything's kind of frozen.

1080
00:42:02,110 --> 00:42:03,729
I can take my time.
I can look at it.

1081
00:42:03,729 --> 00:42:05,189
The race condition
is much harder

1082
00:42:05,189 --> 00:42:07,209
debug it kind of
maybe happens once,

1083
00:42:07,209 --> 00:42:08,789
and then if I fix it,

1084
00:42:08,789 --> 00:42:10,029
do I really know
that I fixed it,

1085
00:42:10,029 --> 00:42:11,730
or maybe it's just
that the timing

1086
00:42:11,730 --> 00:42:13,529
worked out a little bit
differently, right?

1087
00:42:13,529 --> 00:42:15,749
Yeah excellent question though,
how do we diagnose this?

1088
00:42:15,749 --> 00:42:16,669
Yeah, other questions about

1089
00:42:16,669 --> 00:42:19,529
this example are
about deadlocks.

1090
00:42:21,080 --> 00:42:23,220
Right. Cool.

1091
00:42:23,220 --> 00:42:25,920
So, in my experience,

1092
00:42:25,920 --> 00:42:27,719
I teach people about
threading and locks.

1093
00:42:27,719 --> 00:42:29,619
They get excited about
it, and they try to be.

1094
00:42:29,619 --> 00:42:31,139
It feels like a puzzle,
right? So it kind of

1095
00:42:31,139 --> 00:42:33,120
makes you want to start
being very clever.

1096
00:42:33,120 --> 00:42:35,519
And I'm going to show you
about some other weird things,

1097
00:42:35,519 --> 00:42:37,319
more advanced topics with

1098
00:42:37,319 --> 00:42:39,379
the goal of convincing
you don't be clever,

1099
00:42:39,379 --> 00:42:41,260
do simple things when
you're doing locking.

1100
00:42:41,260 --> 00:42:42,979
Otherwise, you're
gonna end up in kind

1101
00:42:42,979 --> 00:42:44,679
of like a world of
trouble, right?

1102
00:42:44,679 --> 00:42:46,880
So let's look at a couple
of advanced topics.

1103
00:42:46,880 --> 00:42:48,719
Maybe actually I might just

1104
00:42:48,719 --> 00:42:50,259
get to the global
interpreter lock today,

1105
00:42:50,259 --> 00:42:52,000
and I'll talk about instruction

1106
00:42:52,000 --> 00:42:53,339
reordering and
caching next time.

1107
00:42:53,339 --> 00:42:54,999
Oh, you cannot see my

1108
00:42:54,999 --> 00:42:57,099
strange. Alright,
let's bring this up.

1109
00:42:57,099 --> 00:42:59,060
So let's talk about some
of these advanced topics,

1110
00:42:59,060 --> 00:43:01,239
like the global
Interpreter lock.

1111
00:43:01,239 --> 00:43:06,380
So here I have a picture
of a bunch of CPU cores,

1112
00:43:06,380 --> 00:43:09,999
and then I have a virtual
address space here.

1113
00:43:09,999 --> 00:43:11,359
This is one virtual addre space.

1114
00:43:11,359 --> 00:43:13,599
I have my Python toward as
the virtual adder space.

1115
00:43:13,599 --> 00:43:15,979
Maybe I have maybe I'm
using like Num Pi, right?

1116
00:43:15,979 --> 00:43:17,519
That's a library
mostly written in C,

1117
00:43:17,519 --> 00:43:19,159
maybe I have that in my
virtual adder space.

1118
00:43:19,159 --> 00:43:20,400
And I have a bunch of threads,

1119
00:43:20,400 --> 00:43:23,499
and we can see that some
of them are running,

1120
00:43:23,499 --> 00:43:25,519
right they're attached
to a CPU core.

1121
00:43:25,519 --> 00:43:27,320
This one over here,
it's blocked.

1122
00:43:27,320 --> 00:43:29,259
It's waiting for a file, right?

1123
00:43:29,259 --> 00:43:31,360
And I see another one here,
which is very interesting.

1124
00:43:31,360 --> 00:43:32,900
It's waiting for
something called the GIL.

1125
00:43:32,900 --> 00:43:35,639
That stands for the
global interpreter lock.

1126
00:43:35,639 --> 00:43:37,279
And it turns out that Python for

1127
00:43:37,279 --> 00:43:40,479
a long time has had
this centralized lock.

1128
00:43:40,479 --> 00:43:42,459
And any thread that's
currently running

1129
00:43:42,459 --> 00:43:44,479
on the CPU has to hold that.

1130
00:43:44,479 --> 00:43:48,479
And what that effectively
means is that we

1131
00:43:48,479 --> 00:43:50,459
cannot be having
multiple Python threads

1132
00:43:50,459 --> 00:43:52,959
actually using multiple CPU
cores at the same time,

1133
00:43:52,959 --> 00:43:54,259
even though that's
one of the big

1134
00:43:54,259 --> 00:43:55,860
motivations for using threads.

1135
00:43:55,860 --> 00:43:57,299
Are threads still useful in

1136
00:43:57,299 --> 00:43:59,619
Python as of today?
Maybe, right?

1137
00:43:59,619 --> 00:44:01,319
Because I have this
thread over here

1138
00:44:01,319 --> 00:44:03,159
that's waiting for a file.
That's still useful.

1139
00:44:03,159 --> 00:44:05,400
I can have a few threads
that are blocked on IO,

1140
00:44:05,400 --> 00:44:07,824
and then maybe one
that's actually running.

1141
00:44:07,824 --> 00:44:10,730
You can also see that somehow,

1142
00:44:10,730 --> 00:44:12,829
even though I have this
global interpreter lock,

1143
00:44:12,829 --> 00:44:15,609
I have multiple threads that are

1144
00:44:15,609 --> 00:44:18,849
actually running on the CPU
cores at the same time.

1145
00:44:18,849 --> 00:44:20,969
How did that happen?
Well, if I'm

1146
00:44:20,969 --> 00:44:25,169
programming a Python package
in a language like C,

1147
00:44:25,169 --> 00:44:26,909
I can do some advanced
things and say,

1148
00:44:26,909 --> 00:44:28,290
I'm willing to release

1149
00:44:28,290 --> 00:44:30,910
the global interpreter
lock in certain cases.

1150
00:44:30,910 --> 00:44:32,529
So the way people have
often gone around this,

1151
00:44:32,529 --> 00:44:34,609
they'll use num Pi
or Pi torch or Pi

1152
00:44:34,609 --> 00:44:36,189
arrow or any of these
different things

1153
00:44:36,189 --> 00:44:37,650
that can solve this issue,

1154
00:44:37,650 --> 00:44:40,329
and just like the
straightforward Python trow,

1155
00:44:40,329 --> 00:44:42,089
they won't be running
things concurrently,

1156
00:44:42,089 --> 00:44:46,084
but in these C libraries,
they will, okay?

1157
00:44:46,084 --> 00:44:47,799
That's something to
be aware of. Let me

1158
00:44:47,799 --> 00:44:49,039
just show you how
this might work.

1159
00:44:49,039 --> 00:44:50,539
At this point, this
one was waiting for

1160
00:44:50,539 --> 00:44:52,620
the global interpreter
lock, so it's blocked.

1161
00:44:52,620 --> 00:44:54,539
That first Python
thread is done.

1162
00:44:54,539 --> 00:44:56,100
So now both of those
are vulnerable.

1163
00:44:56,100 --> 00:44:57,719
Then when it starts
running that other one,

1164
00:44:57,719 --> 00:44:58,739
the first one will be waiting on

1165
00:44:58,739 --> 00:45:01,129
the global interpreter lock.

1166
00:45:01,129 --> 00:45:04,119
All right. This one was
waiting on file IO.

1167
00:45:04,119 --> 00:45:06,879
When it's done, it can't
immediately run would then

1168
00:45:06,879 --> 00:45:10,039
need to wait on the global
interpreter law. All right?

1169
00:45:10,039 --> 00:45:12,099
And then they might be applied
to other things as well.

1170
00:45:12,099 --> 00:45:14,359
I'm trying to make that
example longer than I need to.

1171
00:45:14,359 --> 00:45:16,219
So why do they have
this awful thing that

1172
00:45:16,219 --> 00:45:18,699
is limiting parallel execution?

1173
00:45:18,699 --> 00:45:19,939
Well, it's related to another

1174
00:45:19,939 --> 00:45:21,080
thing called garbage collection.

1175
00:45:21,080 --> 00:45:22,539
Let me just give
you a quick idea

1176
00:45:22,539 --> 00:45:24,059
of how garbage collection works.

1177
00:45:24,059 --> 00:45:26,380
Here I have two threads.

1178
00:45:27,060 --> 00:45:29,919
In the first case, I
guess x equals some list,

1179
00:45:29,919 --> 00:45:31,499
and they say x equals none.

1180
00:45:31,499 --> 00:45:33,819
And then thread two, I say
y equals that same list,

1181
00:45:33,819 --> 00:45:35,299
and then y equals none.

1182
00:45:35,299 --> 00:45:36,879
And what does that look like?

1183
00:45:36,879 --> 00:45:40,370
Well, I have I have
two local variables,

1184
00:45:40,370 --> 00:45:43,110
each this x and y and those
are for different threads,

1185
00:45:43,110 --> 00:45:44,369
and they each have
their own stack,

1186
00:45:44,369 --> 00:45:46,010
and those variables
are referencing

1187
00:45:46,010 --> 00:45:47,909
a common data
structure on the heat.

1188
00:45:47,909 --> 00:45:49,270
Python is actually keeping

1189
00:45:49,270 --> 00:45:50,749
track of how many
references there

1190
00:45:50,749 --> 00:45:53,849
are to that data structure
object. Why does it do that?

1191
00:45:53,849 --> 00:45:57,569
Well, when I say
run y equals none,

1192
00:45:57,569 --> 00:45:59,309
I want to decrease it,

1193
00:45:59,309 --> 00:46:01,409
and when I say x
equals none later,

1194
00:46:01,409 --> 00:46:03,190
then I could realize
there's no more references

1195
00:46:03,190 --> 00:46:05,109
and I could actually
clean it up.

1196
00:46:05,109 --> 00:46:07,489
The main implementation
of Python does

1197
00:46:07,489 --> 00:46:08,889
this reference counting so it

1198
00:46:08,889 --> 00:46:10,489
knows when it can
free up that list.

1199
00:46:10,489 --> 00:46:11,509
Otherwise I might just keep

1200
00:46:11,509 --> 00:46:12,929
using more and more
memory over time,

1201
00:46:12,929 --> 00:46:15,469
and we wouldn't want to do that.

1202
00:46:15,469 --> 00:46:17,949
And so Python is doing
this all the time,

1203
00:46:17,949 --> 00:46:19,650
is keeping track of
these reference counts

1204
00:46:19,650 --> 00:46:21,890
internally on all your
different data structures.

1205
00:46:21,890 --> 00:46:24,830
And and that should

1206
00:46:24,830 --> 00:46:26,890
try to remind you of this
example we saw earlier,

1207
00:46:26,890 --> 00:46:28,889
where we had two
threads that were both

1208
00:46:28,889 --> 00:46:31,209
counting to 10 million
is what happened there.

1209
00:46:31,209 --> 00:46:32,989
When I had two things
that were plus

1210
00:46:32,989 --> 00:46:34,389
equal one minus equal one,

1211
00:46:34,389 --> 00:46:36,349
that could get interrupted
at a bad time.

1212
00:46:36,349 --> 00:46:39,909
Same thing can happen here
with these integers here.

1213
00:46:39,909 --> 00:46:42,049
I have to be very careful
how I make sure that

1214
00:46:42,049 --> 00:46:44,330
I'm safely accessing
these reference counts.

1215
00:46:44,330 --> 00:46:46,949
And so the Python approach
has been for a long time.

1216
00:46:46,949 --> 00:46:48,849
Well we just have one
thread running at a time.

1217
00:46:48,849 --> 00:46:50,130
We don't have to have locking

1218
00:46:50,130 --> 00:46:51,609
around those reference counts.

1219
00:46:51,609 --> 00:46:54,110
Another approach is that you
could have lots of locking,

1220
00:46:54,110 --> 00:46:56,330
and that could let us
have multiple threads,

1221
00:46:56,330 --> 00:46:59,150
but then maybe constantly
acquiring and releasing locks,

1222
00:46:59,150 --> 00:47:00,569
that might slow
things down a lot.

1223
00:47:00,569 --> 00:47:03,109
And so the decision
so far has been,

1224
00:47:03,109 --> 00:47:05,650
let's optimize for single
threaded performance

1225
00:47:05,650 --> 00:47:06,949
because it's a
fundamental trade off.

1226
00:47:06,949 --> 00:47:09,309
If we make multiple threads
run at the same time,

1227
00:47:09,309 --> 00:47:10,970
and we have garbage collection,

1228
00:47:10,970 --> 00:47:13,189
then single threaded
performances worse,

1229
00:47:13,189 --> 00:47:14,929
and that wasn't a trade off
they were willing to make.

1230
00:47:14,929 --> 00:47:16,799
Now, We're like seeing

1231
00:47:16,799 --> 00:47:19,439
history happen happening
in the making, right?

1232
00:47:19,439 --> 00:47:20,700
So this is actually Python

1233
00:47:20,700 --> 00:47:23,780
3.13 is being released tomorrow.

1234
00:47:23,780 --> 00:47:26,080
And they're adding an
experimental feature

1235
00:47:26,080 --> 00:47:28,379
where you can run without
the global interpreter lock.

1236
00:47:28,379 --> 00:47:30,139
You know, it's experimental.

1237
00:47:30,139 --> 00:47:31,760
You actually have to download

1238
00:47:31,760 --> 00:47:34,099
a different version of the
interpreter to have it.

1239
00:47:34,099 --> 00:47:35,719
And they say if you do
that, you should expect

1240
00:47:35,719 --> 00:47:37,979
a substantial single
threaded performance hit.

1241
00:47:37,979 --> 00:47:42,119
So what does the history,
how this all play out?

1242
00:47:42,119 --> 00:47:43,539
We may likely have

1243
00:47:43,539 --> 00:47:45,959
Python interpreters without
the global Interpreter lock,

1244
00:47:45,959 --> 00:47:47,779
or maybe you're going to
have to have a PEC, right?

1245
00:47:47,779 --> 00:47:49,299
So something you
have to be aware of,

1246
00:47:49,299 --> 00:47:51,339
and it'll probably be
something we have to be aware

1247
00:47:51,339 --> 00:47:54,480
of for a long time. Alright.

1248
00:47:54,480 --> 00:47:55,979
I think I'm going a
break there because I

1249
00:47:55,979 --> 00:47:57,439
don't want to get
into this next topic.

1250
00:47:57,439 --> 00:47:59,099
I do have 330 meeting,

1251
00:47:59,099 --> 00:48:01,039
so I normally stay
in chat with folks,

1252
00:48:01,039 --> 00:48:02,279
but I got to book
it out of here.

1253
00:48:02,279 --> 00:48:04,159
So, feel free to drop
an e mail or something,

1254
00:48:04,159 --> 00:48:05,259
or we can catch up on

1255
00:48:05,259 --> 00:48:08,180
Wednesday too. Have
a great evening.
