1
00:00:00,000 --> 00:00:01,400
Semester where we're learning

2
00:00:01,400 --> 00:00:03,020
about different
kinds of resources.

3
00:00:03,020 --> 00:00:04,500
I have a little bit
to wrap up from

4
00:00:04,500 --> 00:00:06,920
last time when we were
looking at Locks.

5
00:00:06,920 --> 00:00:08,499
And then we're will
be moving into

6
00:00:08,499 --> 00:00:12,220
our fourth and final
resource, which is storage.

7
00:00:12,220 --> 00:00:13,739
And after that pretty soon

8
00:00:13,739 --> 00:00:15,419
we'll be into a lot of
interesting things.

9
00:00:15,419 --> 00:00:16,199
We're starting looking at

10
00:00:16,199 --> 00:00:17,739
different distributed
systems that

11
00:00:17,739 --> 00:00:21,020
can actually hold
quite a bit of data.

12
00:00:21,020 --> 00:00:23,000
So let me actually
head back here.

13
00:00:23,000 --> 00:00:25,080
Actually, before I do
that, let me just remind

14
00:00:25,080 --> 00:00:27,540
you that we have a bid term
in one week. I try to check.

15
00:00:27,540 --> 00:00:29,119
Does everybody have any
logistical questions about

16
00:00:29,119 --> 00:00:33,529
the upcoming mid term?
Yeah, right over here.

17
00:00:33,529 --> 00:00:35,609
So this Friday.

18
00:00:35,609 --> 00:00:38,609
It will be anything before this.

19
00:00:38,609 --> 00:00:40,589
Monday is fair game as well,

20
00:00:40,589 --> 00:00:42,669
and I know that's not a lot of

21
00:00:42,669 --> 00:00:45,010
turnaround time to perhaps.

22
00:00:45,010 --> 00:00:46,509
I'll probably keep the
questions about that

23
00:00:46,509 --> 00:00:48,590
Monday maybe a little
simpler than the rest.

24
00:00:48,590 --> 00:00:50,529
I've tried having
another cutoff,

25
00:00:50,529 --> 00:00:51,649
and then people just like,

26
00:00:51,649 --> 00:00:53,049
don't come to that
lecture there like,

27
00:00:53,049 --> 00:00:55,769
why should study for the mid
term instead. So it's there.

28
00:00:55,769 --> 00:00:58,010
You'll maybe do better on
the mid term if you show

29
00:00:58,010 --> 00:01:00,270
up for that October 7 lecture.

30
00:01:00,270 --> 00:01:03,109
Yeah, other questions people
have about the mid term.

31
00:01:03,610 --> 00:01:06,210
Fantastic. You'll
be like here in

32
00:01:06,210 --> 00:01:08,489
class, show up as usual.

33
00:01:08,489 --> 00:01:10,730
Cool. So I am going to

34
00:01:10,730 --> 00:01:12,489
head back and look at some of

35
00:01:12,489 --> 00:01:14,760
the things that we were
wrapping up last time.

36
00:01:14,760 --> 00:01:17,789
So we learned about
blocks in general.

37
00:01:17,789 --> 00:01:19,370
And I want to talk
about a couple of

38
00:01:19,370 --> 00:01:21,869
advanced topics that people
should keep in mind.

39
00:01:21,869 --> 00:01:23,470
And part of my goal here is that

40
00:01:23,470 --> 00:01:26,310
sometimes people will have
maybe, like a clever idea,

41
00:01:26,310 --> 00:01:30,010
and that it might
backfire on them because,

42
00:01:30,010 --> 00:01:31,969
you know, there's some
of these advanced topics

43
00:01:31,969 --> 00:01:34,230
that make you have to use
locks in a certain way.

44
00:01:34,230 --> 00:01:36,869
And if you less you understand
them at a very deep level,

45
00:01:36,869 --> 00:01:37,990
right, you cannot kind of have

46
00:01:37,990 --> 00:01:39,330
some sort of clever
pattern, right?

47
00:01:39,330 --> 00:01:41,310
You have to use locks in
a very conventional way.

48
00:01:41,310 --> 00:01:43,050
So I just want to show a
couple of those things.

49
00:01:43,050 --> 00:01:45,930
The first is about this
infamous lock called

50
00:01:45,930 --> 00:01:49,250
the global interpreter
lock that is a Python.

51
00:01:49,250 --> 00:01:50,490
First of may just show what the

52
00:01:50,490 --> 00:01:52,030
global interpreter
Lock does to us,

53
00:01:52,030 --> 00:01:54,129
and then I'll talk
about why it's there,

54
00:01:54,129 --> 00:01:56,570
maybe the future of the lock.

55
00:01:56,570 --> 00:02:01,380
But Here I have a machine
with six different CPU cores.

56
00:02:01,380 --> 00:02:03,300
And at any given time,

57
00:02:03,300 --> 00:02:06,020
one of these CPU cores
can be running a thread.

58
00:02:06,020 --> 00:02:07,699
Here I just have
a single process.

59
00:02:07,699 --> 00:02:09,219
So I see right now there's four

60
00:02:09,219 --> 00:02:11,080
different threads
that are running.

61
00:02:11,080 --> 00:02:12,799
One of these threads in

62
00:02:12,799 --> 00:02:14,099
the Python code is

63
00:02:14,099 --> 00:02:16,239
waiting for a file,
right? So it's blocked.

64
00:02:16,239 --> 00:02:18,620
And I have another one here
that is actually blocked

65
00:02:18,620 --> 00:02:21,340
on this thing called the
Global Interpreter Lock.

66
00:02:21,340 --> 00:02:24,439
So the rule with the
global interpreter lock is

67
00:02:24,439 --> 00:02:28,440
that only whenever any thread
is running Python code,

68
00:02:28,440 --> 00:02:30,490
it has to hold that lock,

69
00:02:30,490 --> 00:02:32,589
and that prevents other threads

70
00:02:32,589 --> 00:02:34,649
from running Python
rode at the same time.

71
00:02:34,649 --> 00:02:36,629
Right? So when I have
this thread here,

72
00:02:36,629 --> 00:02:38,310
I cannot be running

73
00:02:38,310 --> 00:02:40,669
this other thread that's in
Python rode at the same time.

74
00:02:40,669 --> 00:02:42,469
Maybe somebody wrote
some library and

75
00:02:42,469 --> 00:02:43,169
C or something that

76
00:02:43,169 --> 00:02:44,609
doesn't use a global
interpreter lock,

77
00:02:44,609 --> 00:02:46,070
and they can be running
a bunch of things.

78
00:02:46,070 --> 00:02:48,049
That's one of the
reasons why people get

79
00:02:48,049 --> 00:02:49,549
good performance where
you use something like

80
00:02:49,549 --> 00:02:51,229
um Pi or somebod
else built in C,

81
00:02:51,229 --> 00:02:53,470
instead of using
pure Python Trode.

82
00:02:53,470 --> 00:02:56,389
But I can only run one
of these at a time.

83
00:02:56,389 --> 00:02:59,269
That does mean that locks or

84
00:02:59,269 --> 00:03:00,549
threads are less useful in

85
00:03:00,549 --> 00:03:01,949
Python than other
languages, right?

86
00:03:01,949 --> 00:03:04,090
In most languages, you
have a bunch of threads,

87
00:03:04,090 --> 00:03:06,389
and they can all use CPU
cores at the same time,

88
00:03:06,389 --> 00:03:08,729
and that helps you
utilize the CPU.

89
00:03:08,729 --> 00:03:12,170
In this case, the main benefit
I'm getting from threads

90
00:03:12,170 --> 00:03:13,949
running Pre Python rod is that I

91
00:03:13,949 --> 00:03:15,870
could have one thread
that's blocked on IO,

92
00:03:15,870 --> 00:03:18,249
while another one is
using CPU, right?

93
00:03:18,249 --> 00:03:19,969
So if I just have
Pre Python road,

94
00:03:19,969 --> 00:03:21,390
none of these extra libraries,

95
00:03:21,390 --> 00:03:23,990
it's very you can't really

96
00:03:23,990 --> 00:03:28,054
be using more than one
CPU core at a time.

97
00:03:28,054 --> 00:03:30,680
Alright, let's just run
through this a little bit.

98
00:03:30,680 --> 00:03:34,239
So it's running for a while.
When I stop running that w,

99
00:03:34,239 --> 00:03:37,140
then both of these
become runable.

100
00:03:37,140 --> 00:03:39,519
And maybe it starts
running this one,

101
00:03:39,519 --> 00:03:41,059
W it starts running
this one, that thread

102
00:03:41,059 --> 00:03:42,919
would acquire the global
interpreter lock.

103
00:03:42,919 --> 00:03:45,299
And the first thread
would be blocked, right?

104
00:03:45,299 --> 00:03:46,200
We can't run it right now

105
00:03:46,200 --> 00:03:47,359
because it has to
wait until it has

106
00:03:47,359 --> 00:03:49,919
a chart to have that
lock and run a good.

107
00:03:49,919 --> 00:03:52,459
Maybe the IO finished
over here on this one.

108
00:03:52,459 --> 00:03:56,119
So this thread that was waiting
for IO, stud with that.

109
00:03:56,119 --> 00:03:57,359
Now we'll have to wait for

110
00:03:57,359 --> 00:03:59,749
the global interpreter
lock as well.

111
00:03:59,749 --> 00:04:01,759
Maybe when this one blocks,

112
00:04:01,759 --> 00:04:04,719
because maybe it's doing
some sort of network I owe,

113
00:04:04,719 --> 00:04:06,159
then we could start

114
00:04:06,159 --> 00:04:07,879
actually running that
one again, right?

115
00:04:07,879 --> 00:04:09,320
So we can see that that global

116
00:04:09,320 --> 00:04:10,919
interpreter lock is
preventing us from

117
00:04:10,919 --> 00:04:14,919
running as many threads as we
might be able to otherwise.

118
00:04:14,919 --> 00:04:18,139
So why do they have this?
There's different reasons.

119
00:04:18,139 --> 00:04:21,750
Probably the most supported
reason is that we have to do

120
00:04:21,750 --> 00:04:23,969
some bookkeeping to figure

121
00:04:23,969 --> 00:04:26,189
out what a piece of data
is no longer needed.

122
00:04:26,189 --> 00:04:28,110
That bookkeeping is called
garbage collection, right?

123
00:04:28,110 --> 00:04:29,970
So garbage collection,
we'll see, like, Oh,

124
00:04:29,970 --> 00:04:31,589
maybe I have this
list that nobody's

125
00:04:31,589 --> 00:04:33,409
using anymore in this program,

126
00:04:33,409 --> 00:04:34,730
maybe I can free it up.

127
00:04:34,730 --> 00:04:36,229
And let me just
show you an example

128
00:04:36,229 --> 00:04:37,710
where I have two threads,

129
00:04:37,710 --> 00:04:39,129
and they each have a
piece of code, right?

130
00:04:39,129 --> 00:04:42,670
So I say x equals some
list that x equals no.

131
00:04:42,670 --> 00:04:45,410
Y equals actually the same list

132
00:04:45,410 --> 00:04:47,090
that the first thread
is looking at,

133
00:04:47,090 --> 00:04:48,930
and then y equals ud.

134
00:04:48,930 --> 00:04:50,790
And so at different
points in time,

135
00:04:50,790 --> 00:04:52,189
kind of depending
on inner leavings,

136
00:04:52,189 --> 00:04:54,010
I might have two variables
referring to that list

137
00:04:54,010 --> 00:04:56,309
or one variable or no variables.

138
00:04:56,309 --> 00:04:58,390
And of course, when
there's no variables

139
00:04:58,390 --> 00:05:00,470
referring to some
data structure,

140
00:05:00,470 --> 00:05:01,830
there's no other way

141
00:05:01,830 --> 00:05:03,389
to get access to
that data structure.

142
00:05:03,389 --> 00:05:04,610
We call it garbage, right?

143
00:05:04,610 --> 00:05:06,270
That's memory that is not

144
00:05:06,270 --> 00:05:08,380
helping our program in any
way, we could free it up.

145
00:05:08,380 --> 00:05:10,129
So this point in
time, let's imagine

146
00:05:10,129 --> 00:05:11,710
that I have both x and y set,

147
00:05:11,710 --> 00:05:13,410
and I haven't set
either to ud yet.

148
00:05:13,410 --> 00:05:15,789
So this case, I have the
both point to that list.

149
00:05:15,789 --> 00:05:17,229
Python is ready to do some extra

150
00:05:17,229 --> 00:05:19,270
bookkeeping to keep track of

151
00:05:19,270 --> 00:05:20,730
how many references are

152
00:05:20,730 --> 00:05:23,550
referring to that list
object on the heap.

153
00:05:23,550 --> 00:05:26,289
And so as this runs
as y equals ud,

154
00:05:26,289 --> 00:05:29,055
then that reference
cut would go to wood.

155
00:05:29,055 --> 00:05:31,060
And then if it eventually goes

156
00:05:31,060 --> 00:05:32,740
to zero, we would free it up.

157
00:05:32,740 --> 00:05:35,160
Okay? So reference
counting is the only way

158
00:05:35,160 --> 00:05:37,679
they do garbage
collection in Python,

159
00:05:37,679 --> 00:05:40,159
but it's a big part of
what they're doing.

160
00:05:40,159 --> 00:05:41,940
And one of the applications

161
00:05:41,940 --> 00:05:43,739
of this is that if I
have multiple threads,

162
00:05:43,739 --> 00:05:45,899
they need to modify
these same editors.

163
00:05:45,899 --> 00:05:48,140
And one of the things we saw
last time is that if I have

164
00:05:48,140 --> 00:05:49,260
two threads and I have

165
00:05:49,260 --> 00:05:51,600
an editor that's just
like counting up,

166
00:05:51,600 --> 00:05:54,300
I actually have to have
locking to get that

167
00:05:54,300 --> 00:05:57,499
right because even a simple x

168
00:05:57,499 --> 00:05:59,510
plus equals wo is

169
00:05:59,510 --> 00:06:00,890
multiple instructions
and we could have

170
00:06:00,890 --> 00:06:03,050
a context switch at
a bad type, right?

171
00:06:03,050 --> 00:06:04,870
So how are we going
to do this here?

172
00:06:04,870 --> 00:06:07,429
Well, we're tostly having
variables referring to objects.

173
00:06:07,429 --> 00:06:10,190
So one thing is that we
could have lots of fine

174
00:06:10,190 --> 00:06:13,430
grain locking in the
Python interpreter, right?

175
00:06:13,430 --> 00:06:14,749
We the starbage collection,

176
00:06:14,749 --> 00:06:17,189
stuff it could be acquiring
and releasing locks.

177
00:06:17,189 --> 00:06:19,230
And that would actually
be quite slow, right?

178
00:06:19,230 --> 00:06:20,650
It would probably make just a

179
00:06:20,650 --> 00:06:22,449
regular single threaded
program slower?

180
00:06:22,449 --> 00:06:23,709
If you have a single
threaded program and

181
00:06:23,709 --> 00:06:25,689
it's constantly
locking and unlocking,

182
00:06:25,689 --> 00:06:29,030
it's unnecessary and
slower than it would be.

183
00:06:29,030 --> 00:06:31,950
What else might we
do? Maybe there's

184
00:06:31,950 --> 00:06:33,689
other more clever approaches.

185
00:06:33,689 --> 00:06:35,149
We could just say, let's run

186
00:06:35,149 --> 00:06:37,610
one threaded type.
That's what Python does.

187
00:06:37,610 --> 00:06:39,589
And so there's different
trade offs here.

188
00:06:39,589 --> 00:06:40,750
And one of the
reasons that we've

189
00:06:40,750 --> 00:06:42,029
had the global
interpreter lock for

190
00:06:42,029 --> 00:06:43,130
a long time is there's been

191
00:06:43,130 --> 00:06:44,830
pushback when people
want to remove it.

192
00:06:44,830 --> 00:06:47,609
Well, that might make multi
threaded programs faster,

193
00:06:47,609 --> 00:06:49,929
but single threaded
programs slower.

194
00:06:49,929 --> 00:06:51,090
That's a trade off a lot of

195
00:06:51,090 --> 00:06:53,350
people have not wanted
to make, right?

196
00:06:53,350 --> 00:06:54,869
So we've had the
global interpreter

197
00:06:54,869 --> 00:06:57,070
lock until now, right?

198
00:06:57,070 --> 00:06:59,070
Now, what is the future of it?

199
00:06:59,070 --> 00:07:01,870
Literally, this
week on October 1,

200
00:07:01,870 --> 00:07:04,734
Python 3.13 is released.

201
00:07:04,734 --> 00:07:08,460
And this is the first
made Python version where

202
00:07:08,460 --> 00:07:10,040
they have a mode where you can

203
00:07:10,040 --> 00:07:12,279
run without the global
interpreter lock.

204
00:07:12,279 --> 00:07:14,160
And so there's actually
different versions you sell.

205
00:07:14,160 --> 00:07:15,759
You can say one to
download Python with

206
00:07:15,759 --> 00:07:18,180
the interpreter lock or
without the interpreter lock.

207
00:07:18,180 --> 00:07:20,379
Which one is better for
you? While it depends?

208
00:07:20,379 --> 00:07:21,700
How heavily you
are using threads?

209
00:07:21,700 --> 00:07:23,820
Water lower might
be faster for you.

210
00:07:23,820 --> 00:07:25,560
But they make a
note here, right?

211
00:07:25,560 --> 00:07:28,160
This is experimental. There
are probably some bugs in it.

212
00:07:28,160 --> 00:07:29,480
If you're using the
version without

213
00:07:29,480 --> 00:07:30,720
the global interpreter lock,

214
00:07:30,720 --> 00:07:33,239
single thread performance
is right take a had.

215
00:07:33,239 --> 00:07:35,409
So this is something that
You know, for a long time,

216
00:07:35,409 --> 00:07:36,670
it was not even an option to run

217
00:07:36,670 --> 00:07:38,229
without the global
interpreter lock.

218
00:07:38,229 --> 00:07:39,790
Now it's trying to
becoming an option,

219
00:07:39,790 --> 00:07:41,150
but you're still going to have
to think about it because

220
00:07:41,150 --> 00:07:42,850
there's gonna be some
performance trade offs.

221
00:07:42,850 --> 00:07:43,329
Who knows?

222
00:07:43,329 --> 00:07:45,089
Maybe somebody will fix
that and we have the best

223
00:07:45,089 --> 00:07:47,730
of both worlds someday.
But I wouldn't bet on it.

224
00:07:47,730 --> 00:07:49,030
The global Interpreter lock is

225
00:07:49,030 --> 00:07:50,309
probably something you
have to think about if

226
00:07:50,309 --> 00:07:51,910
you want to write
high performance

227
00:07:51,910 --> 00:07:54,129
Python road and the log run.

228
00:07:54,129 --> 00:07:55,610
What questions people have

229
00:07:55,610 --> 00:07:56,989
about the global
Interpreter lock

230
00:07:56,989 --> 00:07:59,410
or kind of the reason
why it's there.

231
00:08:05,360 --> 00:08:07,740
Alright, so that was
one of the advanced

232
00:08:07,740 --> 00:08:08,980
topics I wanted to talk about.

233
00:08:08,980 --> 00:08:10,459
The other one is really related

234
00:08:10,459 --> 00:08:12,240
to how CPUs work and how that

235
00:08:12,240 --> 00:08:16,759
makes threads and locks
more complicated.

236
00:08:16,759 --> 00:08:19,660
What I've been talking about
threads of locks so far.

237
00:08:19,660 --> 00:08:22,560
The kind of problem that
we have been talking about

238
00:08:22,560 --> 00:08:25,659
a lot is to text switches
at a bad time, right?

239
00:08:25,659 --> 00:08:26,780
To text switches at

240
00:08:26,780 --> 00:08:29,039
a bad time or one of the
reasons we use locks.

241
00:08:29,039 --> 00:08:30,839
But it's actually
not the only reason.

242
00:08:30,839 --> 00:08:33,980
I I don't want to spend a
lot of time on these topics,

243
00:08:33,980 --> 00:08:35,179
but I just want people to not

244
00:08:35,179 --> 00:08:36,459
get clever and think, like, Oh,

245
00:08:36,459 --> 00:08:37,719
if I find another way to deal

246
00:08:37,719 --> 00:08:39,299
with context switches
at a bad time,

247
00:08:39,299 --> 00:08:40,879
I can avoid locks, right?

248
00:08:40,879 --> 00:08:42,839
There is, whole areas of
research where people

249
00:08:42,839 --> 00:08:45,320
build lock free data structures,

250
00:08:45,320 --> 00:08:47,820
but you don't just have to
worry about context switches.

251
00:08:47,820 --> 00:08:49,179
You have to worry about a
couple of other things.

252
00:08:49,179 --> 00:08:50,639
So I just want these
other things to be on

253
00:08:50,639 --> 00:08:52,140
your radar so you
don't try to write

254
00:08:52,140 --> 00:08:55,995
something clever that is
missing some important details.

255
00:08:55,995 --> 00:09:00,110
So, let me show you some
code that has two threads,

256
00:09:00,110 --> 00:09:02,070
and it has no locks.

257
00:09:02,070 --> 00:09:04,170
And based on everything
we've learned so far,

258
00:09:04,170 --> 00:09:06,690
it would seem like it
would be correct code,

259
00:09:06,690 --> 00:09:08,710
but it's actually not.
There's a bug here.

260
00:09:08,710 --> 00:09:11,590
So let's see when I was
first sing about threads,

261
00:09:11,590 --> 00:09:13,690
I wrote code like this
because I thought,

262
00:09:13,690 --> 00:09:15,469
Oh, this is simpler than
thinking about locks.

263
00:09:15,469 --> 00:09:17,050
But this is actually buggy.

264
00:09:17,050 --> 00:09:19,009
What are we doing
here? So we have

265
00:09:19,009 --> 00:09:21,269
a task that's to be
a thread, right?

266
00:09:21,269 --> 00:09:23,670
So I'm say thread
target equals task.

267
00:09:23,670 --> 00:09:26,149
And that task, its job is to

268
00:09:26,149 --> 00:09:30,174
square x and put the
value in the y variable.

269
00:09:30,174 --> 00:09:32,680
And then I can see down
here in the Bad thread,

270
00:09:32,680 --> 00:09:34,159
we're putting off
that y variable.

271
00:09:34,159 --> 00:09:36,220
And so the goal is that
we don't want to put

272
00:09:36,220 --> 00:09:38,359
off the y variable until
the computation is done.

273
00:09:38,359 --> 00:09:41,399
We want to wait until it
actually calculates it,

274
00:09:41,399 --> 00:09:42,620
and then put it out later.

275
00:09:42,620 --> 00:09:44,259
And so, you know,
the correct way

276
00:09:44,259 --> 00:09:46,759
to do that would be
with a droid operation.

277
00:09:46,759 --> 00:09:49,340
What does this person
try to do here?

278
00:09:49,340 --> 00:09:51,160
Well, they created
a ready variable,

279
00:09:51,160 --> 00:09:53,599
not lock, just a ready variable.

280
00:09:53,599 --> 00:09:57,000
And after they set y
equal to the value,

281
00:09:57,000 --> 00:09:58,460
then they say ready equals true.

282
00:09:58,460 --> 00:10:00,559
And what does the
made thread do?

283
00:10:00,559 --> 00:10:02,219
It just keeps looping
until ready is

284
00:10:02,219 --> 00:10:04,579
true and then it
prints off y, right?

285
00:10:04,579 --> 00:10:06,580
So if I only had to worry

286
00:10:06,580 --> 00:10:08,939
about inter leaving and
context switches at bad time,

287
00:10:08,939 --> 00:10:10,600
this would be correct code.

288
00:10:10,600 --> 00:10:12,080
It's actually not correct code.

289
00:10:12,080 --> 00:10:14,819
And the reason why
is that CPUs do

290
00:10:14,819 --> 00:10:18,279
something called out of
order execution, right?

291
00:10:18,279 --> 00:10:19,860
W I wrote this code here,

292
00:10:19,860 --> 00:10:22,880
Y equals sing, ready equals,
I wrote in that order.

293
00:10:22,880 --> 00:10:25,859
But sometimes it might be
faster for the CPU to say,

294
00:10:25,859 --> 00:10:29,259
ready equals true first and
y equals something first.

295
00:10:29,259 --> 00:10:31,119
And when the CPU is
trying to figure out,

296
00:10:31,119 --> 00:10:33,199
can I reorder these
instructions?

297
00:10:33,199 --> 00:10:35,020
It's only looking
at the code here.

298
00:10:35,020 --> 00:10:37,359
It's not thinking
about other threads.

299
00:10:37,359 --> 00:10:38,780
If I'm only looking at the code

300
00:10:38,780 --> 00:10:40,180
here inside of this function,

301
00:10:40,180 --> 00:10:42,740
well, yeah, it doesn't really
matter the order of these.

302
00:10:42,740 --> 00:10:44,180
The order really matters

303
00:10:44,180 --> 00:10:46,199
depending on what other
threads are doing,

304
00:10:46,199 --> 00:10:48,999
but the CPU is not aware of
those at the moment, right?

305
00:10:48,999 --> 00:10:51,919
So the CPU might reorder these.

306
00:10:51,919 --> 00:10:56,680
Why might it do that?
Well, We've already seen

307
00:10:56,880 --> 00:11:00,399
that one of the reasons that
CPUs get slow is because

308
00:11:00,399 --> 00:11:03,360
they have to load
some memory from RAM.

309
00:11:03,360 --> 00:11:05,119
And when they do that, they
do some load instruction.

310
00:11:05,119 --> 00:11:08,139
And, you know, we were going
along with this fast clock,

311
00:11:08,139 --> 00:11:10,299
like, you know, billions
of ticks per second.

312
00:11:10,299 --> 00:11:12,640
And all of a sudden, we
have to wait for 200 ticks

313
00:11:12,640 --> 00:11:15,719
to get a piece of
memory from RAM.

314
00:11:15,719 --> 00:11:17,159
We have to load that
to the register.

315
00:11:17,159 --> 00:11:19,179
And so sometimes
the CPU might say,

316
00:11:19,179 --> 00:11:21,840
Oh, like, this instruction,
I'm stuck on it for a while.

317
00:11:21,840 --> 00:11:23,539
Maybe I can work on some
other things, right?

318
00:11:23,539 --> 00:11:25,080
Maybe there's other
values that are already,

319
00:11:25,080 --> 00:11:26,720
like in a cache
or in a register.

320
00:11:26,720 --> 00:11:29,179
So CPU might do
things out of order

321
00:11:29,179 --> 00:11:30,660
if it's kind of waiting

322
00:11:30,660 --> 00:11:32,399
a long time on a specific
instruction, right?

323
00:11:32,399 --> 00:11:33,979
So stuff like this can happen.

324
00:11:33,979 --> 00:11:36,699
And the CPU is just
looking at that local code

325
00:11:36,699 --> 00:11:39,299
to figure out whether that's
a reasonable thing to do.

326
00:11:39,299 --> 00:11:40,579
Do people have any
questions about

327
00:11:40,579 --> 00:11:42,640
out of order execution?

328
00:11:47,160 --> 00:11:49,839
And, of course, why is
this a problem for us?

329
00:11:49,839 --> 00:11:51,500
Because if ready equals true,

330
00:11:51,500 --> 00:11:53,099
before we compute the value,

331
00:11:53,099 --> 00:11:55,279
then this loop out
here by it sp and it

332
00:11:55,279 --> 00:11:57,919
might pret y before we
actually get a value and Y?

333
00:11:57,919 --> 00:12:04,759
Yeah, question right
here. Yeah, you're right.

334
00:12:04,759 --> 00:12:06,380
By should be a global variable.

335
00:12:06,380 --> 00:12:07,639
Maybe I'll just make
a note of that.

336
00:12:07,639 --> 00:12:09,940
So maybe I'll take
something like global.

337
00:12:09,940 --> 00:12:15,819
Why? Good catch. Yeah.

338
00:12:15,819 --> 00:12:17,400
Thanks for catching
that. Yeah Myb

339
00:12:17,400 --> 00:12:18,779
I should actually
the previous slide,

340
00:12:18,779 --> 00:12:21,239
too, so it's not confusing.

341
00:12:21,280 --> 00:12:25,080
Y, those are both
global variables.

342
00:12:25,480 --> 00:12:28,080
Whatever I you and pick
a bunch of these slides.

343
00:12:28,080 --> 00:12:30,159
Yeah another question over here.

344
00:12:32,760 --> 00:12:38,019
What will the CPU do?
What? Order. What does

345
00:12:38,019 --> 00:12:39,760
it know not to reorder
the execution.

346
00:12:39,760 --> 00:12:42,619
So Locks can do multiple things.

347
00:12:42,619 --> 00:12:43,860
One of the things they
can do is make sure that

348
00:12:43,860 --> 00:12:45,499
two pieces of cod any
at the same time.

349
00:12:45,499 --> 00:12:46,619
They also do something that

350
00:12:46,619 --> 00:12:47,699
I'm not trying to
get into a lot,

351
00:12:47,699 --> 00:12:50,099
but they have something
called a memory barrier.

352
00:12:50,099 --> 00:12:52,160
And Aby barrier
says that basically

353
00:12:52,160 --> 00:12:54,700
all these changes to
memory before the locking

354
00:12:54,700 --> 00:12:56,639
happened have to basically be

355
00:12:56,639 --> 00:12:59,499
visible elsewhere before
after the lock, right?

356
00:12:59,499 --> 00:13:00,939
So if I'm kind of like releasing

357
00:13:00,939 --> 00:13:02,639
a lock and somebody
else acquires it,

358
00:13:02,639 --> 00:13:03,940
it's try to make sure that kind

359
00:13:03,940 --> 00:13:05,240
of all the changes
I had with the lock

360
00:13:05,240 --> 00:13:08,019
are going to be visible
afterwards, right?

361
00:13:08,019 --> 00:13:10,579
So it's not just about
running at the same time,

362
00:13:10,579 --> 00:13:12,380
I try to make sure
all these changes

363
00:13:12,380 --> 00:13:13,859
actually appear to other people

364
00:13:13,859 --> 00:13:15,640
in that order. Do
that make sense?

365
00:13:15,640 --> 00:13:16,980
Yeah, excellent question.

366
00:13:16,980 --> 00:13:19,399
Yeah. Other questions
people have.

367
00:13:20,480 --> 00:13:22,819
Alright, so that's
like, one weird thing

368
00:13:22,819 --> 00:13:24,679
that CPUs do that we
have to worry about.

369
00:13:24,679 --> 00:13:26,059
Locks just take care
of that, right?

370
00:13:26,059 --> 00:13:27,139
So if you're trying to do

371
00:13:27,139 --> 00:13:28,560
something clever
that's lock free,

372
00:13:28,560 --> 00:13:30,060
you really have
to understand how

373
00:13:30,060 --> 00:13:32,040
the CPU works in
quite a bit of tail.

374
00:13:32,040 --> 00:13:33,999
You have to understand in more
detail than, I understand.

375
00:13:33,999 --> 00:13:35,579
I could just row and
make a lock free

376
00:13:35,579 --> 00:13:37,640
data structure very readily.

377
00:13:37,640 --> 00:13:39,020
I'd have to really understand

378
00:13:39,020 --> 00:13:40,400
in more detail what's drawing.

379
00:13:40,400 --> 00:13:41,940
These are just some broad things

380
00:13:41,940 --> 00:13:43,659
that you might have
to worry about.

381
00:13:43,659 --> 00:13:46,099
Let's look at another case here.

382
00:13:46,099 --> 00:13:50,619
We learned that we have these
different caches, right?

383
00:13:50,619 --> 00:13:54,059
And You know, an L
one cash is just for

384
00:13:54,059 --> 00:13:58,020
a single core on a CPU on a
single core on a processor.

385
00:13:58,020 --> 00:13:59,739
It's totally
possible I also have

386
00:13:59,739 --> 00:14:01,899
multiple processor chips plugged

387
00:14:01,899 --> 00:14:04,719
into my motherboard
and in that case,

388
00:14:04,719 --> 00:14:06,839
each of them would have their
own L three cash, right?

389
00:14:06,839 --> 00:14:08,879
So cashes, right are not

390
00:14:08,879 --> 00:14:11,720
shared across all
cores in general.

391
00:14:11,720 --> 00:14:13,300
Some are shared to
a greater extent

392
00:14:13,300 --> 00:14:14,560
and some to a less extent,

393
00:14:14,560 --> 00:14:17,860
but cashes are not
shared universally.

394
00:14:17,860 --> 00:14:22,439
So I can imagine a case like
this where in Poor one,

395
00:14:22,439 --> 00:14:26,399
maybe the L one cash
has these values in it,

396
00:14:26,399 --> 00:14:31,599
and maybe the L one cash for
CR two has se old values.

397
00:14:31,599 --> 00:14:34,379
The cash hasn't been
updated yet, right?

398
00:14:34,379 --> 00:14:35,859
Because we just just

399
00:14:35,859 --> 00:14:38,020
now made these changes
in the L one cash.

400
00:14:38,020 --> 00:14:41,719
And what could happen is
as the cash becomes fresh,

401
00:14:41,719 --> 00:14:44,559
we are really don't
have really guarantees

402
00:14:44,559 --> 00:14:47,039
on which value will become
fresh first, right?

403
00:14:47,039 --> 00:14:49,319
So maybe ready gets fresh first,

404
00:14:49,319 --> 00:14:51,419
and we sell a sale value for y.

405
00:14:51,419 --> 00:14:54,040
And I might put off
that sale value.

406
00:14:54,040 --> 00:14:55,479
Again, if we do locking history,

407
00:14:55,479 --> 00:14:57,579
to make sure that the
right thing happens

408
00:14:57,579 --> 00:14:58,879
with respect to cashing, right?

409
00:14:58,879 --> 00:15:01,049
So What I really want
you to do, right?

410
00:15:01,049 --> 00:15:03,109
Is don't get too clever with
this locking stuff that can

411
00:15:03,109 --> 00:15:04,349
really come back and bite you

412
00:15:04,349 --> 00:15:05,670
with all these strange things.

413
00:15:05,670 --> 00:15:07,809
What you should do is you
should see, like, well,

414
00:15:07,809 --> 00:15:10,530
what state am I accessing
for multiple threads?

415
00:15:10,530 --> 00:15:13,669
And I should identify
those critical sections of

416
00:15:13,669 --> 00:15:14,989
code that are accessing that

417
00:15:14,989 --> 00:15:16,989
and just, put a lock around it.

418
00:15:16,989 --> 00:15:18,970
Don't get clever
and avoid locks.

419
00:15:18,970 --> 00:15:21,269
These locks solve
many problems for us.

420
00:15:21,269 --> 00:15:23,630
And are leaving is the one
problem we looked a lot at.

421
00:15:23,630 --> 00:15:25,470
There's other problems
they solve as well.

422
00:15:25,470 --> 00:15:27,030
So, do people have any questions

423
00:15:27,030 --> 00:15:29,650
about these kind of
more advanced topics?

424
00:15:31,100 --> 00:15:34,979
All right. Fantastic. So I

425
00:15:34,979 --> 00:15:36,199
already give a bunch of advice,

426
00:15:36,199 --> 00:15:37,200
and we're a little bit be hid,

427
00:15:37,200 --> 00:15:38,180
subtraight a head over here,

428
00:15:38,180 --> 00:15:39,420
but feel free to review

429
00:15:39,420 --> 00:15:42,079
that advice for kind
of using lock as well.

430
00:15:42,079 --> 00:15:44,199
Let's talk about file systems.

431
00:15:44,199 --> 00:15:46,920
So file systems to
do a lot of things.

432
00:15:46,920 --> 00:15:48,539
One of the things they
could do is they could

433
00:15:48,539 --> 00:15:51,700
manage the bytes of
data on a block device.

434
00:15:51,700 --> 00:15:55,420
A block device might be like
a hard disk drive or an SSD.

435
00:15:55,420 --> 00:15:56,799
And so one of the things we

436
00:15:56,799 --> 00:15:58,280
want to do is if we were
to thinking about files,

437
00:15:58,280 --> 00:15:59,219
we also have to think about what

438
00:15:59,219 --> 00:16:01,099
are the performance
characteristics

439
00:16:01,099 --> 00:16:03,964
of different devices
that we might be using.

440
00:16:03,964 --> 00:16:05,330
Why do you be able to describe

441
00:16:05,330 --> 00:16:06,969
different types of
file systems? Right?

442
00:16:06,969 --> 00:16:08,790
There's lots of different tins
of file system out there.

443
00:16:08,790 --> 00:16:10,169
At any given time, you're using

444
00:16:10,169 --> 00:16:11,490
at least a few different types,

445
00:16:11,490 --> 00:16:13,649
and not necessarily
thinking about it.

446
00:16:13,649 --> 00:16:15,589
And then finally, we've seen

447
00:16:15,589 --> 00:16:17,070
these commands before Mo and DF.

448
00:16:17,070 --> 00:16:19,470
I want to look at those a
little bit more carefully

449
00:16:19,470 --> 00:16:20,489
now that we actually will

450
00:16:20,489 --> 00:16:22,169
understand what a
file system is.

451
00:16:22,169 --> 00:16:24,050
Okay, so let's start
at the low level,

452
00:16:24,050 --> 00:16:25,730
which is block devices.

453
00:16:25,730 --> 00:16:27,630
And what is a block device?

454
00:16:27,630 --> 00:16:30,230
Well, maybe it makes sense
to contrast it with memory.

455
00:16:30,230 --> 00:16:32,069
With memory, what I

456
00:16:32,069 --> 00:16:34,069
say is that memory is
byte addressable, right?

457
00:16:34,069 --> 00:16:36,450
So Memory has a bunch of bits,

458
00:16:36,450 --> 00:16:38,889
and those bits are chucked
together in bytes.

459
00:16:38,889 --> 00:16:40,349
So eight bits is a byte.

460
00:16:40,349 --> 00:16:41,729
Each byte of memory has

461
00:16:41,729 --> 00:16:44,330
its own unique adress?
Yeah, question right here.

462
00:16:44,330 --> 00:16:50,130
Slide. Oh, are the
slides out of the site?

463
00:16:50,130 --> 00:16:53,270
Maybe I forgot to post the
I could just do that quick

464
00:16:53,270 --> 00:16:57,169
if that's helpful to
people. Let me just see.

465
00:16:57,169 --> 00:16:59,369
Maybe if some people like

466
00:16:59,369 --> 00:17:01,869
to take notes on it or
something like that.

467
00:17:06,840 --> 00:17:09,000
You know, I may have
to exploore stuff.

468
00:17:09,000 --> 00:17:11,119
So by apologies, I'll try to
have it posted online later.

469
00:17:11,119 --> 00:17:14,319
I'll be sure it comes
it's posted afterwards.

470
00:17:14,319 --> 00:17:16,900
So memory is bite addressable.

471
00:17:16,900 --> 00:17:19,060
Whereas blocks, block device.

472
00:17:19,060 --> 00:17:21,919
What they are we do is
break up all these bits

473
00:17:21,919 --> 00:17:25,180
into blocks that are
relatively large.

474
00:17:25,180 --> 00:17:27,259
Maybe like 512 bytes,

475
00:17:27,259 --> 00:17:30,719
half a kilobyte or maybe a
couple of kilobytes, right?

476
00:17:30,719 --> 00:17:33,299
And I may have a block address

477
00:17:33,299 --> 00:17:35,079
for each of these
different blocks.

478
00:17:35,079 --> 00:17:37,219
That'll be the granularity
that I communicate back and

479
00:17:37,219 --> 00:17:40,339
forth with that block device.

480
00:17:40,339 --> 00:17:43,019
So that's going to make some big

481
00:17:43,019 --> 00:17:45,380
impacts on our performance.

482
00:17:45,380 --> 00:17:47,239
So let's imagine that I had

483
00:17:47,239 --> 00:17:49,400
this file stored
on a block device.

484
00:17:49,400 --> 00:17:50,880
It's a CSV file,

485
00:17:50,880 --> 00:17:54,840
and I've highlighted
different colors regions

486
00:17:54,840 --> 00:17:56,379
of 512 bytes, right?

487
00:17:56,379 --> 00:17:59,620
So the first few rows of the
file are that first block,

488
00:17:59,620 --> 00:18:00,899
kind of splits in the middle.

489
00:18:00,899 --> 00:18:02,880
I have some more rows
of the second block,

490
00:18:02,880 --> 00:18:05,264
and so on and so forth, right?

491
00:18:05,264 --> 00:18:07,930
And if I'm writing a program,

492
00:18:07,930 --> 00:18:11,149
I might be looping over, say,
like, one line at a time,

493
00:18:11,149 --> 00:18:14,650
but when we're actually
accessing data on the disk,

494
00:18:14,650 --> 00:18:17,930
it's to be doing these
bigger 512 byte transfers.

495
00:18:17,930 --> 00:18:20,809
So there's a couple of things
that the operating system

496
00:18:20,809 --> 00:18:22,809
is going to do to help
make that faster.

497
00:18:22,809 --> 00:18:24,189
What is that long term?

498
00:18:24,189 --> 00:18:25,410
It might cash these things?

499
00:18:25,410 --> 00:18:27,224
We already learned
about the page cache.

500
00:18:27,224 --> 00:18:28,619
About how that works with MAP,

501
00:18:28,619 --> 00:18:29,879
and can also use that
if we're just like

502
00:18:29,879 --> 00:18:31,520
doing regular reads to a file.

503
00:18:31,520 --> 00:18:34,399
And so in that case, the
page cast lease linux

504
00:18:34,399 --> 00:18:35,900
is four kilobyte blocks,

505
00:18:35,900 --> 00:18:39,240
so that would be sorry,

506
00:18:39,240 --> 00:18:40,999
four kilobyte pages,
that would be

507
00:18:40,999 --> 00:18:42,899
like eight blocks from,

508
00:18:42,899 --> 00:18:44,659
say, a hard drive or
something like that.

509
00:18:44,659 --> 00:18:46,119
And it will just
keep that. So if I'm

510
00:18:46,119 --> 00:18:47,440
reading the same
file multiple times,

511
00:18:47,440 --> 00:18:49,920
maybe I don't have to do
disco on multiple times.

512
00:18:49,920 --> 00:18:51,660
Even if I'm making
one pass though,

513
00:18:51,660 --> 00:18:52,980
we can use memory to help.

514
00:18:52,980 --> 00:18:57,410
So Pytho and lix and other
layers of the stack.

515
00:18:57,410 --> 00:18:58,929
What they'll do is if I access

516
00:18:58,929 --> 00:19:00,510
just like one line of data.

517
00:19:00,510 --> 00:19:02,189
They're going to pull
in a whole block of

518
00:19:02,189 --> 00:19:04,190
data or maybe multiple
blocks of data,

519
00:19:04,190 --> 00:19:05,189
and they're going
to keep that in

520
00:19:05,189 --> 00:19:06,370
a piece of memory
because they're

521
00:19:06,370 --> 00:19:07,809
assuming I'm may be
looping over and

522
00:19:07,809 --> 00:19:09,510
I'm going to ask for
the next slide soon.

523
00:19:09,510 --> 00:19:11,069
That's called buffering, right?

524
00:19:11,069 --> 00:19:13,489
So when I'm to try

525
00:19:13,489 --> 00:19:15,029
to keep data around
blog terminas.

526
00:19:15,029 --> 00:19:16,169
I using. That's caching.

527
00:19:16,169 --> 00:19:17,270
Buffering is when I'm doing

528
00:19:17,270 --> 00:19:18,989
these transfers that I want to

529
00:19:18,989 --> 00:19:20,389
transfer data to the bigger

530
00:19:20,389 --> 00:19:22,589
chucks for performance reasons,

531
00:19:22,589 --> 00:19:23,289
but the application of

532
00:19:23,289 --> 00:19:24,710
a higher level needs
smaller chucks.

533
00:19:24,710 --> 00:19:26,989
I might buffer those
bigger chucks and memory.

534
00:19:26,989 --> 00:19:30,409
So it's ready when
it's needed, right?

535
00:19:30,440 --> 00:19:32,660
So when I'm actually
these files,

536
00:19:32,660 --> 00:19:35,120
both caching and buffering
might be in play.

537
00:19:35,120 --> 00:19:39,460
And you can usually see
that if you look at H top,

538
00:19:39,460 --> 00:19:42,179
usually there'll be
some amount of memory

539
00:19:42,179 --> 00:19:43,619
that's just like actually memory

540
00:19:43,619 --> 00:19:44,920
that processes are using.

541
00:19:44,920 --> 00:19:46,799
There's may be some
page cache memory.

542
00:19:46,799 --> 00:19:48,419
And then there's
usually another color

543
00:19:48,419 --> 00:19:50,440
there that indicates
memory for buffers.

544
00:19:50,440 --> 00:19:51,879
That's usually not a
lot of memory, right,

545
00:19:51,879 --> 00:19:53,160
because it's kind of temporary

546
00:19:53,160 --> 00:19:55,420
for having these
bigger chunks of data.

547
00:19:55,420 --> 00:19:58,880
So that will show up if you
go and run a tool like H top.

548
00:19:59,040 --> 00:20:03,680
Okay, so where does this
matter for performance?

549
00:20:03,760 --> 00:20:07,540
I want to imagine that I
have this big CSV file.

550
00:20:07,540 --> 00:20:08,800
It's not quite a CSV file.

551
00:20:08,800 --> 00:20:13,440
It's like a kind of a cab format

552
00:20:13,440 --> 00:20:16,279
where I have some spaces
between each column.

553
00:20:16,279 --> 00:20:17,439
And I'm just trying
to imagine that

554
00:20:17,439 --> 00:20:18,520
I don't care about all the data.

555
00:20:18,520 --> 00:20:19,819
I just want to access all

556
00:20:19,819 --> 00:20:21,659
of the weather
station IDs, right?

557
00:20:21,659 --> 00:20:23,800
So this is a data set
of weather stations.

558
00:20:23,800 --> 00:20:27,119
And there's a couple
of ways I could do it.

559
00:20:27,590 --> 00:20:30,670
Of the simple way on
the left hand side

560
00:20:30,670 --> 00:20:32,510
would be I just open the file,

561
00:20:32,510 --> 00:20:34,489
and I read it one
line at a time,

562
00:20:34,489 --> 00:20:36,049
so I'm pulling it whole lines,

563
00:20:36,049 --> 00:20:38,870
and then I could just slice
out the first 11 characters,

564
00:20:38,870 --> 00:20:41,049
which is the station and put
that in the list, right?

565
00:20:41,049 --> 00:20:42,850
So this program on the left,

566
00:20:42,850 --> 00:20:44,769
could give me all
the station IDs.

567
00:20:44,769 --> 00:20:47,310
I wrote that program. I
rad it on some data set.

568
00:20:47,310 --> 00:20:50,289
That took 66
milliseconds to run.

569
00:20:50,289 --> 00:20:51,629
And at first glance,

570
00:20:51,629 --> 00:20:53,429
it seems kind of
wasteful, right?

571
00:20:53,429 --> 00:20:55,669
Because I only care
about that little bit

572
00:20:55,669 --> 00:20:56,990
of data at the
beginning of each line,

573
00:20:56,990 --> 00:21:00,510
but it's actually reading
the whole lines first,

574
00:21:00,510 --> 00:21:02,645
and kind of trimming it down.

575
00:21:02,645 --> 00:21:05,040
Okay. So that was not great.

576
00:21:05,040 --> 00:21:07,520
So then I tried to write
an optimized version.

577
00:21:07,520 --> 00:21:09,219
The optimized version.
I put that in quotes

578
00:21:09,219 --> 00:21:11,339
because it actually
ended up being slower.

579
00:21:11,339 --> 00:21:13,420
And when we know about
how the display works,

580
00:21:13,420 --> 00:21:14,879
we can understand
why the optimization

581
00:21:14,879 --> 00:21:16,019
was actually bad, right?

582
00:21:16,019 --> 00:21:17,360
It actually made things worse.

583
00:21:17,360 --> 00:21:20,419
So this more complicated
optimized version on the right,

584
00:21:20,419 --> 00:21:24,440
I said that I only ever want
to read the station ID.

585
00:21:24,440 --> 00:21:26,000
I don't want to read
any other data.

586
00:21:26,000 --> 00:21:27,000
So I did a few things.

587
00:21:27,000 --> 00:21:28,739
When I opened the file,
I said, don't buffer it.

588
00:21:28,739 --> 00:21:30,440
I don't want you to read
it all this extra data.

589
00:21:30,440 --> 00:21:34,140
I just want to access these
small bits of station ID.

590
00:21:34,140 --> 00:21:35,859
And then what I did is

591
00:21:35,859 --> 00:21:38,019
I figured out how
long each line was.

592
00:21:38,019 --> 00:21:39,760
I was like 86 characters.

593
00:21:39,760 --> 00:21:41,739
And then I would compute
it offset by that.

594
00:21:41,739 --> 00:21:42,559
I would have an offset,

595
00:21:42,559 --> 00:21:45,059
and I would 86
characters at a time.

596
00:21:45,059 --> 00:21:46,419
So I could draw a
different offset of

597
00:21:46,419 --> 00:21:48,439
the file that was always
the start of aide.

598
00:21:48,439 --> 00:21:50,479
And that's the SIC operation.

599
00:21:50,479 --> 00:21:52,380
The SIC operation means that I'm

600
00:21:52,380 --> 00:21:54,639
ready to read at a specific
offset of the file, right?

601
00:21:54,639 --> 00:21:56,540
I kind of jump into the
beginning of each slide.

602
00:21:56,540 --> 00:21:57,760
In this case, I just read,

603
00:21:57,760 --> 00:21:59,679
I say, dot read instead of
reading the whole thing.

604
00:21:59,679 --> 00:22:01,799
I would just read
11 bytes, right?

605
00:22:01,799 --> 00:22:03,910
So I'm kind of very
carefully saying,

606
00:22:03,910 --> 00:22:05,880
I my Python program,

607
00:22:05,880 --> 00:22:07,660
only ever give me the Sasha IDs.

608
00:22:07,660 --> 00:22:08,580
Don't give me a whole line

609
00:22:08,580 --> 00:22:09,900
because I don't need
the whole line.

610
00:22:09,900 --> 00:22:12,059
And that's actually
slower, right?

611
00:22:12,059 --> 00:22:17,220
Be because I disabled
buffer at the lower level,

612
00:22:17,220 --> 00:22:18,479
we're still communicating with

613
00:22:18,479 --> 00:22:21,440
the disc get the
granularity of 512 bytes,

614
00:22:21,440 --> 00:22:22,799
no matter what I try to do

615
00:22:22,799 --> 00:22:25,479
otherwise in my Python
program, right?

616
00:22:25,479 --> 00:22:26,680
So my Python program,

617
00:22:26,680 --> 00:22:28,559
it's not very helpful to try to

618
00:22:28,559 --> 00:22:31,059
read small pieces of
data that are subset.

619
00:22:31,059 --> 00:22:32,839
Of block, right?

620
00:22:32,839 --> 00:22:35,479
That's ABD faster just
reading the whole blocks.

621
00:22:35,479 --> 00:22:37,900
And I'll actually get
worse performance,

622
00:22:37,900 --> 00:22:40,879
right if I try to disable
buffering, right?

623
00:22:40,879 --> 00:22:42,339
So it's very similar to what we

624
00:22:42,339 --> 00:22:44,619
saw with cash
liides with memory.

625
00:22:44,619 --> 00:22:46,720
When we're kind of
accessing cash lids,

626
00:22:46,720 --> 00:22:48,340
we want to have programs
that are accessing

627
00:22:48,340 --> 00:22:49,480
whole cash lids of data.

628
00:22:49,480 --> 00:22:51,340
If we just access a little
bit of each cash liide,

629
00:22:51,340 --> 00:22:52,699
where I have worse
performance and

630
00:22:52,699 --> 00:22:54,199
if we're accessing
the whole thing.

631
00:22:54,199 --> 00:22:55,819
So people have questions
about the difference

632
00:22:55,819 --> 00:22:58,120
between these two approaches.

633
00:23:01,160 --> 00:23:04,239
Yeah, question right over here.

634
00:23:06,600 --> 00:23:13,820
Explain what? Oh,
like, the buffering.

635
00:23:13,820 --> 00:23:15,580
I basically disabled buffering.

636
00:23:15,580 --> 00:23:18,939
So normally, Python will
do some buffering for me,

637
00:23:18,939 --> 00:23:20,940
and it'll try to when I
read a little bit of data.

638
00:23:20,940 --> 00:23:22,000
I'll actually read a whole bunch

639
00:23:22,000 --> 00:23:23,259
of data and save it in memory.

640
00:23:23,259 --> 00:23:25,779
So when I do some more reads,
it's just ready for me.

641
00:23:25,779 --> 00:23:28,480
And so I'm saying the
optimized version,

642
00:23:28,480 --> 00:23:29,879
I try to say, I only want to

643
00:23:29,879 --> 00:23:31,800
read the data I
need, nothing more.

644
00:23:31,800 --> 00:23:33,379
And that's why I
disabled buffering

645
00:23:33,379 --> 00:23:35,219
because buffering would
read extra stuff.

646
00:23:35,219 --> 00:23:37,900
Now, disabling buffering
did actually help

647
00:23:37,900 --> 00:23:40,740
because when I'm ultimately
doing disci at a lower level,

648
00:23:40,740 --> 00:23:42,599
it still has to bring
in these whole blocks

649
00:23:42,599 --> 00:23:44,299
at a time anyway, right?

650
00:23:44,299 --> 00:23:45,740
So disabling
buffering could only

651
00:23:45,740 --> 00:23:47,340
hurt me in this case.
That makes sense?

652
00:23:47,340 --> 00:23:54,079
Yeah, right here. Fo.

653
00:23:54,079 --> 00:23:55,699
Yeah, I think if buffer was d,

654
00:23:55,699 --> 00:23:57,320
we ought to have
identical performance.

655
00:23:57,320 --> 00:23:58,739
I don't know if I tried it.

656
00:23:58,739 --> 00:24:00,480
I guess I kind of did
it like a year ago,

657
00:24:00,480 --> 00:24:01,680
but we could try it too.

658
00:24:01,680 --> 00:24:03,219
I mean, that'd be
kind of fun, but

659
00:24:03,219 --> 00:24:05,580
my expectations that
the performance

660
00:24:05,580 --> 00:24:07,540
would be identical
if we had buffer od.

661
00:24:07,540 --> 00:24:10,999
Yeah, great question. Yeah,
all questions people have.

662
00:24:12,770 --> 00:24:18,130
Alright. C. So we have different
types of block devices,

663
00:24:18,130 --> 00:24:20,409
and that was one thing
in common, right?

664
00:24:20,409 --> 00:24:22,309
We want to have be transferring

665
00:24:22,309 --> 00:24:25,509
at least the size of these
blocks for the block device,

666
00:24:25,509 --> 00:24:27,890
but also they have very
different characteristics

667
00:24:27,890 --> 00:24:30,229
as well in other regards.
I'll be look at too.

668
00:24:30,229 --> 00:24:31,449
I look at the hard
disk drive and

669
00:24:31,449 --> 00:24:33,349
also the solid state disk.

670
00:24:33,349 --> 00:24:36,930
And the hard drive actually
has these moving parts.

671
00:24:36,930 --> 00:24:39,629
It has these platters
that are magnetized,

672
00:24:39,629 --> 00:24:41,329
depending on the state
of the magnetism.

673
00:24:41,329 --> 00:24:44,590
It could either be a zero or
a one and a specific point.

674
00:24:44,590 --> 00:24:48,950
This is just spitting
around quite rapidly.

675
00:24:48,950 --> 00:24:51,400
And What we have over here at

676
00:24:51,400 --> 00:24:53,680
the top is is a read right head.

677
00:24:53,680 --> 00:24:55,319
And so that arb will just

678
00:24:55,319 --> 00:24:58,079
move the head back and
forth across the platter.

679
00:24:58,079 --> 00:24:59,419
And wherever it is, it can

680
00:24:59,419 --> 00:25:02,979
read the bite of data at
that position, right?

681
00:25:02,979 --> 00:25:04,860
So if I want to either
read or write some data,

682
00:25:04,860 --> 00:25:06,140
there's a few things
that will happen.

683
00:25:06,140 --> 00:25:08,139
It has to manually move
that head somewhere,

684
00:25:08,139 --> 00:25:09,759
and has to wait
until the platter

685
00:25:09,759 --> 00:25:11,740
spends so the data is
underneath the head,

686
00:25:11,740 --> 00:25:13,039
and then it'll finally actually

687
00:25:13,039 --> 00:25:15,344
start transferring
the data, right?

688
00:25:15,344 --> 00:25:18,230
And those first two
parts that I'm talking

689
00:25:18,230 --> 00:25:20,989
about are going to be what
takes most of the time.

690
00:25:20,989 --> 00:25:24,030
And that's true unless I'm
transferring a lot of data,

691
00:25:24,030 --> 00:25:26,009
say, like the order
of a few megabytes.

692
00:25:26,009 --> 00:25:27,709
If I'm transferring a
few megabytes that I

693
00:25:27,709 --> 00:25:29,589
care about that step three,

694
00:25:29,589 --> 00:25:31,570
but if it's smaller, then step

695
00:25:31,570 --> 00:25:33,709
one and two will
tend to dominate.

696
00:25:33,709 --> 00:25:39,020
Okay? So the way

697
00:25:39,020 --> 00:25:41,659
we'll interact with this
is that internally,

698
00:25:41,659 --> 00:25:43,779
we have all these bytes
in different places,

699
00:25:43,779 --> 00:25:45,459
and what the hard
drive will do is

700
00:25:45,459 --> 00:25:47,419
we'll a side block
locations out here.

701
00:25:47,419 --> 00:25:48,340
Of course, this will be packed

702
00:25:48,340 --> 00:25:49,520
much more tightly
than I'm drawing,

703
00:25:49,520 --> 00:25:51,180
but you can see
block location zero,

704
00:25:51,180 --> 00:25:53,280
one, two, so on and so forth.

705
00:25:53,280 --> 00:25:56,780
And what they try to do
is they try to make sure

706
00:25:56,780 --> 00:25:58,399
that consecutive numbers are

707
00:25:58,399 --> 00:26:00,739
actually next to
each other on disk.

708
00:26:00,739 --> 00:26:02,839
Be when you're programming,
right, let's say,

709
00:26:02,839 --> 00:26:03,619
like you were building

710
00:26:03,619 --> 00:26:05,159
a file system or
something like that,

711
00:26:05,159 --> 00:26:07,179
you don't can't
really quite look

712
00:26:07,179 --> 00:26:09,459
inside of the hard drive
and know the layout.

713
00:26:09,459 --> 00:26:11,599
But what they're trying to
guarantee you is that if

714
00:26:11,599 --> 00:26:14,195
you access blocks
with similar numbers,

715
00:26:14,195 --> 00:26:16,389
If you do a bunch
of those in a row,

716
00:26:16,389 --> 00:26:18,830
then we should have a
pretty fast access pattern,

717
00:26:18,830 --> 00:26:19,709
where we spend most of the time

718
00:26:19,709 --> 00:26:21,349
transferring data instead of

719
00:26:21,349 --> 00:26:24,149
the fixed overhead of
one and two, right?

720
00:26:24,149 --> 00:26:25,689
So that's what's
happening in totally.

721
00:26:25,689 --> 00:26:27,450
And so for the
external perspective,

722
00:26:27,450 --> 00:26:29,890
when we're reading or
writing to a hard drive,

723
00:26:29,890 --> 00:26:33,829
we want to access consecutive
block locations, right?

724
00:26:33,829 --> 00:26:35,289
So we call that a
sequential pattern.

725
00:26:35,289 --> 00:26:37,090
So if I read like 5678,

726
00:26:37,090 --> 00:26:38,429
that would be fast because I

727
00:26:38,429 --> 00:26:39,710
don't have these
fixed overheads.

728
00:26:39,710 --> 00:26:41,730
If I have a do access
pattern where I read,

729
00:26:41,730 --> 00:26:43,290
you know, block two, nine,

730
00:26:43,290 --> 00:26:45,130
five, one, then
that would be a lot

731
00:26:45,130 --> 00:26:48,150
slower because I have to
pay these fixed overheads.

732
00:26:48,570 --> 00:26:50,069
All right.

733
00:26:50,069 --> 00:26:52,469
Just some other interesting
things that people do.

734
00:26:52,469 --> 00:26:56,549
You can imagine that,
you know, rotationally,

735
00:26:56,549 --> 00:26:58,770
it's rotating some
number of degrees

736
00:26:58,770 --> 00:27:01,389
or radians per second.

737
00:27:01,389 --> 00:27:02,950
And on the outside track,

738
00:27:02,950 --> 00:27:06,369
there's more space so they
can pack more bytes in.

739
00:27:06,369 --> 00:27:09,855
And so one of the applications
is on the outside track,

740
00:27:09,855 --> 00:27:12,659
The bites are going
underneath the red head at

741
00:27:12,659 --> 00:27:15,139
a faster rate than on
the inside track, right?

742
00:27:15,139 --> 00:27:17,299
If the physics of that
that makes sense.

743
00:27:17,299 --> 00:27:18,599
And so data on the outside

744
00:27:18,599 --> 00:27:19,919
track would actually
be faster, right?

745
00:27:19,919 --> 00:27:21,259
Kind of different location on

746
00:27:21,259 --> 00:27:23,099
the disc will be either
be faster or shorter.

747
00:27:23,099 --> 00:27:25,199
Some people just
decide that, you know,

748
00:27:25,199 --> 00:27:27,519
hard drives have
a ton of capacity

749
00:27:27,519 --> 00:27:29,440
and kind of the performance

750
00:27:29,440 --> 00:27:31,359
of actually accessing is
what really is painful.

751
00:27:31,359 --> 00:27:32,919
Some people just say,
like, I don't want to

752
00:27:32,919 --> 00:27:34,620
even use the inside track.

753
00:27:34,620 --> 00:27:35,999
That would be called
short stroking. They say,

754
00:27:35,999 --> 00:27:38,659
I'm going to keep all my data
on those outside tracks.

755
00:27:38,659 --> 00:27:40,460
The way they'll normally
do that is I'll start

756
00:27:40,460 --> 00:27:42,759
numbering from blocks
zero around the outside,

757
00:27:42,759 --> 00:27:43,999
so you could just
say I want to use

758
00:27:43,999 --> 00:27:45,520
like the first half
of the blocks,

759
00:27:45,520 --> 00:27:47,199
and then you would have
better performance that if

760
00:27:47,199 --> 00:27:49,680
you were using
that inside track.

761
00:27:49,680 --> 00:27:51,639
Of course, the disadvantage,

762
00:27:51,639 --> 00:27:52,699
you have less space available.

763
00:27:52,699 --> 00:27:54,779
Yeah. Questions right here.

764
00:27:54,940 --> 00:28:03,729
Era Yeah.

765
00:28:03,729 --> 00:28:05,109
Like, you're saying, like,

766
00:28:05,109 --> 00:28:07,209
would it make sense so you
put the operating system

767
00:28:07,209 --> 00:28:09,870
of the outside track
or the inside track?

768
00:28:09,870 --> 00:28:12,030
Yeah. Like, I think generally,

769
00:28:12,030 --> 00:28:16,789
you want to put data that is
kind of accessed a lot on

770
00:28:16,789 --> 00:28:19,129
the outside track
with the caveat that

771
00:28:19,129 --> 00:28:21,869
fits access so often destroy
me a Rab anyway, right?

772
00:28:21,869 --> 00:28:23,469
So you want to put data on

773
00:28:23,469 --> 00:28:24,789
the outside track
that's like pretty

774
00:28:24,789 --> 00:28:26,050
hot, but not the hottest data.

775
00:28:26,050 --> 00:28:28,230
So you can imagine like that
becomes like a whole problem

776
00:28:28,230 --> 00:28:30,569
that you could spend a long
time thinking about, like,

777
00:28:30,569 --> 00:28:32,569
Well, I have all this data,

778
00:28:32,569 --> 00:28:34,309
all these files, and, you

779
00:28:34,309 --> 00:28:35,649
know, where should
I put it, right?

780
00:28:35,649 --> 00:28:37,329
That's something that
people think about, right?

781
00:28:37,329 --> 00:28:41,389
And it's a complicated
space to work in, right?

782
00:28:41,389 --> 00:28:43,570
Yeah, it's definitely
interesting though.

783
00:28:43,570 --> 00:28:46,669
Yeah, other questions or
comments people have.

784
00:28:47,400 --> 00:28:51,299
Alright. Cool. So
those are hard drives.

785
00:28:51,299 --> 00:28:53,959
They have some performance
characteristics.

786
00:28:53,959 --> 00:28:56,140
Solid state discs.

787
00:28:56,140 --> 00:28:58,779
The solid state means that
there's no moving parts.

788
00:28:58,779 --> 00:29:01,179
There's different technologies
like the main one that is

789
00:29:01,179 --> 00:29:04,059
basically used universally
is something called flash.

790
00:29:04,059 --> 00:29:06,319
And with flash, instead
of it being magnetized,

791
00:29:06,319 --> 00:29:09,119
it's either like
charged or not charged.

792
00:29:09,119 --> 00:29:11,540
And so since there's
no moving parts,

793
00:29:11,540 --> 00:29:12,939
right, it's going to
be faster, right?

794
00:29:12,939 --> 00:29:14,359
Be you're of sending

795
00:29:14,359 --> 00:29:15,779
electrical signals instead of

796
00:29:15,779 --> 00:29:17,580
waiting for something to
actually physically move.

797
00:29:17,580 --> 00:29:20,180
And it's also
inherently parallel.

798
00:29:20,180 --> 00:29:21,840
So when I'm look
at a hard drive,

799
00:29:21,840 --> 00:29:24,460
there's like one head
that moves around.

800
00:29:24,460 --> 00:29:28,039
It could be one place at a
time with an SSD, often times,

801
00:29:28,039 --> 00:29:29,539
like we could be
reading bytes from

802
00:29:29,539 --> 00:29:32,639
different portions of the
SSD simultaneously, right?

803
00:29:32,639 --> 00:29:34,359
So already, you
can try to imagine

804
00:29:34,359 --> 00:29:37,159
why we would have a lot
better performance with this.

805
00:29:37,159 --> 00:29:39,320
But it still has some
weird internal details

806
00:29:39,320 --> 00:29:41,474
that impact performance.

807
00:29:41,474 --> 00:29:43,169
To understand these, I have to

808
00:29:43,169 --> 00:29:44,909
use these word block and page.

809
00:29:44,909 --> 00:29:47,270
And I've used both of
those words before.

810
00:29:47,270 --> 00:29:48,909
I've been using block
in this lecture

811
00:29:48,909 --> 00:29:50,330
to refer to the granularity

812
00:29:50,330 --> 00:29:52,090
of the data transfer

813
00:29:52,090 --> 00:29:54,790
between the block
device and software.

814
00:29:54,790 --> 00:29:57,129
And I've used page before
as type of the unit

815
00:29:57,129 --> 00:30:00,149
of caching of memory in
the operating system.

816
00:30:00,149 --> 00:30:02,329
And these words are also used to

817
00:30:02,329 --> 00:30:04,870
talk about how an SSD
works internally,

818
00:30:04,870 --> 00:30:06,270
and they just have absolutely

819
00:30:06,270 --> 00:30:08,049
completely different
meanings in this context.

820
00:30:08,049 --> 00:30:10,129
So my apologies, I didn't
choose the terminology.

821
00:30:10,129 --> 00:30:12,350
I just want to be clear that
when I'm on this slide,

822
00:30:12,350 --> 00:30:14,510
I'm using these words
completely differently.

823
00:30:14,510 --> 00:30:17,459
Okay? So a page is

824
00:30:17,459 --> 00:30:21,420
the unit in which we can either
read or write some data.

825
00:30:21,420 --> 00:30:25,840
Okay? And so I've drawn down
here a small page of data.

826
00:30:25,840 --> 00:30:29,319
And one of the
tricks is or one of

827
00:30:29,319 --> 00:30:31,179
the annoying things is that when

828
00:30:31,179 --> 00:30:33,319
I have a page of data writed,

829
00:30:33,319 --> 00:30:35,780
I cannot rewrite it
with something else,

830
00:30:35,780 --> 00:30:37,359
because that page is
part of something

831
00:30:37,359 --> 00:30:40,179
bigger called a block, right?

832
00:30:40,179 --> 00:30:43,200
And if I want to, I can
erase a whole block,

833
00:30:43,200 --> 00:30:45,559
but I can't just erase
a portion of it.

834
00:30:45,559 --> 00:30:47,059
Has anybody ever played with

835
00:30:47,059 --> 00:30:49,979
an echa sketch?
That's this toy here?

836
00:30:50,270 --> 00:30:53,189
Yeah. So actually a sketch
there are lots of fu,

837
00:30:53,189 --> 00:30:56,729
you could draw on it in
fired detail, right?

838
00:30:56,729 --> 00:30:59,190
But if I want to erase
something, it's cores straight.

839
00:30:59,190 --> 00:31:00,649
I have to shake the whole thing.

840
00:31:00,649 --> 00:31:02,569
So in this case, the fired thing

841
00:31:02,569 --> 00:31:04,209
that's happening
are these pages,

842
00:31:04,209 --> 00:31:06,229
but the erase is cores straight.
That's the whole thing.

843
00:31:06,229 --> 00:31:08,169
So you should really
imagine at SSD,

844
00:31:08,169 --> 00:31:10,989
like, a big array
of these sketches.

845
00:31:10,989 --> 00:31:12,130
I can try to write in the pages,

846
00:31:12,130 --> 00:31:14,540
but then if I want to
change the value at a page,

847
00:31:14,540 --> 00:31:17,049
Well, now I have
a problem, right?

848
00:31:17,049 --> 00:31:19,690
And so that's going to
impact the performance.

849
00:31:19,690 --> 00:31:21,289
I'll kind of make us
think about how we

850
00:31:21,289 --> 00:31:23,829
actually want to
use this device.

851
00:31:23,829 --> 00:31:25,710
So I want to imagine that I've

852
00:31:25,710 --> 00:31:28,109
already ridded all the
pages of the block here,

853
00:31:28,109 --> 00:31:34,849
and so ABCD, and now I want
to replace B with x, right?

854
00:31:34,850 --> 00:31:37,130
So I have two options.

855
00:31:37,130 --> 00:31:40,334
One is that I could
erase the whole thing.

856
00:31:40,334 --> 00:31:42,440
And then I could write x there.

857
00:31:42,440 --> 00:31:44,059
But if I have to do
that, then I'd have to

858
00:31:44,059 --> 00:31:45,679
save ACD and memory and

859
00:31:45,679 --> 00:31:49,319
write those a second
time as well, right?

860
00:31:49,319 --> 00:31:51,180
So I try to write
one page one page,

861
00:31:51,180 --> 00:31:52,579
but then I'm like,
I had to erase

862
00:31:52,579 --> 00:31:54,119
this whole thing. That
took a long time.

863
00:31:54,119 --> 00:31:56,119
I had to write all the pages.

864
00:31:56,119 --> 00:31:58,940
That would be kind of bad.
Right? It would be slow.

865
00:31:58,940 --> 00:32:00,399
So the other thing
that people will more

866
00:32:00,399 --> 00:32:02,340
often do is instead
of writing x there,

867
00:32:02,340 --> 00:32:06,319
they'll say, Let's just write
X somewhere else, right?

868
00:32:06,319 --> 00:32:07,880
So they'll say, Hey,

869
00:32:07,880 --> 00:32:10,220
let's write X over here.

870
00:32:10,220 --> 00:32:12,540
And even though B is garbage,

871
00:32:12,540 --> 00:32:14,260
we're trying to
replace B with x,

872
00:32:14,260 --> 00:32:16,119
we'll just like leave
it there because

873
00:32:16,119 --> 00:32:18,489
it's too expensive to erase it.

874
00:32:18,489 --> 00:32:20,810
If I erase that then I have
to have all this collateral,

875
00:32:20,810 --> 00:32:22,549
I don't want to say
damage, but I have to have

876
00:32:22,549 --> 00:32:25,589
this collateral cost, right?

877
00:32:25,589 --> 00:32:30,509
All right. So, What
about here, right?

878
00:32:30,509 --> 00:32:31,789
So if I do that, that I need to

879
00:32:31,789 --> 00:32:33,189
do some extra book
keeping, right?

880
00:32:33,189 --> 00:32:35,690
So SSDs will usually have
something about of Rb,

881
00:32:35,690 --> 00:32:37,189
and they'll keep track of,

882
00:32:37,189 --> 00:32:39,249
like, well, you know,

883
00:32:39,249 --> 00:32:40,330
instead of the data actually

884
00:32:40,330 --> 00:32:41,509
being where it was
originally here,

885
00:32:41,509 --> 00:32:42,849
in this other place,
they have to have

886
00:32:42,849 --> 00:32:44,729
some mapping that
when you're using it,

887
00:32:44,729 --> 00:32:49,269
and I write to a page specific
location that I read it,

888
00:32:49,269 --> 00:32:51,189
maybe it's different
places internally.

889
00:32:51,189 --> 00:32:52,769
I don't want to think about
that. I just want to get back

890
00:32:52,769 --> 00:32:55,369
the same data that I
wrote to it before.

891
00:32:55,369 --> 00:32:56,969
So that's one thing
that they have to do.

892
00:32:56,969 --> 00:32:59,900
The other thing is
that Eventually,

893
00:32:59,900 --> 00:33:01,100
right, if you're
already out of space,

894
00:33:01,100 --> 00:33:02,059
they'll have to reclaim that.

895
00:33:02,059 --> 00:33:03,780
And what they might do
is they might wait.

896
00:33:03,780 --> 00:33:09,059
In this case, procrastation
is good because right now,

897
00:33:09,059 --> 00:33:10,500
B is garbage, but if I wait,

898
00:33:10,500 --> 00:33:13,180
maybe C and D might
become garbage as well.

899
00:33:13,180 --> 00:33:16,200
Maybe if a lot of that data
that block is garbage,

900
00:33:16,200 --> 00:33:17,859
that it's not so wasteful to

901
00:33:17,859 --> 00:33:20,239
erase the whole thing
and rewrite it, right?

902
00:33:20,239 --> 00:33:21,739
So we kind of want to
procrastate it and hope of

903
00:33:21,739 --> 00:33:23,659
that when we have
to do the work.

904
00:33:23,659 --> 00:33:26,504
We could do a lot of
that at the same time.

905
00:33:26,504 --> 00:33:28,710
So in terms of the strategy

906
00:33:28,710 --> 00:33:30,830
for somebody who's actually
using these things,

907
00:33:30,830 --> 00:33:32,769
what you want to do is

908
00:33:32,769 --> 00:33:34,389
you uh to avoided this
circumstance, right?

909
00:33:34,389 --> 00:33:37,469
B this is slow it kind
of creates this waste.

910
00:33:37,469 --> 00:33:40,409
If you want to use
the SSD effectively,

911
00:33:40,409 --> 00:33:43,070
you uh to write, like,
big files sequentially.

912
00:33:43,070 --> 00:33:44,209
You're to write a little bit of

913
00:33:44,209 --> 00:33:45,490
data here and a little there,

914
00:33:45,490 --> 00:33:47,169
the natural cause
these override.

915
00:33:47,169 --> 00:33:49,549
They'll kind of get
this bad performance

916
00:33:49,549 --> 00:33:52,989
out of your SSD. All right.

917
00:33:52,989 --> 00:33:54,570
Well, I guess I
should just pause

918
00:33:54,570 --> 00:33:56,289
there by question about it.

919
00:33:56,289 --> 00:33:58,110
It's a little bit strange,
right? But that's

920
00:33:58,110 --> 00:33:59,929
how the performance
will play out.

921
00:33:59,929 --> 00:34:06,849
Yeah, right here. Block s

922
00:34:06,849 --> 00:34:11,179
and then like dated
that you Okay.

923
00:34:11,179 --> 00:34:13,659
Yeah, you're saying
that we could

924
00:34:13,659 --> 00:34:15,839
move ACD somewhere else as well,

925
00:34:15,839 --> 00:34:17,299
then just try of
reclaim this block.

926
00:34:17,299 --> 00:34:19,439
Yeah, and they're going to do
something like that, right?

927
00:34:19,439 --> 00:34:21,159
Because once they have to

928
00:34:21,159 --> 00:34:22,899
add this extra
bookkeeping to keep track

929
00:34:22,899 --> 00:34:25,099
of that a given piece

930
00:34:25,099 --> 00:34:26,840
of data could be in
different places,

931
00:34:26,840 --> 00:34:30,339
then would I have to
eventually erase this?

932
00:34:30,339 --> 00:34:31,739
I mean, I could we
use the same block,

933
00:34:31,739 --> 00:34:32,879
or I could be use
a different block

934
00:34:32,879 --> 00:34:34,379
and kind it doesn't
matter if I have

935
00:34:34,379 --> 00:34:35,819
some sort of mapping
structure that

936
00:34:35,819 --> 00:34:37,939
keeps track of where
it actually is, right?

937
00:34:37,939 --> 00:34:39,719
So you'll usually just
try have like some pool,

938
00:34:39,719 --> 00:34:41,319
like these blocks are
ready for writing,

939
00:34:41,319 --> 00:34:43,100
and then of all
the other blocks,

940
00:34:43,100 --> 00:34:44,600
the SST is try to keep

941
00:34:44,600 --> 00:34:46,419
track of how dirty
they are, right?

942
00:34:46,419 --> 00:34:48,559
L, there are some blocks that

943
00:34:48,559 --> 00:34:50,959
might have mostly current data,

944
00:34:50,959 --> 00:34:52,260
and some of mostly garbage.

945
00:34:52,260 --> 00:34:53,359
And we need to free up some

946
00:34:53,359 --> 00:34:54,619
space you want to do
the ones that are

947
00:34:54,619 --> 00:34:57,400
mostly garbage first or you
know, there's other policies.

948
00:34:57,400 --> 00:34:59,419
I don't want to get
too deep into it,

949
00:34:59,419 --> 00:35:00,640
but there's other strategies

950
00:35:00,640 --> 00:35:01,959
you might chose to
figure out, well,

951
00:35:01,959 --> 00:35:03,619
when I clean something
up, there's a bunch of

952
00:35:03,619 --> 00:35:05,979
blocks that have a mix
of garbage and data.

953
00:35:05,979 --> 00:35:07,579
Which one should I clean up to

954
00:35:07,579 --> 00:35:09,359
get the best performance
of the long run?

955
00:35:09,359 --> 00:35:11,060
But yeah, definitely everything

956
00:35:11,060 --> 00:35:12,299
is fluid at this point, right?

957
00:35:12,299 --> 00:35:13,819
If we keep track of
where the data is,

958
00:35:13,819 --> 00:35:15,579
it doesn't have to be
in the same place.

959
00:35:15,579 --> 00:35:19,640
Yeah, Excellent point. Yeah,
other comets or questions.

960
00:35:22,730 --> 00:35:24,990
Cool. So I want to compare

961
00:35:24,990 --> 00:35:26,889
the performance
characteristics between these.

962
00:35:26,889 --> 00:35:28,189
There's different
metrics when I'm

963
00:35:28,189 --> 00:35:29,670
comparing storage resource.

964
00:35:29,670 --> 00:35:31,189
I can think about the capacity.

965
00:35:31,189 --> 00:35:33,209
A latency is how
long it might take

966
00:35:33,209 --> 00:35:37,150
to transfer just like
one small piece of data.

967
00:35:37,150 --> 00:35:38,969
Iops is related to that,

968
00:35:38,969 --> 00:35:40,870
so that's IO
operations per second.

969
00:35:40,870 --> 00:35:43,729
So the IO operations
are read or right.

970
00:35:43,729 --> 00:35:46,710
And when it's ask me how
many I could do per second,

971
00:35:46,710 --> 00:35:48,050
that will depend on the latency,

972
00:35:48,050 --> 00:35:49,409
but it will also
depend on how many

973
00:35:49,409 --> 00:35:50,930
I could do in parallel.

974
00:35:50,930 --> 00:35:52,149
So these reads or

975
00:35:52,149 --> 00:35:54,049
writes are generally
considered to be small.

976
00:35:54,049 --> 00:35:55,669
And then throughput
would just be

977
00:35:55,669 --> 00:35:57,750
how many bytes I could
transfer per second?

978
00:35:57,750 --> 00:36:00,090
And that probably
depends on by workload

979
00:36:00,090 --> 00:36:02,889
by doing kind of a sequential
pattern or added pattern.

980
00:36:02,889 --> 00:36:06,124
I just put Oh, let me go back.

981
00:36:06,124 --> 00:36:11,119
I put over here, relative
to S hard drives, well,

982
00:36:11,119 --> 00:36:12,319
what I say about SSDs,

983
00:36:12,319 --> 00:36:13,919
and this is a little
bit, you know,

984
00:36:13,919 --> 00:36:15,659
handwavy, about
quantifying things

985
00:36:15,659 --> 00:36:17,679
here because both devices
are always changing.

986
00:36:17,679 --> 00:36:19,399
So in terms of capacity,

987
00:36:19,399 --> 00:36:21,379
like how many bytes
we just store,

988
00:36:21,379 --> 00:36:24,019
SSDs are much worse
per dollar, right?

989
00:36:24,019 --> 00:36:27,480
You have to pay a lot more
for SSDs per byte of storage.

990
00:36:27,480 --> 00:36:29,000
In terms of latency,

991
00:36:29,000 --> 00:36:32,579
SSDs are much better because
there's no moving parts.

992
00:36:32,579 --> 00:36:35,459
If I just want to read
one little block of data,

993
00:36:35,459 --> 00:36:36,980
I can get it back very quickly.

994
00:36:36,980 --> 00:36:40,100
If I'm talking about
rad i ops per second,

995
00:36:40,100 --> 00:36:41,339
I'm randomly reading little

996
00:36:41,339 --> 00:36:42,964
pieces of data all
over the place,

997
00:36:42,964 --> 00:36:45,169
Estes are fantastic about

998
00:36:45,169 --> 00:36:47,349
that because there's low
lats no movie parts.

999
00:36:47,349 --> 00:36:49,770
I can do a bunch of those
things in parallel,

1000
00:36:49,770 --> 00:36:53,250
right? What about throughput?

1001
00:36:53,250 --> 00:36:55,049
So, let's say I'm
just sequentially

1002
00:36:55,049 --> 00:36:57,429
accessing a bunch of data.

1003
00:36:57,429 --> 00:37:00,329
Hard disk drives are actually
pretty good at that, right?

1004
00:37:00,329 --> 00:37:01,810
Le once you get the
head in position

1005
00:37:01,810 --> 00:37:03,850
and you start
transferring bytes,

1006
00:37:03,850 --> 00:37:05,489
it could be pretty fast, right?

1007
00:37:05,489 --> 00:37:07,190
So SSDs are probably
a little bit faster,

1008
00:37:07,190 --> 00:37:09,290
but that might be in
the same ballpark.

1009
00:37:09,290 --> 00:37:12,609
I mean, it all depends on
how high SSD you have.

1010
00:37:12,609 --> 00:37:14,790
But hard disks are pretty
good at throughput transfer.

1011
00:37:14,790 --> 00:37:17,469
O, you'll say, SSDs are
a little bit better.

1012
00:37:17,469 --> 00:37:19,229
What about if I have

1013
00:37:19,229 --> 00:37:21,130
measuring my throughput
bytes per second,

1014
00:37:21,130 --> 00:37:22,410
and I'm either randomly

1015
00:37:22,410 --> 00:37:24,840
writing data or
randomly reading data?

1016
00:37:24,840 --> 00:37:27,869
SSDs are going to be
better in either case,

1017
00:37:27,869 --> 00:37:29,169
but for the random write taste,

1018
00:37:29,169 --> 00:37:30,849
I have to worry about
that block thing,

1019
00:37:30,849 --> 00:37:32,089
the block clean up.

1020
00:37:32,089 --> 00:37:35,589
How important does that?
It might depend, right?

1021
00:37:35,589 --> 00:37:37,949
If I'm just like
cost like writing to

1022
00:37:37,949 --> 00:37:40,529
my SSD randomly all the time,

1023
00:37:40,529 --> 00:37:43,009
eventually, I may run out
of blocks to write to it.

1024
00:37:43,009 --> 00:37:44,989
It's going to be constantly
garbage collecting them,

1025
00:37:44,989 --> 00:37:47,149
and that would be Trosty, right?

1026
00:37:47,149 --> 00:37:49,029
One of the nice things
about the SSDs is

1027
00:37:49,029 --> 00:37:51,069
that I could have a burst of
a bunch of random writes,

1028
00:37:51,069 --> 00:37:53,109
and that if I don't
write to it for a while,

1029
00:37:53,109 --> 00:37:54,469
then it could try in

1030
00:37:54,469 --> 00:37:56,229
the background to clean
things up so that when

1031
00:37:56,229 --> 00:37:57,969
I have another sudden burst

1032
00:37:57,969 --> 00:37:59,469
of a bunch of rights
would be okay, right?

1033
00:37:59,469 --> 00:38:01,089
So if we're doing a
bunch of random rights,

1034
00:38:01,089 --> 00:38:02,869
we have to worry
about that with SSDs.

1035
00:38:02,869 --> 00:38:04,770
You can see, in terms
of performance,

1036
00:38:04,770 --> 00:38:06,369
with the hard drive,
there's a bunch of things

1037
00:38:06,369 --> 00:38:08,070
you have to worry about
to get good performance.

1038
00:38:08,070 --> 00:38:10,589
With SSDs, the one thing
you really have to worry

1039
00:38:10,589 --> 00:38:11,870
about is am I randomly

1040
00:38:11,870 --> 00:38:13,410
writing data a lot
of different places?

1041
00:38:13,410 --> 00:38:14,549
If you are, then you might have

1042
00:38:14,549 --> 00:38:15,810
a problem, but in general,

1043
00:38:15,810 --> 00:38:17,470
SSDs, a lot of patterns,

1044
00:38:17,470 --> 00:38:19,329
it straight be pretty fast at.

1045
00:38:19,329 --> 00:38:21,189
Have you got any
questions about that from

1046
00:38:21,189 --> 00:38:25,049
Parison? Yeah,
question right here.

1047
00:38:34,040 --> 00:38:37,099
Yeah. So you just proposed idea,

1048
00:38:37,099 --> 00:38:38,259
which is cell just say that.

1049
00:38:38,259 --> 00:38:40,199
So, maybe the application

1050
00:38:40,199 --> 00:38:42,840
itself is doing a bunch
of random rights.

1051
00:38:42,840 --> 00:38:46,399
But when we write
applications, right?

1052
00:38:46,399 --> 00:38:48,519
No probably none of us

1053
00:38:48,519 --> 00:38:50,299
have had to actually worry
about this where we're like,

1054
00:38:50,299 --> 00:38:51,759
say, I'm writing
to this block on

1055
00:38:51,759 --> 00:38:53,760
my SSD or that block on my SSD.

1056
00:38:53,760 --> 00:38:54,539
We are doing that.

1057
00:38:54,539 --> 00:38:55,759
What we're really
doing is we're writing

1058
00:38:55,759 --> 00:38:59,939
to maybe a database or you
do a file system, like that.

1059
00:38:59,939 --> 00:39:02,279
That's to ultimately manage
those blocks for us.

1060
00:39:02,279 --> 00:39:03,479
And so it's totally
possible that

1061
00:39:03,479 --> 00:39:05,419
an application have
some random rights,

1062
00:39:05,419 --> 00:39:06,560
and some layer of software

1063
00:39:06,560 --> 00:39:08,259
could convert those
random rights.

1064
00:39:08,259 --> 00:39:09,979
Into something sequential that's

1065
00:39:09,979 --> 00:39:11,519
better for the device, right?

1066
00:39:11,519 --> 00:39:13,679
So you can imagine this from
the perspective of like,

1067
00:39:13,679 --> 00:39:14,900
Well, I'm trying to
write an application

1068
00:39:14,900 --> 00:39:16,060
that's SSD friendly.

1069
00:39:16,060 --> 00:39:17,739
It's also possible
that you could have

1070
00:39:17,739 --> 00:39:20,399
a SSD friendly database that

1071
00:39:20,399 --> 00:39:21,779
makes the application
not need to

1072
00:39:21,779 --> 00:39:23,379
worry about it.
Excellent point, right?

1073
00:39:23,379 --> 00:39:24,779
So we have to make things

1074
00:39:24,779 --> 00:39:26,700
sequential to get a performance.

1075
00:39:26,700 --> 00:39:28,420
That doesn't mean that
every person writing

1076
00:39:28,420 --> 00:39:31,459
every application has to
necessarily worry about it.

1077
00:39:31,459 --> 00:39:32,539
If they're building on top of

1078
00:39:32,539 --> 00:39:33,799
somebody else that
worries about it

1079
00:39:33,799 --> 00:39:36,559
for you. Yeah, great point.

1080
00:39:36,559 --> 00:39:39,519
Other points or
questions people have.

1081
00:39:40,360 --> 00:39:43,439
Alright, cool. So that's the
hardware we're dealing with.

1082
00:39:43,439 --> 00:39:45,619
I just want to show
some quick other things

1083
00:39:45,619 --> 00:39:47,279
that might happen here.

1084
00:39:47,279 --> 00:39:49,139
One of the things
we might do is if I

1085
00:39:49,139 --> 00:39:51,690
have a big hard
drive or a big SSD,

1086
00:39:51,690 --> 00:39:54,320
I could partition it
in different parts.

1087
00:39:54,320 --> 00:39:55,700
And kind of logically,

1088
00:39:55,700 --> 00:39:58,359
each of those will appear
like it's a wed device,

1089
00:39:58,359 --> 00:40:00,780
even though there's
only one real device.

1090
00:40:00,780 --> 00:40:02,859
Onlytx, if I go under Slash Dv,

1091
00:40:02,859 --> 00:40:04,240
I can like L S files,

1092
00:40:04,240 --> 00:40:06,380
and I can see these
different partitions.

1093
00:40:06,380 --> 00:40:09,259
So SDA and SDB would be

1094
00:40:09,259 --> 00:40:13,159
referring to two different
actual hard drives or SSDs.

1095
00:40:13,159 --> 00:40:15,159
And then all these other
things like SDA one,

1096
00:40:15,159 --> 00:40:17,920
SDB one, SDA 14.

1097
00:40:17,920 --> 00:40:21,499
Those are referring to
partitions of that, right?

1098
00:40:21,499 --> 00:40:23,239
So often we'll have
kind of a big device,

1099
00:40:23,239 --> 00:40:24,999
and we'll carve it
it a smaller chucks.

1100
00:40:24,999 --> 00:40:26,895
That's called partitioning.

1101
00:40:26,895 --> 00:40:29,829
The opposite of
partitioning is that we

1102
00:40:29,829 --> 00:40:32,230
might actually have a bunch
of different devices,

1103
00:40:32,230 --> 00:40:33,689
and we want to make it look like

1104
00:40:33,689 --> 00:40:36,949
one giant device with
a lot of capacity.

1105
00:40:36,949 --> 00:40:40,550
And the technology that
does that is called raid.

1106
00:40:40,550 --> 00:40:41,949
And so raid ss for

1107
00:40:41,949 --> 00:40:43,749
a redundant array of
an expensive disks.

1108
00:40:43,749 --> 00:40:45,370
Who knows? Maybe
they are expensive.

1109
00:40:45,370 --> 00:40:48,750
But the idea is that we have
a bunch of different disks,

1110
00:40:48,750 --> 00:40:51,235
and a raid controller
can make it appear.

1111
00:40:51,235 --> 00:40:53,679
Like it's one big desk, right?

1112
00:40:53,679 --> 00:40:55,599
And why is it redundant?

1113
00:40:55,599 --> 00:40:57,399
Well, it's not always
redundant actually, right?

1114
00:40:57,399 --> 00:40:59,680
So maybe it's not always
red it's always expensive.

1115
00:40:59,680 --> 00:41:01,699
But sometimes what we
might want to worry about

1116
00:41:01,699 --> 00:41:04,039
is if I have all of these SSDs,

1117
00:41:04,039 --> 00:41:05,780
and one of them
eventually fails,

1118
00:41:05,780 --> 00:41:08,179
I don't want to
necessarily lose data.

1119
00:41:08,179 --> 00:41:10,059
So sometimes a raid
controller might

1120
00:41:10,059 --> 00:41:12,379
heat multiple copies of data
in different places or have

1121
00:41:12,379 --> 00:41:14,199
other forms of redundancy so

1122
00:41:14,199 --> 00:41:17,100
that we feel like we
have this giant device,

1123
00:41:17,100 --> 00:41:19,300
and if one of the
actual devices fails,

1124
00:41:19,300 --> 00:41:20,839
we don't lose any data, right?

1125
00:41:20,839 --> 00:41:22,219
We can have a bunch of cheap,

1126
00:41:22,219 --> 00:41:24,399
bad desks that we
could appear like

1127
00:41:24,399 --> 00:41:26,899
one big, reliable desk, right?

1128
00:41:26,899 --> 00:41:29,019
That's rain. Have you

1129
00:41:29,019 --> 00:41:31,339
know any question about
either partitioning or raid?

1130
00:41:31,339 --> 00:41:36,710
Yeah, right here.
Possible. For SSD.

1131
00:41:36,710 --> 00:41:40,289
S three Oh, you're

1132
00:41:40,289 --> 00:41:43,509
say say you have three
HDDs, and three SSDs.

1133
00:41:43,509 --> 00:41:47,309
And you have a rad controller
that manages both of them.

1134
00:41:47,309 --> 00:41:49,369
So I'm not aware
of, like in theory,

1135
00:41:49,369 --> 00:41:51,029
you could do anything, right?

1136
00:41:51,029 --> 00:41:55,590
Like the implementations
that I have seen,

1137
00:41:55,590 --> 00:41:58,690
they do well when the
devices are similar.

1138
00:41:58,690 --> 00:42:00,750
They have similar
performance properties

1139
00:42:00,750 --> 00:42:02,709
and stuff like that.

1140
00:42:02,709 --> 00:42:04,649
They generally aren't
going to realize, like,

1141
00:42:04,649 --> 00:42:07,010
Oh, like, this one's fast
or this one's slower.

1142
00:42:07,010 --> 00:42:08,569
Let's take advantage
of that, right?

1143
00:42:08,569 --> 00:42:10,849
So generally, they'd
use raid to kind of

1144
00:42:10,849 --> 00:42:12,110
have a bunch of similar devices

1145
00:42:12,110 --> 00:42:13,829
appear like one big device.

1146
00:42:13,829 --> 00:42:15,909
Now, you could totally
have a computer that has

1147
00:42:15,909 --> 00:42:18,270
both fast SSDs and
slow hard drisks.

1148
00:42:18,270 --> 00:42:20,470
Then generally at a higher
level, maybe in software,

1149
00:42:20,470 --> 00:42:22,209
you might write
like a database or

1150
00:42:22,209 --> 00:42:25,049
some application that's smart
about using both of those.

1151
00:42:25,049 --> 00:42:26,849
But what generally happen
at the raid level?

1152
00:42:26,849 --> 00:42:28,370
Rd is usually kind of simpler.

1153
00:42:28,370 --> 00:42:31,009
Making uniform things appear,
like, one bigger thing.

1154
00:42:31,009 --> 00:42:32,629
Yeah, its excellent ought thoug,

1155
00:42:32,629 --> 00:42:33,510
right you could imagine

1156
00:42:33,510 --> 00:42:34,689
building a different
kind of raid.

1157
00:42:34,689 --> 00:42:36,489
That's smart about it, right?

1158
00:42:36,489 --> 00:42:39,810
Yeah, Other questions or ideas.

1159
00:42:40,360 --> 00:42:42,480
All right. Cool.

1160
00:42:42,480 --> 00:42:44,279
So we've seen lots

1161
00:42:44,279 --> 00:42:45,740
of different ways we
have block devices.

1162
00:42:45,740 --> 00:42:47,779
You have an SST, you can
have a hard disk drive.

1163
00:42:47,779 --> 00:42:49,759
You can have some
combination of those.

1164
00:42:49,759 --> 00:42:53,439
You can have some fraction
of one with partitioning.

1165
00:42:53,439 --> 00:42:54,980
Once we have a block device,

1166
00:42:54,980 --> 00:42:57,879
then we need to have some
way of managing it, right?

1167
00:42:57,879 --> 00:42:59,059
Imagine how annoying would be

1168
00:42:59,059 --> 00:43:00,539
if you want to save some data,

1169
00:43:00,539 --> 00:43:03,725
and you have to say, like,
I want to write my data.

1170
00:43:03,725 --> 00:43:05,929
And blocks like three,

1171
00:43:05,929 --> 00:43:07,769
six and seven, or you
have to figure out

1172
00:43:07,769 --> 00:43:09,789
which blocks are free.
You'd have to break it up.

1173
00:43:09,789 --> 00:43:12,069
And so writing data
directly in blocks is

1174
00:43:12,069 --> 00:43:13,309
something that's difficult and

1175
00:43:13,309 --> 00:43:14,630
we wouldn't want to do it often.

1176
00:43:14,630 --> 00:43:17,089
And what's easier is
just writing a file.

1177
00:43:17,089 --> 00:43:18,429
When I just write a file,

1178
00:43:18,429 --> 00:43:20,329
it's like whatever
size I want to be.

1179
00:43:20,329 --> 00:43:22,989
And that data ultimately
ends up in different blocks,

1180
00:43:22,989 --> 00:43:25,029
but I don't really
think about it, right?

1181
00:43:25,029 --> 00:43:26,489
So why is it

1182
00:43:26,489 --> 00:43:29,449
so why do we have that
convenienal to write a file?

1183
00:43:29,449 --> 00:43:31,690
Well, there's a piece of
software called a file system.

1184
00:43:31,690 --> 00:43:33,229
The file system lets us write

1185
00:43:33,229 --> 00:43:34,969
these files of any size we want.

1186
00:43:34,969 --> 00:43:37,310
And it figures out here
are some free blocks,

1187
00:43:37,310 --> 00:43:40,175
and it splits up our data
across these different blocks.

1188
00:43:40,175 --> 00:43:42,639
And so what we want to
do if we want to write

1189
00:43:42,639 --> 00:43:44,859
applications that are kind
of using storage well,

1190
00:43:44,859 --> 00:43:46,239
we have to understand
a bit about how

1191
00:43:46,239 --> 00:43:47,359
the actual hardware works,

1192
00:43:47,359 --> 00:43:49,059
and we have to understand
a little bit about what

1193
00:43:49,059 --> 00:43:51,779
the file system might be
doing on top of that.

1194
00:43:51,779 --> 00:43:54,274
The world all user is abstract.

1195
00:43:54,274 --> 00:43:57,370
The file system is
abstracting storage.

1196
00:43:57,370 --> 00:43:59,150
If I write a file,
I'm also writing

1197
00:43:59,150 --> 00:44:01,769
block individual blocks, but
I'm not thinking about that.

1198
00:44:01,769 --> 00:44:04,090
That's headed from
me. Abstraction hides

1199
00:44:04,090 --> 00:44:05,629
ugly details that I
don't want to have

1200
00:44:05,629 --> 00:44:07,369
to think about all the time.

1201
00:44:07,369 --> 00:44:09,669
There's lots of different
file systems out there,

1202
00:44:09,669 --> 00:44:11,489
and the most common or kind of

1203
00:44:11,489 --> 00:44:13,490
basic one is what I call
a local file system.

1204
00:44:13,490 --> 00:44:14,930
But I have a local file system.

1205
00:44:14,930 --> 00:44:17,289
I have some code that's
maybe read or write a file,

1206
00:44:17,289 --> 00:44:19,570
and that is to figure
out on my behalf,

1207
00:44:19,570 --> 00:44:24,049
which blocks to actually read
or write to achieve that.

1208
00:44:25,270 --> 00:44:27,930
Here's six different
kinds of file systems.

1209
00:44:27,930 --> 00:44:29,129
I'm just going to
go through one by

1210
00:44:29,129 --> 00:44:31,689
one that I want you
to remember, right?

1211
00:44:31,689 --> 00:44:34,449
So I have that local file
system on the top left.

1212
00:44:34,449 --> 00:44:37,370
When we're using docker,

1213
00:44:37,370 --> 00:44:39,750
And I create a new container.

1214
00:44:39,750 --> 00:44:42,570
It has a new file
system with new files.

1215
00:44:42,570 --> 00:44:44,929
Now, fortunately,
I don't have to

1216
00:44:44,929 --> 00:44:47,270
buy a new hard drive every
time I start a new container.

1217
00:44:47,270 --> 00:44:48,829
That would be awful, right?

1218
00:44:48,829 --> 00:44:52,450
And so the file system that
I'm giving to that container,

1219
00:44:52,450 --> 00:44:54,589
what it's actually doing is

1220
00:44:54,589 --> 00:44:57,530
it's saving its data at
a different file system,

1221
00:44:57,530 --> 00:44:59,490
probably some local file system.

1222
00:44:59,490 --> 00:45:01,089
So there's some
file systems like

1223
00:45:01,089 --> 00:45:03,369
overlay FS is the one
that Docker uses,

1224
00:45:03,369 --> 00:45:04,789
where I store files in there,

1225
00:45:04,789 --> 00:45:06,750
that it takes some of
those files and it stores

1226
00:45:06,750 --> 00:45:08,909
at a different local
file system, right?

1227
00:45:08,909 --> 00:45:10,869
So we might often have
file systems on top of

1228
00:45:10,869 --> 00:45:13,450
file systems on top
of block devices.

1229
00:45:13,450 --> 00:45:16,590
Right? Sometimes people want
to read and write files,

1230
00:45:16,590 --> 00:45:17,789
but they wanted to
be really fast,

1231
00:45:17,789 --> 00:45:19,210
and they want it
to be temporary.

1232
00:45:19,210 --> 00:45:21,930
And so even though they like
to think in terms of files,

1233
00:45:21,930 --> 00:45:23,250
they want it to be in memory.

1234
00:45:23,250 --> 00:45:26,310
And so we have
memory file systems.

1235
00:45:26,310 --> 00:45:28,289
The big one is called TPS.

1236
00:45:28,289 --> 00:45:29,549
Kind of makes sense,
right? You have

1237
00:45:29,549 --> 00:45:31,490
temporary files there
because when you reboot,

1238
00:45:31,490 --> 00:45:32,610
all those files are broad,

1239
00:45:32,610 --> 00:45:34,549
but it's really fast for
we're using that, right?

1240
00:45:34,549 --> 00:45:38,529
So a TPS instead of using a
block device might use Rab.

1241
00:45:39,360 --> 00:45:42,419
Oftentimes, the operating
system wants to give us

1242
00:45:42,419 --> 00:45:44,039
different information
about processes

1243
00:45:44,039 --> 00:45:44,719
or things like that.

1244
00:45:44,719 --> 00:45:47,579
And you can imagine different
APIs they could build.

1245
00:45:47,579 --> 00:45:49,579
But why build something new

1246
00:45:49,579 --> 00:45:52,340
when everybody can just
learn how to use files.

1247
00:45:52,340 --> 00:45:55,419
And so there's things called
pseudo file systems, right?

1248
00:45:55,419 --> 00:45:56,560
In a pseudo file system,

1249
00:45:56,560 --> 00:45:59,139
what it might do is it It

1250
00:45:59,139 --> 00:46:00,479
might look like I have a file

1251
00:46:00,479 --> 00:46:01,759
for every process
that's running.

1252
00:46:01,759 --> 00:46:04,879
When I read that file, I can
see that the data that file

1253
00:46:04,879 --> 00:46:06,200
would tell me like
how much memory

1254
00:46:06,200 --> 00:46:08,639
that process is using, right?

1255
00:46:08,639 --> 00:46:10,399
Like that information about how

1256
00:46:10,399 --> 00:46:11,579
much memory a process using,

1257
00:46:11,579 --> 00:46:14,059
it's not stored in a disk
anyware in real file.

1258
00:46:14,059 --> 00:46:15,780
It's just a pseudo file system.

1259
00:46:15,780 --> 00:46:18,820
The main one that we need to
know is called the Proc FS.

1260
00:46:18,820 --> 00:46:20,340
That's a process file system.

1261
00:46:20,340 --> 00:46:21,679
There's no real files there,

1262
00:46:21,679 --> 00:46:22,979
but it looks like
there are files,

1263
00:46:22,979 --> 00:46:26,600
and when I read them, I
can learn about my system.

1264
00:46:27,760 --> 00:46:30,259
How many people have ever

1265
00:46:30,259 --> 00:46:32,280
gone out to the CS lab and saved

1266
00:46:32,280 --> 00:46:34,319
some files and then draw on
to a different machine and

1267
00:46:34,319 --> 00:46:35,399
saw those files are still

1268
00:46:35,399 --> 00:46:37,644
there? Has anybody
ever done that?

1269
00:46:37,644 --> 00:46:40,330
A few of you, that essks

1270
00:46:40,330 --> 00:46:42,429
to something called a
network file system, right?

1271
00:46:42,429 --> 00:46:44,410
So one network file
system is called NFS,

1272
00:46:44,410 --> 00:46:46,150
the one of the CS
lab is called AFS,

1273
00:46:46,150 --> 00:46:48,310
that's a different type
of network file system.

1274
00:46:48,310 --> 00:46:52,370
And the idea here is that we
have some type of server.

1275
00:46:52,370 --> 00:46:53,830
And on that server,

1276
00:46:53,830 --> 00:46:56,109
there is maybe a
local file system,

1277
00:46:56,109 --> 00:46:57,549
storing data on some desk.

1278
00:46:57,549 --> 00:46:59,169
And then on top of
that, what we have is

1279
00:46:59,169 --> 00:47:01,929
a network file system
server, right?

1280
00:47:01,929 --> 00:47:02,769
And it's there.

1281
00:47:02,769 --> 00:47:04,089
And what that's trying
to do is it's try to

1282
00:47:04,089 --> 00:47:06,550
let other people on other
machines see those files.

1283
00:47:06,550 --> 00:47:09,895
So if I have some code running
on a separate machine,

1284
00:47:09,895 --> 00:47:11,859
It's going to be using

1285
00:47:11,859 --> 00:47:14,540
an NFS file system
that is there locally,

1286
00:47:14,540 --> 00:47:16,839
and that NFS file system
is going to be doing

1287
00:47:16,839 --> 00:47:19,259
remote procedure calls
to that NFS server.

1288
00:47:19,259 --> 00:47:20,639
So if I read a file over here,

1289
00:47:20,639 --> 00:47:22,119
I send the request
over the server,

1290
00:47:22,119 --> 00:47:24,439
get the data there,
and then send it back.

1291
00:47:24,439 --> 00:47:25,700
That's great because it feels

1292
00:47:25,700 --> 00:47:26,820
like I'm just reading files,

1293
00:47:26,820 --> 00:47:29,160
even though those files
are not on my computer.

1294
00:47:29,160 --> 00:47:29,739
I could jump to

1295
00:47:29,739 --> 00:47:31,119
a different computer and
have the same set off,

1296
00:47:31,119 --> 00:47:32,620
and I could see those same files

1297
00:47:32,620 --> 00:47:34,040
that I created elsewhere.

1298
00:47:34,040 --> 00:47:35,990
So we need to have
network file system.

1299
00:47:35,990 --> 00:47:38,980
As well, right? And then
where are we headed?

1300
00:47:38,980 --> 00:47:40,039
After the mid term,

1301
00:47:40,039 --> 00:47:41,160
one of the things we're
going to be spending

1302
00:47:41,160 --> 00:47:43,500
a lot of time on is
distributed systems.

1303
00:47:43,500 --> 00:47:44,840
And particularly we want
to see what happens

1304
00:47:44,840 --> 00:47:46,300
if I have a distributed
file system.

1305
00:47:46,300 --> 00:47:48,760
And the w where we learned
is the Dup file system.

1306
00:47:48,760 --> 00:47:50,679
In that case, the Du
file system is going to

1307
00:47:50,679 --> 00:47:52,680
have maybe like hundreds
or thousands of machines.

1308
00:47:52,680 --> 00:47:54,619
I's star to be storing
data across those.

1309
00:47:54,619 --> 00:47:56,400
But it's just started to
feel like a file system,

1310
00:47:56,400 --> 00:47:58,040
that's where we have
some big files.

1311
00:47:58,040 --> 00:47:59,400
Of course if you have
hundreds of machines,

1312
00:47:59,400 --> 00:48:01,499
these files can be quite large.

1313
00:48:01,499 --> 00:48:03,059
Do people have any
questions about

1314
00:48:03,059 --> 00:48:04,740
these different kinds
of file systems

1315
00:48:04,740 --> 00:48:07,440
or the different purposes
of file systems?

1316
00:48:13,470 --> 00:48:17,409
All right. So I want to look a

1317
00:48:17,409 --> 00:48:18,529
little bit more closely at

1318
00:48:18,529 --> 00:48:20,669
the local file system, because
that's often the base.

1319
00:48:20,669 --> 00:48:20,909
Right?

1320
00:48:20,909 --> 00:48:23,409
At of these other file systems
are based on top of it.

1321
00:48:23,409 --> 00:48:25,029
And somebody I
imagine in this case,

1322
00:48:25,029 --> 00:48:27,209
I have two kilobyte blocks,
and I have a few here.

1323
00:48:27,209 --> 00:48:28,589
And so the question is, how does

1324
00:48:28,589 --> 00:48:30,730
the local file system
use different blocks?

1325
00:48:30,730 --> 00:48:32,789
There's actually lots of
different ways you could do it,

1326
00:48:32,789 --> 00:48:34,109
a lot of different strategies.

1327
00:48:34,109 --> 00:48:35,029
I'm just trying to show

1328
00:48:35,029 --> 00:48:36,529
an example of one
way you might do

1329
00:48:36,529 --> 00:48:37,770
it to kind of give you a general

1330
00:48:37,770 --> 00:48:39,779
idea of what they might do.

1331
00:48:39,779 --> 00:48:42,369
First off, they want
to have some notion of

1332
00:48:42,369 --> 00:48:45,769
file that is really the
stake from any name,

1333
00:48:45,769 --> 00:48:47,469
what we actually see
is there's ways to

1334
00:48:47,469 --> 00:48:49,469
have multiple names
for the same file.

1335
00:48:49,469 --> 00:48:52,629
And so the technical
term is ode, right?

1336
00:48:52,629 --> 00:48:56,730
And so an ode can refer
to some number of bytes.

1337
00:48:56,730 --> 00:48:58,349
You just think of an iod as

1338
00:48:58,349 --> 00:49:00,270
somebody that's
giving me file data,

1339
00:49:00,270 --> 00:49:01,750
but not a file name.

1340
00:49:01,750 --> 00:49:05,189
And so what we can do is we
can put some ides in a block.

1341
00:49:05,189 --> 00:49:06,670
I imagine that's 1 kilobyte.

1342
00:49:06,670 --> 00:49:07,809
And what it'll do is it'll

1343
00:49:07,809 --> 00:49:10,609
have basically pointers
to different blocks.

1344
00:49:10,609 --> 00:49:13,709
So I guess this ode zero
has blocks two and four,

1345
00:49:13,709 --> 00:49:15,070
and it'll have some metadata.

1346
00:49:15,070 --> 00:49:16,469
It might tell me that

1347
00:49:16,469 --> 00:49:18,289
that file is only 3
kilobytes, right?

1348
00:49:18,289 --> 00:49:21,469
So I'm not really using
all of my second block.

1349
00:49:21,469 --> 00:49:23,330
Right? In this case,
that files fragmented,

1350
00:49:23,330 --> 00:49:24,669
it's not contiguous at disk.

1351
00:49:24,669 --> 00:49:26,030
Sometimes you write
an application

1352
00:49:26,030 --> 00:49:27,909
that's like read
data sequentially,

1353
00:49:27,909 --> 00:49:29,330
but takes the file system,

1354
00:49:29,330 --> 00:49:30,869
and it actually ends
up random, right?

1355
00:49:30,869 --> 00:49:34,939
Which is not great.
What about directories?

1356
00:49:34,939 --> 00:49:38,100
Well, directories are really
kind of special files,

1357
00:49:38,100 --> 00:49:40,439
and so I've shown
one here, right?

1358
00:49:40,439 --> 00:49:42,439
So I've added 01,

1359
00:49:42,439 --> 00:49:44,179
and that just has blocks three.

1360
00:49:44,179 --> 00:49:47,619
And I have some data inside
of that special file.

1361
00:49:47,619 --> 00:49:50,859
And what is that data inside
of a special directory file?

1362
00:49:50,859 --> 00:49:53,000
Well, it'll be a
bunch of file names

1363
00:49:53,000 --> 00:49:55,299
referring to IO numbers, right?

1364
00:49:55,299 --> 00:49:58,499
So file dot text is
referring to 00 over here.

1365
00:49:58,499 --> 00:50:02,159
F 00, I can get the data
inside of that file, right?

1366
00:50:02,159 --> 00:50:04,039
Things like these extenches
don't mean anything.

1367
00:50:04,039 --> 00:50:06,319
It's just for kind of
human documentation.

1368
00:50:06,319 --> 00:50:07,939
And there's no reason
I couldn't have

1369
00:50:07,939 --> 00:50:10,499
the same O number in
different directories, right?

1370
00:50:10,499 --> 00:50:11,860
That same IO would
have different

1371
00:50:11,860 --> 00:50:13,900
names in different places.

1372
00:50:13,900 --> 00:50:16,960
Each file system
has a root factory.

1373
00:50:16,960 --> 00:50:18,100
So I might say that iO.

1374
00:50:18,100 --> 00:50:19,400
One is the root factory

1375
00:50:19,400 --> 00:50:21,199
from which I can find
everything else.

1376
00:50:21,199 --> 00:50:24,699
And would I have a new
desk, I have to format it.

1377
00:50:24,699 --> 00:50:26,540
I have to create all these
initial stata structure.

1378
00:50:26,540 --> 00:50:28,200
I have to create some ios create

1379
00:50:28,200 --> 00:50:30,319
an empty root drator,
all those things.

1380
00:50:30,319 --> 00:50:31,739
That's called formatting, right?

1381
00:50:31,739 --> 00:50:33,279
So if you get a
new empty device,

1382
00:50:33,279 --> 00:50:35,319
you're going to have to format
it before you can use it.

1383
00:50:35,319 --> 00:50:37,059
Alright, fantastic.
We'll there and

1384
00:50:37,059 --> 00:50:40,000
feel free to come up and chat
if you have any questions.
